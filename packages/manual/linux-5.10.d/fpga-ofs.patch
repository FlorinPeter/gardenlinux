https://github.com/OPAE/linux-dfl/wiki

diff -Nur org/debian/patches/fpga-ofs/0001-fpga-dfl-fix-the-definitions-of-type-feature_id-for-.patch new/debian/patches/fpga-ofs/0001-fpga-dfl-fix-the-definitions-of-type-feature_id-for-.patch
--- org/debian/patches/fpga-ofs/0001-fpga-dfl-fix-the-definitions-of-type-feature_id-for-.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0001-fpga-dfl-fix-the-definitions-of-type-feature_id-for-.patch	2021-07-20 06:17:11.300845163 +0200
@@ -0,0 +1,93 @@
+From 986ac76c99741afd8488ced585085b567586d900 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Thu, 24 Sep 2020 14:34:07 +0800
+Subject: [PATCH 001/149] fpga: dfl: fix the definitions of type & feature_id
+ for dfl devices
+
+The value of the field dfl_device.type comes from the 12 bits register
+field DFH_ID according to DFL spec. So this patch changes the definition
+of the type field to u16.
+
+Also it is not necessary to illustrate the valid bits of the type field
+in comments. Instead we should explicitly define the possible values in
+the enumeration type for it, because they are shared by hardware spec.
+We should not let the compiler decide these values.
+
+Similar changes are also applied to dfl_device.feature_id.
+
+This patch also fixed the MODALIAS format according to the changes
+above.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+----
+v9: no change
+v10: no change
+---
+ drivers/fpga/dfl.c |  3 +--
+ drivers/fpga/dfl.h | 14 +++++++-------
+ 2 files changed, 8 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index b450870b75ed..5a6ba3b2fa05 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -298,8 +298,7 @@ static int dfl_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+ {
+ 	struct dfl_device *ddev = to_dfl_dev(dev);
+ 
+-	/* The type has 4 valid bits and feature_id has 12 valid bits */
+-	return add_uevent_var(env, "MODALIAS=dfl:t%01Xf%03X",
++	return add_uevent_var(env, "MODALIAS=dfl:t%04Xf%04X",
+ 			      ddev->type, ddev->feature_id);
+ }
+ 
+diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
+index 5dc758f655b7..ac373b1fcff9 100644
+--- a/drivers/fpga/dfl.h
++++ b/drivers/fpga/dfl.h
+@@ -520,19 +520,19 @@ long dfl_feature_ioctl_set_irq(struct platform_device *pdev,
+  * enum dfl_id_type - define the DFL FIU types
+  */
+ enum dfl_id_type {
+-	FME_ID,
+-	PORT_ID,
++	FME_ID = 0,
++	PORT_ID = 1,
+ 	DFL_ID_MAX,
+ };
+ 
+ /**
+  * struct dfl_device_id -  dfl device identifier
+- * @type: contains 4 bits DFL FIU type of the device. See enum dfl_id_type.
+- * @feature_id: contains 12 bits feature identifier local to its DFL FIU type.
++ * @type: DFL FIU type of the device. See enum dfl_id_type.
++ * @feature_id: feature identifier local to its DFL FIU type.
+  * @driver_data: driver specific data.
+  */
+ struct dfl_device_id {
+-	u8 type;
++	u16 type;
+ 	u16 feature_id;
+ 	unsigned long driver_data;
+ };
+@@ -543,7 +543,7 @@ struct dfl_device_id {
+  * @dev: generic device interface.
+  * @id: id of the dfl device.
+  * @type: type of DFL FIU of the device. See enum dfl_id_type.
+- * @feature_id: 16 bits feature identifier local to its DFL FIU type.
++ * @feature_id: feature identifier local to its DFL FIU type.
+  * @mmio_res: mmio resource of this dfl device.
+  * @irqs: list of Linux IRQ numbers of this dfl device.
+  * @num_irqs: number of IRQs supported by this dfl device.
+@@ -553,7 +553,7 @@ struct dfl_device_id {
+ struct dfl_device {
+ 	struct device dev;
+ 	int id;
+-	u8 type;
++	u16 type;
+ 	u16 feature_id;
+ 	struct resource mmio_res;
+ 	int *irqs;
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0002-fpga-dfl-move-dfl_device_id-to-mod_devicetable.h.patch new/debian/patches/fpga-ofs/0002-fpga-dfl-move-dfl_device_id-to-mod_devicetable.h.patch
--- org/debian/patches/fpga-ofs/0002-fpga-dfl-move-dfl_device_id-to-mod_devicetable.h.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0002-fpga-dfl-move-dfl_device_id-to-mod_devicetable.h.patch	2021-07-20 06:17:11.300845163 +0200
@@ -0,0 +1,95 @@
+From 2110140b47ec3f5f176abe4365cef36887acc577 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Tue, 15 Sep 2020 11:27:50 +0800
+Subject: [PATCH 002/149] fpga: dfl: move dfl_device_id to mod_devicetable.h
+
+In order to support MODULE_DEVICE_TABLE() for dfl device driver, this
+patch moves struct dfl_device_id to mod_devicetable.h
+
+Some brief description for DFL (Device Feature List) is added to make
+the DFL known to the whole kernel.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Signed-off-by: Wu Hao <hao.wu@intel.com>
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+Acked-by: Wu Hao <hao.wu@intel.com>
+Signed-off-by: Moritz Fischer <mdf@kernel.org>
+----
+v2: fix the order for the header file
+v3: rebase the patch for dfl bus name change
+v9: rebase the patch for dfl bus name changes back to "dfl"
+v10: add some comments to describe what is DFL.
+---
+ drivers/fpga/dfl.h              | 13 +------------
+ include/linux/mod_devicetable.h | 24 ++++++++++++++++++++++++
+ 2 files changed, 25 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
+index ac373b1fcff9..549c7900dcfd 100644
+--- a/drivers/fpga/dfl.h
++++ b/drivers/fpga/dfl.h
+@@ -22,6 +22,7 @@
+ #include <linux/interrupt.h>
+ #include <linux/iopoll.h>
+ #include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/mod_devicetable.h>
+ #include <linux/platform_device.h>
+ #include <linux/slab.h>
+ #include <linux/uuid.h>
+@@ -525,18 +526,6 @@ enum dfl_id_type {
+ 	DFL_ID_MAX,
+ };
+ 
+-/**
+- * struct dfl_device_id -  dfl device identifier
+- * @type: DFL FIU type of the device. See enum dfl_id_type.
+- * @feature_id: feature identifier local to its DFL FIU type.
+- * @driver_data: driver specific data.
+- */
+-struct dfl_device_id {
+-	u16 type;
+-	u16 feature_id;
+-	unsigned long driver_data;
+-};
+-
+ /**
+  * struct dfl_device - represent an dfl device on dfl bus
+  *
+diff --git a/include/linux/mod_devicetable.h b/include/linux/mod_devicetable.h
+index 5b08a473cdba..e4870e5d3ea8 100644
+--- a/include/linux/mod_devicetable.h
++++ b/include/linux/mod_devicetable.h
+@@ -838,4 +838,28 @@ struct mhi_device_id {
+ 	kernel_ulong_t driver_data;
+ };
+ 
++/*
++ * DFL (Device Feature List)
++ *
++ * DFL defines a linked list of feature headers within the device MMIO space to
++ * provide an extensible way of adding features. Software can walk through these
++ * predefined data structures to enumerate features. It is now used in the FPGA.
++ * See Documentation/fpga/dfl.rst for more information.
++ *
++ * The dfl bus type is introduced to match the individual feature devices (dfl
++ * devices) for specific dfl drivers.
++ */
++
++/**
++ * struct dfl_device_id -  dfl device identifier
++ * @type: DFL FIU type of the device. See enum dfl_id_type.
++ * @feature_id: feature identifier local to its DFL FIU type.
++ * @driver_data: driver specific data.
++ */
++struct dfl_device_id {
++	__u16 type;
++	__u16 feature_id;
++	unsigned long driver_data;
++};
++
+ #endif /* LINUX_MOD_DEVICETABLE_H */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0003-fpga-dfl-add-dfl-bus-support-to-MODULE_DEVICE_TABLE.patch new/debian/patches/fpga-ofs/0003-fpga-dfl-add-dfl-bus-support-to-MODULE_DEVICE_TABLE.patch
--- org/debian/patches/fpga-ofs/0003-fpga-dfl-add-dfl-bus-support-to-MODULE_DEVICE_TABLE.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0003-fpga-dfl-add-dfl-bus-support-to-MODULE_DEVICE_TABLE.patch	2021-07-20 06:17:11.304845151 +0200
@@ -0,0 +1,84 @@
+From 852293fc1d7341d6bf214130158f1e92fe0317c4 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Tue, 15 Sep 2020 11:27:51 +0800
+Subject: [PATCH 003/149] fpga: dfl: add dfl bus support to
+ MODULE_DEVICE_TABLE()
+
+Device Feature List (DFL) is a linked list of feature headers within the
+device MMIO space. It is used by FPGA to enumerate multiple sub features
+within it. Each feature can be uniquely identified by DFL type and
+feature id, which can be read out from feature headers.
+
+A dfl bus helps DFL framework modularize DFL device drivers for
+different sub features. The dfl bus matches its devices and drivers by
+DFL type and feature id.
+
+This patch adds dfl bus support to MODULE_DEVICE_TABLE() by adding info
+about struct dfl_device_id in devicetable-offsets.c and add a dfl entry
+point in file2alias.c.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Signed-off-by: Wu Hao <hao.wu@intel.com>
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Acked-by: Wu Hao <hao.wu@intel.com>
+Signed-off-by: Moritz Fischer <mdf@kernel.org>
+----
+v2: add comments for the format of modalias
+v3: changes the names from dfl_XXX to fpga_dfl_XXX
+    delete the comments of valid bits for modalias format
+v9: rebase the patch for bus name changes back to "dfl"
+v10: no change
+---
+ scripts/mod/devicetable-offsets.c |  4 ++++
+ scripts/mod/file2alias.c          | 13 +++++++++++++
+ 2 files changed, 17 insertions(+)
+
+diff --git a/scripts/mod/devicetable-offsets.c b/scripts/mod/devicetable-offsets.c
+index 27007c18e754..d8350eea6d1a 100644
+--- a/scripts/mod/devicetable-offsets.c
++++ b/scripts/mod/devicetable-offsets.c
+@@ -243,5 +243,9 @@ int main(void)
+ 	DEVID(mhi_device_id);
+ 	DEVID_FIELD(mhi_device_id, chan);
+ 
++	DEVID(dfl_device_id);
++	DEVID_FIELD(dfl_device_id, type);
++	DEVID_FIELD(dfl_device_id, feature_id);
++
+ 	return 0;
+ }
+diff --git a/scripts/mod/file2alias.c b/scripts/mod/file2alias.c
+index 2417dd1dee33..8a438c94dcd9 100644
+--- a/scripts/mod/file2alias.c
++++ b/scripts/mod/file2alias.c
+@@ -1368,6 +1368,18 @@ static int do_mhi_entry(const char *filename, void *symval, char *alias)
+ 	return 1;
+ }
+ 
++/* Looks like: dfl:tNfN */
++static int do_dfl_entry(const char *filename, void *symval, char *alias)
++{
++	DEF_FIELD(symval, dfl_device_id, type);
++	DEF_FIELD(symval, dfl_device_id, feature_id);
++
++	sprintf(alias, "dfl:t%04Xf%04X", type, feature_id);
++
++	add_wildcard(alias);
++	return 1;
++}
++
+ /* Does namelen bytes of name exactly match the symbol? */
+ static bool sym_is(const char *name, unsigned namelen, const char *symbol)
+ {
+@@ -1442,6 +1454,7 @@ static const struct devtable devtable[] = {
+ 	{"tee", SIZE_tee_client_device_id, do_tee_entry},
+ 	{"wmi", SIZE_wmi_device_id, do_wmi_entry},
+ 	{"mhi", SIZE_mhi_device_id, do_mhi_entry},
++	{"dfl", SIZE_dfl_device_id, do_dfl_entry},
+ };
+ 
+ /* Create MODULE_ALIAS() statements.
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0004-fpga-dfl-move-dfl-bus-related-APIs-to-include-linux-.patch new/debian/patches/fpga-ofs/0004-fpga-dfl-move-dfl-bus-related-APIs-to-include-linux-.patch
--- org/debian/patches/fpga-ofs/0004-fpga-dfl-move-dfl-bus-related-APIs-to-include-linux-.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0004-fpga-dfl-move-dfl-bus-related-APIs-to-include-linux-.patch	2021-07-20 06:17:11.320845107 +0200
@@ -0,0 +1,231 @@
+From 3c35c52062075a4bdfdc7b03a3d73e6b1129e5d3 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Tue, 15 Sep 2020 11:27:53 +0800
+Subject: [PATCH 004/149] fpga: dfl: move dfl bus related APIs to
+ include/linux/dfl.h
+
+Now the dfl drivers could be made as independent modules and put in
+different folders according to their functionalities. In order for
+scattered dfl device drivers to include dfl bus APIs, move the
+dfl bus APIs to a new header file in the public folder.
+
+[mdf@kernel.org: Fixed up MAINTAINERS entry merge]
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+Acked-by: Wu Hao <hao.wu@intel.com>
+Signed-off-by: Moritz Fischer <mdf@kernel.org>
+----
+v2: updated the MAINTAINERS under FPGA DFL DRIVERS
+    improve the comments
+    rename the dfl-bus.h to dfl.h
+v3: rebase the patch for previous changes
+v9: rebase the patch for bus name changes back to "dfl"
+v10: move the head file from inlude/linux/fpga to include/linux
+---
+ MAINTAINERS         |  1 +
+ drivers/fpga/dfl.c  |  1 +
+ drivers/fpga/dfl.h  | 72 -------------------------------------
+ include/linux/dfl.h | 86 +++++++++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 88 insertions(+), 72 deletions(-)
+ create mode 100644 include/linux/dfl.h
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 281de213ef47..10d8ad4f6fe6 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -6895,6 +6895,7 @@ S:	Maintained
+ F:	Documentation/ABI/testing/sysfs-bus-dfl
+ F:	Documentation/fpga/dfl.rst
+ F:	drivers/fpga/dfl*
++F:	include/linux/dfl.h
+ F:	include/uapi/linux/fpga-dfl.h
+ 
+ FPGA MANAGER FRAMEWORK
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index 5a6ba3b2fa05..511b20ff35a3 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -10,6 +10,7 @@
+  *   Wu Hao <hao.wu@intel.com>
+  *   Xiao Guangrong <guangrong.xiao@linux.intel.com>
+  */
++#include <linux/dfl.h>
+ #include <linux/fpga-dfl.h>
+ #include <linux/module.h>
+ #include <linux/uaccess.h>
+diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
+index 549c7900dcfd..2b82c96ba56c 100644
+--- a/drivers/fpga/dfl.h
++++ b/drivers/fpga/dfl.h
+@@ -517,76 +517,4 @@ long dfl_feature_ioctl_set_irq(struct platform_device *pdev,
+ 			       struct dfl_feature *feature,
+ 			       unsigned long arg);
+ 
+-/**
+- * enum dfl_id_type - define the DFL FIU types
+- */
+-enum dfl_id_type {
+-	FME_ID = 0,
+-	PORT_ID = 1,
+-	DFL_ID_MAX,
+-};
+-
+-/**
+- * struct dfl_device - represent an dfl device on dfl bus
+- *
+- * @dev: generic device interface.
+- * @id: id of the dfl device.
+- * @type: type of DFL FIU of the device. See enum dfl_id_type.
+- * @feature_id: feature identifier local to its DFL FIU type.
+- * @mmio_res: mmio resource of this dfl device.
+- * @irqs: list of Linux IRQ numbers of this dfl device.
+- * @num_irqs: number of IRQs supported by this dfl device.
+- * @cdev: pointer to DFL FPGA container device this dfl device belongs to.
+- * @id_entry: matched id entry in dfl driver's id table.
+- */
+-struct dfl_device {
+-	struct device dev;
+-	int id;
+-	u16 type;
+-	u16 feature_id;
+-	struct resource mmio_res;
+-	int *irqs;
+-	unsigned int num_irqs;
+-	struct dfl_fpga_cdev *cdev;
+-	const struct dfl_device_id *id_entry;
+-};
+-
+-/**
+- * struct dfl_driver - represent an dfl device driver
+- *
+- * @drv: driver model structure.
+- * @id_table: pointer to table of device IDs the driver is interested in.
+- *	      { } member terminated.
+- * @probe: mandatory callback for device binding.
+- * @remove: callback for device unbinding.
+- */
+-struct dfl_driver {
+-	struct device_driver drv;
+-	const struct dfl_device_id *id_table;
+-
+-	int (*probe)(struct dfl_device *dfl_dev);
+-	void (*remove)(struct dfl_device *dfl_dev);
+-};
+-
+-#define to_dfl_dev(d) container_of(d, struct dfl_device, dev)
+-#define to_dfl_drv(d) container_of(d, struct dfl_driver, drv)
+-
+-/*
+- * use a macro to avoid include chaining to get THIS_MODULE.
+- */
+-#define dfl_driver_register(drv) \
+-	__dfl_driver_register(drv, THIS_MODULE)
+-int __dfl_driver_register(struct dfl_driver *dfl_drv, struct module *owner);
+-void dfl_driver_unregister(struct dfl_driver *dfl_drv);
+-
+-/*
+- * module_dfl_driver() - Helper macro for drivers that don't do
+- * anything special in module init/exit.  This eliminates a lot of
+- * boilerplate.  Each module may only use this macro once, and
+- * calling it replaces module_init() and module_exit().
+- */
+-#define module_dfl_driver(__dfl_driver) \
+-	module_driver(__dfl_driver, dfl_driver_register, \
+-		      dfl_driver_unregister)
+-
+ #endif /* __FPGA_DFL_H */
+diff --git a/include/linux/dfl.h b/include/linux/dfl.h
+new file mode 100644
+index 000000000000..7affba2fd545
+--- /dev/null
++++ b/include/linux/dfl.h
+@@ -0,0 +1,86 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Header file for DFL driver and device API
++ *
++ * Copyright (C) 2020 Intel Corporation, Inc.
++ */
++
++#ifndef __LINUX_FPGA_DFL_H
++#define __LINUX_FPGA_DFL_H
++
++#include <linux/device.h>
++#include <linux/mod_devicetable.h>
++
++/**
++ * enum dfl_id_type - define the DFL FIU types
++ */
++enum dfl_id_type {
++	FME_ID = 0,
++	PORT_ID = 1,
++	DFL_ID_MAX,
++};
++
++/**
++ * struct dfl_device - represent an dfl device on dfl bus
++ *
++ * @dev: generic device interface.
++ * @id: id of the dfl device.
++ * @type: type of DFL FIU of the device. See enum dfl_id_type.
++ * @feature_id: feature identifier local to its DFL FIU type.
++ * @mmio_res: mmio resource of this dfl device.
++ * @irqs: list of Linux IRQ numbers of this dfl device.
++ * @num_irqs: number of IRQs supported by this dfl device.
++ * @cdev: pointer to DFL FPGA container device this dfl device belongs to.
++ * @id_entry: matched id entry in dfl driver's id table.
++ */
++struct dfl_device {
++	struct device dev;
++	int id;
++	u16 type;
++	u16 feature_id;
++	struct resource mmio_res;
++	int *irqs;
++	unsigned int num_irqs;
++	struct dfl_fpga_cdev *cdev;
++	const struct dfl_device_id *id_entry;
++};
++
++/**
++ * struct dfl_driver - represent an dfl device driver
++ *
++ * @drv: driver model structure.
++ * @id_table: pointer to table of device IDs the driver is interested in.
++ *	      { } member terminated.
++ * @probe: mandatory callback for device binding.
++ * @remove: callback for device unbinding.
++ */
++struct dfl_driver {
++	struct device_driver drv;
++	const struct dfl_device_id *id_table;
++
++	int (*probe)(struct dfl_device *dfl_dev);
++	void (*remove)(struct dfl_device *dfl_dev);
++};
++
++#define to_dfl_dev(d) container_of(d, struct dfl_device, dev)
++#define to_dfl_drv(d) container_of(d, struct dfl_driver, drv)
++
++/*
++ * use a macro to avoid include chaining to get THIS_MODULE.
++ */
++#define dfl_driver_register(drv) \
++	__dfl_driver_register(drv, THIS_MODULE)
++int __dfl_driver_register(struct dfl_driver *dfl_drv, struct module *owner);
++void dfl_driver_unregister(struct dfl_driver *dfl_drv);
++
++/*
++ * module_dfl_driver() - Helper macro for drivers that don't do
++ * anything special in module init/exit.  This eliminates a lot of
++ * boilerplate.  Each module may only use this macro once, and
++ * calling it replaces module_init() and module_exit().
++ */
++#define module_dfl_driver(__dfl_driver) \
++	module_driver(__dfl_driver, dfl_driver_register, \
++		      dfl_driver_unregister)
++
++#endif /* __LINUX_FPGA_DFL_H */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0005-fpga-dfl-add-support-for-N3000-Nios-private-feature.patch new/debian/patches/fpga-ofs/0005-fpga-dfl-add-support-for-N3000-Nios-private-feature.patch
--- org/debian/patches/fpga-ofs/0005-fpga-dfl-add-support-for-N3000-Nios-private-feature.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0005-fpga-dfl-add-support-for-N3000-Nios-private-feature.patch	2021-07-20 06:17:11.332845072 +0200
@@ -0,0 +1,767 @@
+From b5942d909c981080f5fe4d91508552773520d6f5 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Mon, 7 Sep 2020 22:23:27 +0800
+Subject: [PATCH 005/149] fpga: dfl: add support for N3000 Nios private feature
+
+This patch adds support for the Nios handshake private feature on Intel
+PAC (Programmable Acceleration Card) N3000.
+
+The Nios is the embedded processor on the FPGA card. This private feature
+provides a handshake interface to FPGA Nios firmware, which receives
+retimer configuration command from host and executes via an internal SPI
+master (spi-altera). When Nios finishes the configuration, host takes over
+the ownership of the SPI master to control an Intel MAX10 BMC (Board
+Management Controller) Chip on the SPI bus.
+
+For Nios firmware handshake part, this driver requests the retimer
+configuration for Nios firmware on probe, and adds some sysfs nodes for
+user to query the onboard retimer's working mode and Nios firmware
+version.
+
+For SPI part, this driver adds a spi-altera platform device as well as
+the MAX10 BMC spi slave info. A spi-altera driver will be matched to
+handle the following SPI work.
+
+[mdf@kernel.org: Fixed up MAINTAINERS file to include added ABI doc]
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Signed-off-by: Wu Hao <hao.wu@intel.com>
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Signed-off-by: YueHaibing <yuehaibing@huawei.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+----
+v3: add the doc for this driver
+    minor fixes for comments from Tom
+v4: move the err log in regmap implementation, and delete
+     n3000_nios_writel/readl(), they have nothing to wrapper now.
+    some minor fixes and comments improvement.
+v5: fix the output of fec_mode sysfs inf to "no" on 10G configuration,
+     cause no FEC mode could be configured for 10G.
+    rename the dfl_n3000_nios_* to n3000_nios_*
+    improves comments.
+v6: fix the output of fec_mode sysfs inf to "not supported" if in 10G,
+     or the firmware version major < 3.
+    minor fixes and improves comments.
+v7: improves comments.
+v8: add sysfs interfaces for retimer mode, also doc update.
+    delete duplicated sysfs interfaces description in doc.
+    minor fixes.
+v9: delete the retimer FEC mode configuration via module_parameter.
+    update the kernel version of the sysfs interfaces in Doc.
+    merge the patch "Make m10_n3000_info static" (https://lore.kernel.org/linux-fpga/52d8411e-13d8-1e91-756d-131802f5f445@huawei.com/T/#t)
+    remove the tags of Maintainers, this implementation is changed.
+v10: improve the name of some macros, functions and variables.
+     refactor the FEC mode setting and reading.
+     refactor the retimer init error checking and dumping.
+     refactor the loop timeout for regbus reading & write.
+     some minor fixes.
+v11: use sysfs_emit instead of sprintf.
+     rebase to 5.10-rc1.
+v12: move the MODULE_DEVICE_TABLE() right after its definition.
+---
+ .../testing/sysfs-bus-dfl-devices-n3000-nios  |  47 ++
+ MAINTAINERS                                   |   2 +-
+ drivers/fpga/Kconfig                          |  11 +
+ drivers/fpga/Makefile                         |   2 +
+ drivers/fpga/dfl-n3000-nios.c                 | 588 ++++++++++++++++++
+ 5 files changed, 649 insertions(+), 1 deletion(-)
+ create mode 100644 Documentation/ABI/testing/sysfs-bus-dfl-devices-n3000-nios
+ create mode 100644 drivers/fpga/dfl-n3000-nios.c
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-dfl-devices-n3000-nios b/Documentation/ABI/testing/sysfs-bus-dfl-devices-n3000-nios
+new file mode 100644
+index 000000000000..a50553764654
+--- /dev/null
++++ b/Documentation/ABI/testing/sysfs-bus-dfl-devices-n3000-nios
+@@ -0,0 +1,47 @@
++What:		/sys/bus/dfl/devices/dfl_dev.X/fec_mode
++Date:		Oct 2020
++KernelVersion:	5.11
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Read-only. Returns the FEC mode of the 25G links of the
++		ethernet retimers configured by Nios firmware. "rs" for Reed
++		Solomon FEC, "kr" for Fire Code FEC, "no" for NO FEC.
++		"not supported" if the FEC mode setting is not supported, this
++		happens when the Nios firmware version major < 3, or no link is
++		configured to 25G.
++		Format: string
++
++What:		/sys/bus/dfl/devices/dfl_dev.X/retimer_A_mode
++Date:		Oct 2020
++KernelVersion:	5.11
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Read-only. Returns the enumeration value of the working mode of
++		the retimer A configured by the Nios firmware. The value is
++		read out from shared registers filled by the Nios firmware. Now
++		the values could be:
++
++		- "0": Reset
++		- "1": 4x10G
++		- "2": 4x25G
++		- "3": 2x25G
++		- "4": 2x25G+2x10G
++		- "5": 1x25G
++
++		If the Nios firmware is updated in future to support more
++		retimer modes, more enumeration value is expected.
++		Format: 0x%x
++
++What:		/sys/bus/dfl/devices/dfl_dev.X/retimer_B_mode
++Date:		Oct 2020
++KernelVersion:	5.11
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Read-only. Returns the enumeration value of the working mode of
++		the retimer B configured by the Nios firmware. The value format
++		is the same as retimer_A_mode.
++
++What:		/sys/bus/dfl/devices/dfl_dev.X/nios_fw_version
++Date:		Oct 2020
++KernelVersion:	5.11
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Read-only. Returns the version of the Nios firmware in the
++		FPGA. Its format is "major.minor.patch".
++		Format: %x.%x.%x
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 10d8ad4f6fe6..64d3dc5b7589 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -6892,7 +6892,7 @@ M:	Wu Hao <hao.wu@intel.com>
+ R:	Tom Rix <trix@redhat.com>
+ L:	linux-fpga@vger.kernel.org
+ S:	Maintained
+-F:	Documentation/ABI/testing/sysfs-bus-dfl
++F:	Documentation/ABI/testing/sysfs-bus-dfl*
+ F:	Documentation/fpga/dfl.rst
+ F:	drivers/fpga/dfl*
+ F:	include/linux/dfl.h
+diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
+index 5645226ca3ce..5ff9438b7b46 100644
+--- a/drivers/fpga/Kconfig
++++ b/drivers/fpga/Kconfig
+@@ -192,6 +192,17 @@ config FPGA_DFL_AFU
+ 	  to the FPGA infrastructure via a Port. There may be more than one
+ 	  Port/AFU per DFL based FPGA device.
+ 
++config FPGA_DFL_NIOS_INTEL_PAC_N3000
++	tristate "FPGA DFL NIOS Driver for Intel PAC N3000"
++	depends on FPGA_DFL
++	select REGMAP
++	help
++	  This is the driver for the N3000 Nios private feature on Intel
++	  PAC (Programmable Acceleration Card) N3000. It communicates
++	  with the embedded Nios processor to configure the retimers on
++	  the card. It also instantiates the SPI master (spi-altera) for
++	  the card's BMC (Board Management Controller).
++
+ config FPGA_DFL_PCI
+ 	tristate "FPGA DFL PCIe Device Driver"
+ 	depends on PCI && FPGA_DFL
+diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
+index d8e21dfc6778..18dc9885883a 100644
+--- a/drivers/fpga/Makefile
++++ b/drivers/fpga/Makefile
+@@ -44,5 +44,7 @@ dfl-fme-objs += dfl-fme-perf.o
+ dfl-afu-objs := dfl-afu-main.o dfl-afu-region.o dfl-afu-dma-region.o
+ dfl-afu-objs += dfl-afu-error.o
+ 
++obj-$(CONFIG_FPGA_DFL_NIOS_INTEL_PAC_N3000)	+= dfl-n3000-nios.o
++
+ # Drivers for FPGAs which implement DFL
+ obj-$(CONFIG_FPGA_DFL_PCI)		+= dfl-pci.o
+diff --git a/drivers/fpga/dfl-n3000-nios.c b/drivers/fpga/dfl-n3000-nios.c
+new file mode 100644
+index 000000000000..25018ef4e465
+--- /dev/null
++++ b/drivers/fpga/dfl-n3000-nios.c
+@@ -0,0 +1,588 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * DFL device driver for Nios private feature on Intel PAC (Programmable
++ * Acceleration Card) N3000
++ *
++ * Copyright (C) 2019-2020 Intel Corporation, Inc.
++ *
++ * Authors:
++ *   Wu Hao <hao.wu@intel.com>
++ *   Xu Yilun <yilun.xu@intel.com>
++ */
++#include <linux/bitfield.h>
++#include <linux/dfl.h>
++#include <linux/errno.h>
++#include <linux/io.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/regmap.h>
++#include <linux/stddef.h>
++#include <linux/spi/altera.h>
++#include <linux/spi/spi.h>
++#include <linux/types.h>
++
++/*
++ * N3000 Nios private feature registers, named as NIOS_SPI_XX on spec.
++ * NS is the abbreviation of NIOS_SPI.
++ */
++#define N3000_NS_PARAM				0x8
++#define N3000_NS_PARAM_SHIFT_MODE_MSK		BIT_ULL(1)
++#define N3000_NS_PARAM_SHIFT_MODE_MSB		0
++#define N3000_NS_PARAM_SHIFT_MODE_LSB		1
++#define N3000_NS_PARAM_DATA_WIDTH		GENMASK_ULL(7, 2)
++#define N3000_NS_PARAM_NUM_CS			GENMASK_ULL(13, 8)
++#define N3000_NS_PARAM_CLK_POL			BIT_ULL(14)
++#define N3000_NS_PARAM_CLK_PHASE		BIT_ULL(15)
++#define N3000_NS_PARAM_PERIPHERAL_ID		GENMASK_ULL(47, 32)
++
++#define N3000_NS_CTRL				0x10
++#define N3000_NS_CTRL_WR_DATA			GENMASK_ULL(31, 0)
++#define N3000_NS_CTRL_ADDR			GENMASK_ULL(44, 32)
++#define N3000_NS_CTRL_CMD_MSK			GENMASK_ULL(63, 62)
++#define N3000_NS_CTRL_CMD_NOP			0
++#define N3000_NS_CTRL_CMD_RD			1
++#define N3000_NS_CTRL_CMD_WR			2
++
++#define N3000_NS_STAT				0x18
++#define N3000_NS_STAT_RD_DATA			GENMASK_ULL(31, 0)
++#define N3000_NS_STAT_RW_VAL			BIT_ULL(32)
++
++/* Nios handshake registers, indirect access */
++#define N3000_NIOS_INIT				0x1000
++#define N3000_NIOS_INIT_DONE			BIT(0)
++#define N3000_NIOS_INIT_START			BIT(1)
++/* Mode for retimer A, link 0, the same below */
++#define N3000_NIOS_INIT_REQ_FEC_MODE_A0_MSK	GENMASK(9, 8)
++#define N3000_NIOS_INIT_REQ_FEC_MODE_A1_MSK	GENMASK(11, 10)
++#define N3000_NIOS_INIT_REQ_FEC_MODE_A2_MSK	GENMASK(13, 12)
++#define N3000_NIOS_INIT_REQ_FEC_MODE_A3_MSK	GENMASK(15, 14)
++#define N3000_NIOS_INIT_REQ_FEC_MODE_B0_MSK	GENMASK(17, 16)
++#define N3000_NIOS_INIT_REQ_FEC_MODE_B1_MSK	GENMASK(19, 18)
++#define N3000_NIOS_INIT_REQ_FEC_MODE_B2_MSK	GENMASK(21, 20)
++#define N3000_NIOS_INIT_REQ_FEC_MODE_B3_MSK	GENMASK(23, 22)
++#define N3000_NIOS_INIT_REQ_FEC_MODE_NO		0x0
++#define N3000_NIOS_INIT_REQ_FEC_MODE_KR		0x1
++#define N3000_NIOS_INIT_REQ_FEC_MODE_RS		0x2
++
++#define N3000_NIOS_FW_VERSION			0x1004
++#define N3000_NIOS_FW_VERSION_PATCH		GENMASK(23, 20)
++#define N3000_NIOS_FW_VERSION_MINOR		GENMASK(27, 24)
++#define N3000_NIOS_FW_VERSION_MAJOR		GENMASK(31, 28)
++
++/* The retimers we use on Intel PAC N3000 is Parkvale, abbreviated to PKVL */
++#define N3000_NIOS_PKVL_A_MODE_STS		0x1020
++#define N3000_NIOS_PKVL_B_MODE_STS		0x1024
++#define N3000_NIOS_PKVL_MODE_STS_GROUP_MSK	GENMASK(15, 8)
++#define N3000_NIOS_PKVL_MODE_STS_GROUP_OK	0x0
++#define N3000_NIOS_PKVL_MODE_STS_ID_MSK		GENMASK(7, 0)
++/* When GROUP MASK field == GROUP_OK  */
++#define N3000_NIOS_PKVL_MODE_ID_RESET		0x0
++#define N3000_NIOS_PKVL_MODE_ID_4X10G		0x1
++#define N3000_NIOS_PKVL_MODE_ID_4X25G		0x2
++#define N3000_NIOS_PKVL_MODE_ID_2X25G		0x3
++#define N3000_NIOS_PKVL_MODE_ID_2X25G_2X10G	0x4
++#define N3000_NIOS_PKVL_MODE_ID_1X25G		0x5
++
++#define N3000_NIOS_REGBUS_RETRY_COUNT		10000	/* loop count */
++
++#define N3000_NIOS_INIT_TIMEOUT			10000000	/* usec */
++#define N3000_NIOS_INIT_TIME_INTV		100000		/* usec */
++
++#define N3000_NIOS_INIT_REQ_FEC_MODE_MSK_ALL	\
++	(N3000_NIOS_INIT_REQ_FEC_MODE_A0_MSK |	\
++	 N3000_NIOS_INIT_REQ_FEC_MODE_A1_MSK |	\
++	 N3000_NIOS_INIT_REQ_FEC_MODE_A2_MSK |	\
++	 N3000_NIOS_INIT_REQ_FEC_MODE_A3_MSK |	\
++	 N3000_NIOS_INIT_REQ_FEC_MODE_B0_MSK |	\
++	 N3000_NIOS_INIT_REQ_FEC_MODE_B1_MSK |	\
++	 N3000_NIOS_INIT_REQ_FEC_MODE_B2_MSK |	\
++	 N3000_NIOS_INIT_REQ_FEC_MODE_B3_MSK)
++
++#define N3000_NIOS_INIT_REQ_FEC_MODE_NO_ALL			\
++	(FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A0_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A1_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A2_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A3_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B0_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B1_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B2_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_NO) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B3_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_NO))
++
++#define N3000_NIOS_INIT_REQ_FEC_MODE_KR_ALL			\
++	(FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A0_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A1_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A2_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A3_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B0_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B1_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B2_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_KR) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B3_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_KR))
++
++#define N3000_NIOS_INIT_REQ_FEC_MODE_RS_ALL			\
++	(FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A0_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A1_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A2_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_A3_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B0_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B1_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B2_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_RS) |		\
++	 FIELD_PREP(N3000_NIOS_INIT_REQ_FEC_MODE_B3_MSK,	\
++		    N3000_NIOS_INIT_REQ_FEC_MODE_RS))
++
++struct n3000_nios {
++	void __iomem *base;
++	struct regmap *regmap;
++	struct device *dev;
++	struct platform_device *altera_spi;
++};
++
++static ssize_t nios_fw_version_show(struct device *dev,
++				    struct device_attribute *attr, char *buf)
++{
++	struct n3000_nios *nn = dev_get_drvdata(dev);
++	unsigned int val;
++	int ret;
++
++	ret = regmap_read(nn->regmap, N3000_NIOS_FW_VERSION, &val);
++	if (ret)
++		return ret;
++
++	return sysfs_emit(buf, "%x.%x.%x\n",
++			  (u8)FIELD_GET(N3000_NIOS_FW_VERSION_MAJOR, val),
++			  (u8)FIELD_GET(N3000_NIOS_FW_VERSION_MINOR, val),
++			  (u8)FIELD_GET(N3000_NIOS_FW_VERSION_PATCH, val));
++}
++static DEVICE_ATTR_RO(nios_fw_version);
++
++#define IS_MODE_STATUS_OK(mode_stat)					\
++	(FIELD_GET(N3000_NIOS_PKVL_MODE_STS_GROUP_MSK, (mode_stat)) ==	\
++	 N3000_NIOS_PKVL_MODE_STS_GROUP_OK)
++
++#define IS_RETIMER_FEC_SUPPORTED(retimer_mode)			\
++	((retimer_mode) != N3000_NIOS_PKVL_MODE_ID_RESET &&	\
++	 (retimer_mode) != N3000_NIOS_PKVL_MODE_ID_4X10G)
++
++static int get_retimer_mode(struct n3000_nios *nn, unsigned int mode_stat_reg,
++			    unsigned int *retimer_mode)
++{
++	unsigned int val;
++	int ret;
++
++	ret = regmap_read(nn->regmap, mode_stat_reg, &val);
++	if (ret)
++		return ret;
++
++	if (!IS_MODE_STATUS_OK(val))
++		return -EFAULT;
++
++	*retimer_mode = FIELD_GET(N3000_NIOS_PKVL_MODE_STS_ID_MSK, val);
++
++	return 0;
++}
++
++static ssize_t retimer_A_mode_show(struct device *dev,
++				   struct device_attribute *attr, char *buf)
++{
++	struct n3000_nios *nn = dev_get_drvdata(dev);
++	unsigned int mode;
++	int ret;
++
++	ret = get_retimer_mode(nn, N3000_NIOS_PKVL_A_MODE_STS, &mode);
++	if (ret)
++		return ret;
++
++	return sysfs_emit(buf, "0x%x\n", mode);
++}
++static DEVICE_ATTR_RO(retimer_A_mode);
++
++static ssize_t retimer_B_mode_show(struct device *dev,
++				   struct device_attribute *attr, char *buf)
++{
++	struct n3000_nios *nn = dev_get_drvdata(dev);
++	unsigned int mode;
++	int ret;
++
++	ret = get_retimer_mode(nn, N3000_NIOS_PKVL_B_MODE_STS, &mode);
++	if (ret)
++		return ret;
++
++	return sysfs_emit(buf, "0x%x\n", mode);
++}
++static DEVICE_ATTR_RO(retimer_B_mode);
++
++static ssize_t fec_mode_show(struct device *dev,
++			     struct device_attribute *attr, char *buf)
++{
++	unsigned int val, retimer_a_mode, retimer_b_mode, fec_modes;
++	struct n3000_nios *nn = dev_get_drvdata(dev);
++	int ret;
++
++	/* FEC mode setting is not supported in early FW versions */
++	ret = regmap_read(nn->regmap, N3000_NIOS_FW_VERSION, &val);
++	if (ret)
++		return ret;
++
++	if (FIELD_GET(N3000_NIOS_FW_VERSION_MAJOR, val) < 3)
++		return sysfs_emit(buf, "not supported\n");
++
++	/* If no 25G links, FEC mode setting is not supported either */
++	ret = get_retimer_mode(nn, N3000_NIOS_PKVL_A_MODE_STS, &retimer_a_mode);
++	if (ret)
++		return ret;
++
++	ret = get_retimer_mode(nn, N3000_NIOS_PKVL_B_MODE_STS, &retimer_b_mode);
++	if (ret)
++		return ret;
++
++	if (!IS_RETIMER_FEC_SUPPORTED(retimer_a_mode) &&
++	    !IS_RETIMER_FEC_SUPPORTED(retimer_b_mode))
++		return sysfs_emit(buf, "not supported\n");
++
++	/* get the valid FEC mode for 25G links */
++	ret = regmap_read(nn->regmap, N3000_NIOS_INIT, &val);
++	if (ret)
++		return ret;
++
++	/*
++	 * FEC mode should always be the same for all links, as we set them
++	 * in this way.
++	 */
++	fec_modes = (val & N3000_NIOS_INIT_REQ_FEC_MODE_MSK_ALL);
++	if (fec_modes == N3000_NIOS_INIT_REQ_FEC_MODE_NO_ALL)
++		return sysfs_emit(buf, "no\n");
++	else if (fec_modes == N3000_NIOS_INIT_REQ_FEC_MODE_KR_ALL)
++		return sysfs_emit(buf, "kr\n");
++	else if (fec_modes == N3000_NIOS_INIT_REQ_FEC_MODE_RS_ALL)
++		return sysfs_emit(buf, "rs\n");
++
++	return -EFAULT;
++}
++static DEVICE_ATTR_RO(fec_mode);
++
++static struct attribute *n3000_nios_attrs[] = {
++	&dev_attr_nios_fw_version.attr,
++	&dev_attr_retimer_A_mode.attr,
++	&dev_attr_retimer_B_mode.attr,
++	&dev_attr_fec_mode.attr,
++	NULL,
++};
++ATTRIBUTE_GROUPS(n3000_nios);
++
++static int n3000_nios_init_done_check(struct n3000_nios *nn)
++{
++	unsigned int val, state_a, state_b;
++	struct device *dev = nn->dev;
++	int ret, ret2;
++
++	/*
++	 * The SPI is shared by the Nios core inside the FPGA, Nios will use
++	 * this SPI master to do some one time initialization after power up,
++	 * and then release the control to OS. The driver needs to poll on
++	 * INIT_DONE to see when driver could take the control.
++	 *
++	 * Please note that after Nios firmware version 3.0.0, INIT_START is
++	 * introduced, so driver needs to trigger START firstly and then check
++	 * INIT_DONE.
++	 */
++
++	ret = regmap_read(nn->regmap, N3000_NIOS_FW_VERSION, &val);
++	if (ret)
++		return ret;
++
++	/*
++	 * If Nios version register is totally uninitialized(== 0x0), then the
++	 * Nios firmware is missing. So host could take control of SPI master
++	 * safely, but initialization work for Nios is not done. To restore the
++	 * card, we need to reprogram a new Nios firmware via the BMC chip on
++	 * SPI bus. So the driver doesn't error out, it continues to create the
++	 * spi controller device and spi_board_info for BMC.
++	 */
++	if (val == 0) {
++		dev_err(dev, "Nios version reg = 0x%x, skip INIT_DONE check, but the retimer may be uninitialized\n",
++			val);
++		return 0;
++	}
++
++	if (FIELD_GET(N3000_NIOS_FW_VERSION_MAJOR, val) >= 3) {
++		/* read NIOS_INIT to check if retimer initialization is done */
++		ret = regmap_read(nn->regmap, N3000_NIOS_INIT, &val);
++		if (ret)
++			return ret;
++
++		/* check if retimers are initialized already */
++		if (val & (N3000_NIOS_INIT_DONE || N3000_NIOS_INIT_START))
++			goto nios_init_done;
++
++		/* configure FEC mode per module param */
++		val = N3000_NIOS_INIT_START;
++
++		/*
++		 * When the retimer is to be set to 10G mode, there is no FEC
++		 * mode setting, so the REQ_FEC_MODE field will be ignored by
++		 * Nios firmware in this case. But we should still fill the FEC
++		 * mode field cause host could not get the retimer working mode
++		 * until the Nios init is done.
++		 *
++		 * For now the driver doesn't support the retimer FEC mode
++		 * switching per user's request. It is always set to Reed
++		 * Solomon FEC.
++		 *
++		 * The driver will set the same FEC mode for all links.
++		 */
++		val |= N3000_NIOS_INIT_REQ_FEC_MODE_RS_ALL;
++
++		ret = regmap_write(nn->regmap, N3000_NIOS_INIT, val);
++		if (ret)
++			return ret;
++	}
++
++nios_init_done:
++	/* polls on NIOS_INIT_DONE */
++	ret = regmap_read_poll_timeout(nn->regmap, N3000_NIOS_INIT, val,
++				       val & N3000_NIOS_INIT_DONE,
++				       N3000_NIOS_INIT_TIME_INTV,
++				       N3000_NIOS_INIT_TIMEOUT);
++	if (ret)
++		dev_err(dev, "NIOS_INIT_DONE %s\n",
++			(ret == -ETIMEDOUT) ? "timed out" : "check error");
++
++	ret2 = regmap_read(nn->regmap, N3000_NIOS_PKVL_A_MODE_STS, &state_a);
++	if (ret2)
++		return ret2;
++
++	ret2 = regmap_read(nn->regmap, N3000_NIOS_PKVL_B_MODE_STS, &state_b);
++	if (ret2)
++		return ret2;
++
++	if (!ret) {
++		/*
++		 * After INIT_DONE is detected, it still needs to check if the
++		 * Nios firmware reports any error during the retimer
++		 * configuration.
++		 */
++		if (IS_MODE_STATUS_OK(state_a) && IS_MODE_STATUS_OK(state_b))
++			return 0;
++
++		/*
++		 * If the retimer configuration is failed, the Nios firmware
++		 * will still release the spi controller for host to
++		 * communicate with the BMC. It makes possible for people to
++		 * reprogram a new Nios firmware and restore the card. So the
++		 * driver doesn't error out, it continues to create the spi
++		 * controller device and spi_board_info for BMC.
++		 */
++		dev_err(dev, "NIOS_INIT_DONE OK, but err on retimer init\n");
++	}
++
++	dev_err(nn->dev, "PKVL_A_MODE_STS 0x%x\n", state_a);
++	dev_err(nn->dev, "PKVL_B_MODE_STS 0x%x\n", state_b);
++
++	return ret;
++}
++
++static struct spi_board_info m10_n3000_info = {
++	.modalias = "m10-n3000",
++	.max_speed_hz = 12500000,
++	.bus_num = 0,
++	.chip_select = 0,
++};
++
++static int create_altera_spi_controller(struct n3000_nios *nn)
++{
++	struct altera_spi_platform_data pdata = { 0 };
++	struct platform_device_info pdevinfo = { 0 };
++	void __iomem *base = nn->base;
++	u64 v;
++
++	v = readq(base + N3000_NS_PARAM);
++
++	pdata.mode_bits = SPI_CS_HIGH;
++	if (FIELD_GET(N3000_NS_PARAM_CLK_POL, v))
++		pdata.mode_bits |= SPI_CPOL;
++	if (FIELD_GET(N3000_NS_PARAM_CLK_PHASE, v))
++		pdata.mode_bits |= SPI_CPHA;
++
++	pdata.num_chipselect = FIELD_GET(N3000_NS_PARAM_NUM_CS, v);
++	pdata.bits_per_word_mask =
++		SPI_BPW_RANGE_MASK(1, FIELD_GET(N3000_NS_PARAM_DATA_WIDTH, v));
++
++	pdata.num_devices = 1;
++	pdata.devices = &m10_n3000_info;
++
++	dev_dbg(nn->dev, "%s cs %u bpm 0x%x mode 0x%x\n", __func__,
++		pdata.num_chipselect, pdata.bits_per_word_mask,
++		pdata.mode_bits);
++
++	pdevinfo.name = "subdev_spi_altera";
++	pdevinfo.id = PLATFORM_DEVID_AUTO;
++	pdevinfo.parent = nn->dev;
++	pdevinfo.data = &pdata;
++	pdevinfo.size_data = sizeof(pdata);
++
++	nn->altera_spi = platform_device_register_full(&pdevinfo);
++	return PTR_ERR_OR_ZERO(nn->altera_spi);
++}
++
++static void destroy_altera_spi_controller(struct n3000_nios *nn)
++{
++	platform_device_unregister(nn->altera_spi);
++}
++
++static int n3000_nios_poll_stat_timeout(void __iomem *base, u64 *v)
++{
++	int loops;
++
++	/*
++	 * We don't use the time based timeout here for performance.
++	 *
++	 * The regbus read/write is on the critical path of Intel PAC N3000
++	 * image programing. The time based timeout checking will add too much
++	 * overhead on it. Usually the state changes in 1 or 2 loops on the
++	 * test server, and we set 10000 times loop here for safety.
++	 */
++	for (loops = N3000_NIOS_REGBUS_RETRY_COUNT; loops > 0 ; loops--) {
++		*v = readq(base + N3000_NS_STAT);
++		if (*v & N3000_NS_STAT_RW_VAL)
++			break;
++		cpu_relax();
++	}
++
++	return (loops > 0) ? 0 : -ETIMEDOUT;
++}
++
++static int n3000_nios_reg_write(void *context, unsigned int reg, unsigned int val)
++{
++	struct n3000_nios *nn = context;
++	u64 v;
++	int ret;
++
++	v = FIELD_PREP(N3000_NS_CTRL_CMD_MSK, N3000_NS_CTRL_CMD_WR) |
++	    FIELD_PREP(N3000_NS_CTRL_ADDR, reg) |
++	    FIELD_PREP(N3000_NS_CTRL_WR_DATA, val);
++	writeq(v, nn->base + N3000_NS_CTRL);
++
++	ret = n3000_nios_poll_stat_timeout(nn->base, &v);
++	if (ret)
++		dev_err(nn->dev, "fail to write reg 0x%x val 0x%x: %d\n",
++			reg, val, ret);
++
++	return ret;
++}
++
++static int n3000_nios_reg_read(void *context, unsigned int reg, unsigned int *val)
++{
++	struct n3000_nios *nn = context;
++	u64 v;
++	int ret;
++
++	v = FIELD_PREP(N3000_NS_CTRL_CMD_MSK, N3000_NS_CTRL_CMD_RD) |
++	    FIELD_PREP(N3000_NS_CTRL_ADDR, reg);
++	writeq(v, nn->base + N3000_NS_CTRL);
++
++	ret = n3000_nios_poll_stat_timeout(nn->base, &v);
++	if (ret)
++		dev_err(nn->dev, "fail to read reg 0x%x: %d\n", reg, ret);
++	else
++		*val = FIELD_GET(N3000_NS_STAT_RD_DATA, v);
++
++	return ret;
++}
++
++static const struct regmap_config n3000_nios_regbus_cfg = {
++	.reg_bits = 32,
++	.reg_stride = 4,
++	.val_bits = 32,
++	.fast_io = true,
++
++	.reg_write = n3000_nios_reg_write,
++	.reg_read = n3000_nios_reg_read,
++};
++
++static int n3000_nios_probe(struct dfl_device *ddev)
++{
++	struct device *dev = &ddev->dev;
++	struct n3000_nios *nn;
++	int ret;
++
++	nn = devm_kzalloc(dev, sizeof(*nn), GFP_KERNEL);
++	if (!nn)
++		return -ENOMEM;
++
++	dev_set_drvdata(&ddev->dev, nn);
++
++	nn->dev = dev;
++
++	nn->base = devm_ioremap_resource(&ddev->dev, &ddev->mmio_res);
++	if (IS_ERR(nn->base))
++		return PTR_ERR(nn->base);
++
++	nn->regmap = devm_regmap_init(dev, NULL, nn, &n3000_nios_regbus_cfg);
++	if (IS_ERR(nn->regmap))
++		return PTR_ERR(nn->regmap);
++
++	ret = n3000_nios_init_done_check(nn);
++	if (ret)
++		return ret;
++
++	ret = create_altera_spi_controller(nn);
++	if (ret)
++		dev_err(dev, "altera spi controller create failed: %d\n", ret);
++
++	return ret;
++}
++
++static void n3000_nios_remove(struct dfl_device *ddev)
++{
++	struct n3000_nios *nn = dev_get_drvdata(&ddev->dev);
++
++	destroy_altera_spi_controller(nn);
++}
++
++#define FME_FEATURE_ID_N3000_NIOS	0xd
++
++static const struct dfl_device_id n3000_nios_ids[] = {
++	{ FME_ID, FME_FEATURE_ID_N3000_NIOS },
++	{ }
++};
++MODULE_DEVICE_TABLE(dfl, n3000_nios_ids);
++
++static struct dfl_driver n3000_nios_driver = {
++	.drv	= {
++		.name       = "dfl-n3000-nios",
++		.dev_groups = n3000_nios_groups,
++	},
++	.id_table = n3000_nios_ids,
++	.probe   = n3000_nios_probe,
++	.remove  = n3000_nios_remove,
++};
++
++module_dfl_driver(n3000_nios_driver);
++
++MODULE_DESCRIPTION("Driver for Nios private feature on Intel PAC N3000");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0006-memory-dfl-emif-add-the-DFL-EMIF-private-feature-dri.patch new/debian/patches/fpga-ofs/0006-memory-dfl-emif-add-the-DFL-EMIF-private-feature-dri.patch
--- org/debian/patches/fpga-ofs/0006-memory-dfl-emif-add-the-DFL-EMIF-private-feature-dri.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0006-memory-dfl-emif-add-the-DFL-EMIF-private-feature-dri.patch	2021-07-20 06:17:11.332845072 +0200
@@ -0,0 +1,319 @@
+From 8db296240c5318427ed0a291f905c8b66c6deb0c Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Mon, 21 Sep 2020 13:09:48 +0800
+Subject: [PATCH 006/149] memory: dfl-emif: add the DFL EMIF private feature
+ driver
+
+This driver is for the EMIF private feature implemented under FPGA
+Device Feature List (DFL) framework. It is used to expose memory
+interface status information as well as memory clearing control.
+
+The purpose of memory clearing block is to zero out all private memory
+when FPGA is to be reprogrammed. This gives users a reliable method to
+prevent potential data leakage.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+Acked-by: Krzysztof Kozlowski <krzk@kernel.org>
+----
+v2: Adjust the position of this driver in Kconfig.
+    Improves the name of the Kconfig option.
+    Change the include dfl-bus.h to dfl.h, cause the previous patchset
+     renames the file.
+    Some minor fixes and comment improvement.
+v3: Adjust the position of the driver in Makefile.
+v9: Add static prefix for emif attributes macro.
+    Update the kernel version of the sysfs interfaces in Doc.
+v10: Rebase due to the dfl head file moves to include/linux.
+v11: Use sysfs_emit instead of sprintf.
+     Rebase to rebase to 5.10-rc1.
+---
+ .../ABI/testing/sysfs-bus-dfl-devices-emif    |  25 +++
+ drivers/memory/Kconfig                        |   9 +
+ drivers/memory/Makefile                       |   2 +
+ drivers/memory/dfl-emif.c                     | 207 ++++++++++++++++++
+ 4 files changed, 243 insertions(+)
+ create mode 100644 Documentation/ABI/testing/sysfs-bus-dfl-devices-emif
+ create mode 100644 drivers/memory/dfl-emif.c
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-dfl-devices-emif b/Documentation/ABI/testing/sysfs-bus-dfl-devices-emif
+new file mode 100644
+index 000000000000..1ae8ebd15b93
+--- /dev/null
++++ b/Documentation/ABI/testing/sysfs-bus-dfl-devices-emif
+@@ -0,0 +1,25 @@
++What:		/sys/bus/dfl/devices/dfl_dev.X/infX_cal_fail
++Date:		Oct 2020
++KernelVersion:	5.11
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Read-only. It indicates if the calibration failed on this
++		memory interface. "1" for calibration failure, "0" for OK.
++		Format: %u
++
++What:		/sys/bus/dfl/devices/dfl_dev.X/infX_init_done
++Date:		Oct 2020
++KernelVersion:	5.11
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Read-only. It indicates if the initialization completed on
++		this memory interface. "1" for initialization complete, "0"
++		for not yet.
++		Format: %u
++
++What:		/sys/bus/dfl/devices/dfl_dev.X/infX_clear
++Date:		Oct 2020
++KernelVersion:	5.11
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Write-only. Writing "1" to this file will zero out all memory
++		data in this memory interface. Writing of other values is
++		invalid.
++		Format: %u
+diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
+index cc2c83e1accf..4bc378460d9b 100644
+--- a/drivers/memory/Kconfig
++++ b/drivers/memory/Kconfig
+@@ -137,6 +137,15 @@ config TI_EMIF_SRAM
+ 	  sequence so this driver provides several relocatable PM functions
+ 	  for the SoC PM code to use.
+ 
++config FPGA_DFL_EMIF
++	tristate "FPGA DFL EMIF Driver"
++	depends on FPGA_DFL && HAS_IOMEM
++	help
++	  This driver is for the EMIF private feature implemented under
++	  FPGA Device Feature List (DFL) framework. It is used to expose
++	  memory interface status information as well as memory clearing
++	  control.
++
+ config MVEBU_DEVBUS
+ 	bool "Marvell EBU Device Bus Controller"
+ 	default y if PLAT_ORION
+diff --git a/drivers/memory/Makefile b/drivers/memory/Makefile
+index e71cf7b99641..bc7663ed1c25 100644
+--- a/drivers/memory/Makefile
++++ b/drivers/memory/Makefile
+@@ -28,6 +28,8 @@ obj-$(CONFIG_STM32_FMC2_EBI)	+= stm32-fmc2-ebi.o
+ obj-$(CONFIG_SAMSUNG_MC)	+= samsung/
+ obj-$(CONFIG_TEGRA_MC)		+= tegra/
+ obj-$(CONFIG_TI_EMIF_SRAM)	+= ti-emif-sram.o
++obj-$(CONFIG_FPGA_DFL_EMIF)	+= dfl-emif.o
++
+ ti-emif-sram-objs		:= ti-emif-pm.o ti-emif-sram-pm.o
+ 
+ AFLAGS_ti-emif-sram-pm.o	:=-Wa,-march=armv7-a
+diff --git a/drivers/memory/dfl-emif.c b/drivers/memory/dfl-emif.c
+new file mode 100644
+index 000000000000..3f719816771d
+--- /dev/null
++++ b/drivers/memory/dfl-emif.c
+@@ -0,0 +1,207 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * DFL device driver for EMIF private feature
++ *
++ * Copyright (C) 2020 Intel Corporation, Inc.
++ *
++ */
++#include <linux/bitfield.h>
++#include <linux/dfl.h>
++#include <linux/errno.h>
++#include <linux/io.h>
++#include <linux/iopoll.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/spinlock.h>
++#include <linux/types.h>
++
++#define FME_FEATURE_ID_EMIF		0x9
++
++#define EMIF_STAT			0x8
++#define EMIF_STAT_INIT_DONE_SFT		0
++#define EMIF_STAT_CALC_FAIL_SFT		8
++#define EMIF_STAT_CLEAR_BUSY_SFT	16
++#define EMIF_CTRL			0x10
++#define EMIF_CTRL_CLEAR_EN_SFT		0
++#define EMIF_CTRL_CLEAR_EN_MSK		GENMASK_ULL(3, 0)
++
++#define EMIF_POLL_INVL			10000 /* us */
++#define EMIF_POLL_TIMEOUT		5000000 /* us */
++
++struct dfl_emif {
++	struct device *dev;
++	void __iomem *base;
++	spinlock_t lock;	/* Serialises access to EMIF_CTRL reg */
++};
++
++struct emif_attr {
++	struct device_attribute attr;
++	u32 shift;
++	u32 index;
++};
++
++#define to_emif_attr(dev_attr) \
++	container_of(dev_attr, struct emif_attr, attr)
++
++static ssize_t emif_state_show(struct device *dev,
++			       struct device_attribute *attr, char *buf)
++{
++	struct emif_attr *eattr = to_emif_attr(attr);
++	struct dfl_emif *de = dev_get_drvdata(dev);
++	u64 val;
++
++	val = readq(de->base + EMIF_STAT);
++
++	return sysfs_emit(buf, "%u\n",
++			  !!(val & BIT_ULL(eattr->shift + eattr->index)));
++}
++
++static ssize_t emif_clear_store(struct device *dev,
++				struct device_attribute *attr,
++				const char *buf, size_t count)
++{
++	struct emif_attr *eattr = to_emif_attr(attr);
++	struct dfl_emif *de = dev_get_drvdata(dev);
++	u64 clear_busy_msk, clear_en_msk, val;
++	void __iomem *base = de->base;
++
++	if (!sysfs_streq(buf, "1"))
++		return -EINVAL;
++
++	clear_busy_msk = BIT_ULL(EMIF_STAT_CLEAR_BUSY_SFT + eattr->index);
++	clear_en_msk = BIT_ULL(EMIF_CTRL_CLEAR_EN_SFT + eattr->index);
++
++	spin_lock(&de->lock);
++	/* The CLEAR_EN field is WO, but other fields are RW */
++	val = readq(base + EMIF_CTRL);
++	val &= ~EMIF_CTRL_CLEAR_EN_MSK;
++	val |= clear_en_msk;
++	writeq(val, base + EMIF_CTRL);
++	spin_unlock(&de->lock);
++
++	if (readq_poll_timeout(base + EMIF_STAT, val,
++			       !(val & clear_busy_msk),
++			       EMIF_POLL_INVL, EMIF_POLL_TIMEOUT)) {
++		dev_err(de->dev, "timeout, fail to clear\n");
++		return -ETIMEDOUT;
++	}
++
++	return count;
++}
++
++#define emif_state_attr(_name, _shift, _index)				\
++	static struct emif_attr emif_attr_##inf##_index##_##_name =	\
++		{ .attr = __ATTR(inf##_index##_##_name, 0444,		\
++				 emif_state_show, NULL),		\
++		  .shift = (_shift), .index = (_index) }
++
++#define emif_clear_attr(_index)						\
++	static struct emif_attr emif_attr_##inf##_index##_clear =	\
++		{ .attr = __ATTR(inf##_index##_clear, 0200,		\
++				 NULL, emif_clear_store),		\
++		  .index = (_index) }
++
++emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 0);
++emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 1);
++emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 2);
++emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 3);
++
++emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 0);
++emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 1);
++emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 2);
++emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 3);
++
++emif_clear_attr(0);
++emif_clear_attr(1);
++emif_clear_attr(2);
++emif_clear_attr(3);
++
++static struct attribute *dfl_emif_attrs[] = {
++	&emif_attr_inf0_init_done.attr.attr,
++	&emif_attr_inf0_cal_fail.attr.attr,
++	&emif_attr_inf0_clear.attr.attr,
++
++	&emif_attr_inf1_init_done.attr.attr,
++	&emif_attr_inf1_cal_fail.attr.attr,
++	&emif_attr_inf1_clear.attr.attr,
++
++	&emif_attr_inf2_init_done.attr.attr,
++	&emif_attr_inf2_cal_fail.attr.attr,
++	&emif_attr_inf2_clear.attr.attr,
++
++	&emif_attr_inf3_init_done.attr.attr,
++	&emif_attr_inf3_cal_fail.attr.attr,
++	&emif_attr_inf3_clear.attr.attr,
++
++	NULL,
++};
++
++static umode_t dfl_emif_visible(struct kobject *kobj,
++				struct attribute *attr, int n)
++{
++	struct dfl_emif *de = dev_get_drvdata(kobj_to_dev(kobj));
++	struct emif_attr *eattr = container_of(attr, struct emif_attr,
++					       attr.attr);
++	u64 val;
++
++	/*
++	 * This device supports upto 4 memory interfaces, but not all
++	 * interfaces are used on different platforms. The read out value of
++	 * CLEAN_EN field (which is a bitmap) could tell how many interfaces
++	 * are available.
++	 */
++	val = FIELD_GET(EMIF_CTRL_CLEAR_EN_MSK, readq(de->base + EMIF_CTRL));
++
++	return (val & BIT_ULL(eattr->index)) ? attr->mode : 0;
++}
++
++static const struct attribute_group dfl_emif_group = {
++	.is_visible = dfl_emif_visible,
++	.attrs = dfl_emif_attrs,
++};
++
++static const struct attribute_group *dfl_emif_groups[] = {
++	&dfl_emif_group,
++	NULL,
++};
++
++static int dfl_emif_probe(struct dfl_device *ddev)
++{
++	struct device *dev = &ddev->dev;
++	struct dfl_emif *de;
++
++	de = devm_kzalloc(dev, sizeof(*de), GFP_KERNEL);
++	if (!de)
++		return -ENOMEM;
++
++	de->base = devm_ioremap_resource(dev, &ddev->mmio_res);
++	if (IS_ERR(de->base))
++		return PTR_ERR(de->base);
++
++	de->dev = dev;
++	spin_lock_init(&de->lock);
++	dev_set_drvdata(dev, de);
++
++	return 0;
++}
++
++static const struct dfl_device_id dfl_emif_ids[] = {
++	{ FME_ID, FME_FEATURE_ID_EMIF },
++	{ }
++};
++MODULE_DEVICE_TABLE(dfl, dfl_emif_ids);
++
++static struct dfl_driver dfl_emif_driver = {
++	.drv	= {
++		.name       = "dfl-emif",
++		.dev_groups = dfl_emif_groups,
++	},
++	.id_table = dfl_emif_ids,
++	.probe   = dfl_emif_probe,
++};
++module_dfl_driver(dfl_emif_driver);
++
++MODULE_DESCRIPTION("DFL EMIF driver");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0007-fpga-dfl-add-support-for-switching-the-retimer-FEC-m.patch new/debian/patches/fpga-ofs/0007-fpga-dfl-add-support-for-switching-the-retimer-FEC-m.patch
--- org/debian/patches/fpga-ofs/0007-fpga-dfl-add-support-for-switching-the-retimer-FEC-m.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0007-fpga-dfl-add-support-for-switching-the-retimer-FEC-m.patch	2021-07-20 06:17:11.332845072 +0200
@@ -0,0 +1,177 @@
+From 668ed943be0ca3e0d400f6ef44cb0cf4cde7d9f6 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Sat, 10 Oct 2020 10:38:27 +0800
+Subject: [PATCH 007/149] fpga: dfl: add support for switching the retimer FEC
+ mode
+
+The N3000 Nios private feature provides the one-time configuration for
+the retime FEC mode. The Nios firmware is responsible for the actual
+hardware operation. It gives users a chance (only one chance) to set the
+retimers to a different FEC mode.
+
+The Nios firmware has no nvmem to store the required FEC mode info, so it
+needs the user input everytime on board power up. So this patch
+introduced a module parameter for the user input.
+
+However, the community rejects this module parameter solution. Firstly
+the module parameter can not support different configuration for
+multiple boards. Secondly the maintainer thinks this configuration
+should not be cared by linux user, the bootloader (thus the on board
+firmware) should be changed to handle the configuration.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+---
+ .../testing/sysfs-bus-dfl-devices-n3000-nios  |  4 +-
+ Documentation/fpga/dfl-n3000-nios.rst         | 73 +++++++++++++++++++
+ Documentation/fpga/index.rst                  |  1 +
+ drivers/fpga/dfl-n3000-nios.c                 | 18 +++--
+ 4 files changed, 90 insertions(+), 6 deletions(-)
+ create mode 100644 Documentation/fpga/dfl-n3000-nios.rst
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-dfl-devices-n3000-nios b/Documentation/ABI/testing/sysfs-bus-dfl-devices-n3000-nios
+index a50553764654..26b4aa038e13 100644
+--- a/Documentation/ABI/testing/sysfs-bus-dfl-devices-n3000-nios
++++ b/Documentation/ABI/testing/sysfs-bus-dfl-devices-n3000-nios
+@@ -7,7 +7,9 @@ Description:	Read-only. Returns the FEC mode of the 25G links of the
+ 		Solomon FEC, "kr" for Fire Code FEC, "no" for NO FEC.
+ 		"not supported" if the FEC mode setting is not supported, this
+ 		happens when the Nios firmware version major < 3, or no link is
+-		configured to 25G.
++		configured to 25G. The FEC mode could be set by module
++		parameters, but it could only be set once after the board
++		powers up.
+ 		Format: string
+ 
+ What:		/sys/bus/dfl/devices/dfl_dev.X/retimer_A_mode
+diff --git a/Documentation/fpga/dfl-n3000-nios.rst b/Documentation/fpga/dfl-n3000-nios.rst
+new file mode 100644
+index 000000000000..66bc09150aba
+--- /dev/null
++++ b/Documentation/fpga/dfl-n3000-nios.rst
+@@ -0,0 +1,73 @@
++.. SPDX-License-Identifier: GPL-2.0
++
++=================================
++N3000 Nios Private Feature Driver
++=================================
++
++The N3000 Nios driver supports for the Nios handshake private feature on Intel
++PAC (Programmable Acceleration Card) N3000.
++
++The Nios is the embedded processor in the FPGA, it will configure the 2 onboard
++ethernet retimers on power up. This private feature provides a handshake
++interface to FPGA Nios firmware, which receives the ethernet retimer
++configuration command from host and does the configuration via an internal SPI
++master (spi-altera). When Nios finishes the configuration, host takes over the
++ownership of the SPI master to control an Intel MAX10 BMC (Board Management
++Controller) Chip on the SPI bus.
++
++So the driver does 2 major tasks on probe, uses the Nios firmware to configure
++the ethernet retimer, and then creates a spi master platform device with the
++MAX10 device info in spi_board_info.
++
++
++Configuring the ethernet retimer
++================================
++
++The Intel PAC N3000 is a FPGA based SmartNIC platform which could be programmed
++to various configurations (with different link numbers and speeds, e.g. 8x10G,
++4x25G ...). And the retimer chips should also be configured correspondingly by
++Nios firmware. There are 2 retimer chips on the board, each of them supports 4
++links. For example, in 8x10G configuration, the 2 retimer chips are both set to
++4x10G mode, while in 4x25G configuration, retimer A is set to 4x25G and retimer
++B is in reset. For now, the Nios firmware only supports 10G and 25G mode
++setting for the retimer chips.
++
++For all 25G links, their FEC (Forward Error Correction) mode could be further
++configured by Nios firmware for user's requirement. For 10G links, they don't
++have the FEC mode at all, the firmware ignores the FEC mode setting for them.
++The FEC setting is not supported if the firmware version major < 3.
++
++The retimer configuration can only be done once after the board powers up, the
++Nios firmware will not accept second configuration afterward. So it is not
++proper for the driver to create a RW sysfs node for the FEC mode. A better way
++is that the driver accepts a module parameter for the FEC mode, and does the
++retimer configuration on driver probe, it also creates a RO sysfs node for the
++FEC mode query.
++
++Module Parameters
++=================
++
++The N3000 Nios driver supports the following module parameters:
++
++* fec_mode: string
++  Require the Nios firmware to set the FEC mode for all 25G links of the
++  ethernet retimers. The Nios firmware configures all these links with the same
++  FEC mode. The possible values of fec_mode could be:
++
++  - "rs": Reed Solomon FEC (default)
++  - "kr": Fire Code FEC
++  - "no": No FEC
++
++  Since the firmware doesn't accept second configuration, The FEC mode will not
++  be changed if the module is reloaded with a different parameter value.
++
++  The parameter has no effect for 10G links. It has no effect to all the links
++  if firmware version major < 3.
++
++
++Sysfs Attributes
++================
++
++The driver creates some attributes in sysfs for users to query the retimer
++info. Please see Documentation/ABI/testing/sysfs-bus-dfl-devices-n3000-nios for
++more details.
+diff --git a/Documentation/fpga/index.rst b/Documentation/fpga/index.rst
+index f80f95667ca2..5fd3c379e1c8 100644
+--- a/Documentation/fpga/index.rst
++++ b/Documentation/fpga/index.rst
+@@ -8,6 +8,7 @@ fpga
+     :maxdepth: 1
+ 
+     dfl
++    dfl-n3000-nios
+ 
+ .. only::  subproject and html
+ 
+diff --git a/drivers/fpga/dfl-n3000-nios.c b/drivers/fpga/dfl-n3000-nios.c
+index 25018ef4e465..7c0af52d87e4 100644
+--- a/drivers/fpga/dfl-n3000-nios.c
++++ b/drivers/fpga/dfl-n3000-nios.c
+@@ -23,6 +23,10 @@
+ #include <linux/spi/spi.h>
+ #include <linux/types.h>
+ 
++static char *fec_mode = "rs";
++module_param(fec_mode, charp, 0444);
++MODULE_PARM_DESC(fec_mode, "FEC mode of the ethernet retimer on Intel PAC N3000");
++
+ /*
+  * N3000 Nios private feature registers, named as NIOS_SPI_XX on spec.
+  * NS is the abbreviation of NIOS_SPI.
+@@ -348,13 +352,17 @@ static int n3000_nios_init_done_check(struct n3000_nios *nn)
+ 		 * mode field cause host could not get the retimer working mode
+ 		 * until the Nios init is done.
+ 		 *
+-		 * For now the driver doesn't support the retimer FEC mode
+-		 * switching per user's request. It is always set to Reed
+-		 * Solomon FEC.
+-		 *
+ 		 * The driver will set the same FEC mode for all links.
+ 		 */
+-		val |= N3000_NIOS_INIT_REQ_FEC_MODE_RS_ALL;
++
++		if (!strcmp(fec_mode, "no"))
++			val |= N3000_NIOS_INIT_REQ_FEC_MODE_NO_ALL;
++		else if (!strcmp(fec_mode, "kr"))
++			val |= N3000_NIOS_INIT_REQ_FEC_MODE_KR_ALL;
++		else if (!strcmp(fec_mode, "rs"))
++			val |= N3000_NIOS_INIT_REQ_FEC_MODE_RS_ALL;
++		else
++			return -EINVAL;
+ 
+ 		ret = regmap_write(nn->regmap, N3000_NIOS_INIT, val);
+ 		if (ret)
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0008-fpga-dfl-add-driver_override-support.patch new/debian/patches/fpga-ofs/0008-fpga-dfl-add-driver_override-support.patch
--- org/debian/patches/fpga-ofs/0008-fpga-dfl-add-driver_override-support.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0008-fpga-dfl-add-driver_override-support.patch	2021-07-20 06:17:11.336845061 +0200
@@ -0,0 +1,157 @@
+From 8d4b8d6088974c1810b74f9b6c739c690cd7fbfe Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Fri, 19 Jun 2020 11:14:31 +0800
+Subject: [PATCH 008/149] fpga: dfl: add driver_override support
+
+Add support for overriding the default matching of a dfl device to a dfl
+driver. It follows the same way that can be used for PCI and platform
+devices. This patch adds the 'driver_override' sysfs file.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+----
+v2: use sysfs_emit instead of sprintf.
+    some minor fixes.
+---
+ Documentation/ABI/testing/sysfs-bus-dfl | 21 ++++++++++
+ drivers/fpga/dfl.c                      | 54 ++++++++++++++++++++++++-
+ include/linux/dfl.h                     |  2 +
+ 3 files changed, 76 insertions(+), 1 deletion(-)
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-dfl b/Documentation/ABI/testing/sysfs-bus-dfl
+index b0265ab17200..679981eec897 100644
+--- a/Documentation/ABI/testing/sysfs-bus-dfl
++++ b/Documentation/ABI/testing/sysfs-bus-dfl
+@@ -15,3 +15,24 @@ Description:	Read-only. It returns feature identifier local to its DFL FIU
+ 		type.
+ 
+ 		Format: 0x%x
++
++What:		/sys/bus/dfl/devices/.../driver_override
++Date:		Oct 2020
++KernelVersion:	5.11
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	This file allows the driver for a device to be specified which
++		will override the standard ID table matching. When specified,
++		only a driver with a name matching the value written to
++		driver_override will have an opportunity to bind to the device.
++		The override is specified by writing a string to the
++		driver_override file (echo dfl-uio-pdev > driver_override) and
++		may be cleared with an empty string (echo > driver_override).
++		This returns the device to standard matching rules binding.
++		Writing to driver_override does not automatically unbind the
++		device from its current driver or make any attempt to
++		automatically load the specified driver.  If no driver with a
++		matching name is currently loaded in the kernel, the device
++		will not bind to any driver.  This also allows devices to
++		opt-out of driver binding using a driver_override name such as
++		"none".  Only a single driver may be specified in the override,
++		there is no support for parsing delimiters.
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index 511b20ff35a3..df0ebd2ed0da 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -262,6 +262,10 @@ static int dfl_bus_match(struct device *dev, struct device_driver *drv)
+ 	struct dfl_driver *ddrv = to_dfl_drv(drv);
+ 	const struct dfl_device_id *id_entry;
+ 
++	/* When driver_override is set, only bind to the matching driver */
++	if (ddev->driver_override)
++		return !strcmp(ddev->driver_override, drv->name);
++
+ 	id_entry = ddrv->id_table;
+ 	if (id_entry) {
+ 		while (id_entry->feature_id) {
+@@ -303,6 +307,53 @@ static int dfl_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+ 			      ddev->type, ddev->feature_id);
+ }
+ 
++static ssize_t driver_override_show(struct device *dev,
++				    struct device_attribute *attr, char *buf)
++{
++	struct dfl_device *ddev = to_dfl_dev(dev);
++	ssize_t len;
++
++	device_lock(dev);
++	len = sysfs_emit(buf, "%s\n", ddev->driver_override);
++	device_unlock(dev);
++	return len;
++}
++
++static ssize_t driver_override_store(struct device *dev,
++				     struct device_attribute *attr,
++				     const char *buf, size_t count)
++{
++	struct dfl_device *ddev = to_dfl_dev(dev);
++	char *driver_override, *old, *cp;
++
++	/* We need to keep extra room for a newline */
++	if (count >= (PAGE_SIZE - 1))
++		return -EINVAL;
++
++	driver_override = kstrndup(buf, count, GFP_KERNEL);
++	if (!driver_override)
++		return -ENOMEM;
++
++	cp = strchr(driver_override, '\n');
++	if (cp)
++		*cp = '\0';
++
++	device_lock(dev);
++	old = ddev->driver_override;
++	if (strlen(driver_override)) {
++		ddev->driver_override = driver_override;
++	} else {
++		kfree(driver_override);
++		ddev->driver_override = NULL;
++	}
++	device_unlock(dev);
++
++	kfree(old);
++
++	return count;
++}
++static DEVICE_ATTR_RW(driver_override);
++
+ static ssize_t
+ type_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+@@ -324,6 +375,7 @@ static DEVICE_ATTR_RO(feature_id);
+ static struct attribute *dfl_dev_attrs[] = {
+ 	&dev_attr_type.attr,
+ 	&dev_attr_feature_id.attr,
++	&dev_attr_driver_override.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(dfl_dev);
+@@ -469,7 +521,7 @@ static int dfl_devs_add(struct dfl_feature_platform_data *pdata)
+ 
+ int __dfl_driver_register(struct dfl_driver *dfl_drv, struct module *owner)
+ {
+-	if (!dfl_drv || !dfl_drv->probe || !dfl_drv->id_table)
++	if (!dfl_drv || !dfl_drv->probe)
+ 		return -EINVAL;
+ 
+ 	dfl_drv->drv.owner = owner;
+diff --git a/include/linux/dfl.h b/include/linux/dfl.h
+index 7affba2fd545..e1b2471f0f86 100644
+--- a/include/linux/dfl.h
++++ b/include/linux/dfl.h
+@@ -32,6 +32,7 @@ enum dfl_id_type {
+  * @num_irqs: number of IRQs supported by this dfl device.
+  * @cdev: pointer to DFL FPGA container device this dfl device belongs to.
+  * @id_entry: matched id entry in dfl driver's id table.
++ * @driver_override: driver name to force a match
+  */
+ struct dfl_device {
+ 	struct device dev;
+@@ -43,6 +44,7 @@ struct dfl_device {
+ 	unsigned int num_irqs;
+ 	struct dfl_fpga_cdev *cdev;
+ 	const struct dfl_device_id *id_entry;
++	char *driver_override;
+ };
+ 
+ /**
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0009-fpga-dfl-add-the-userspace-I-O-device-support-for-DF.patch new/debian/patches/fpga-ofs/0009-fpga-dfl-add-the-userspace-I-O-device-support-for-DF.patch
--- org/debian/patches/fpga-ofs/0009-fpga-dfl-add-the-userspace-I-O-device-support-for-DF.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0009-fpga-dfl-add-the-userspace-I-O-device-support-for-DF.patch	2021-07-20 06:17:11.336845061 +0200
@@ -0,0 +1,147 @@
+From c41be607a04de171790349af88ec44f4d7677e59 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Mon, 28 Sep 2020 16:12:07 +0800
+Subject: [PATCH 009/149] fpga: dfl: add the userspace I/O device support for
+ DFL devices
+
+This patch supports the DFL drivers be written in userspace. This is
+realized by exposing the userspace I/O device interfaces. The driver
+leverages the uio_pdrv_genirq, it adds the uio_pdrv_genirq platform
+device with the DFL device's resources, and let the generic UIO platform
+device driver provide support to userspace access to kernel interrupts
+and memory locations.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+----
+v2: refacor the code about device resources filling.
+    fix some comments.
+---
+ drivers/fpga/Kconfig        | 10 +++++
+ drivers/fpga/Makefile       |  1 +
+ drivers/fpga/dfl-uio-pdev.c | 81 +++++++++++++++++++++++++++++++++++++
+ 3 files changed, 92 insertions(+)
+ create mode 100644 drivers/fpga/dfl-uio-pdev.c
+
+diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
+index 5ff9438b7b46..c72559e2fc88 100644
+--- a/drivers/fpga/Kconfig
++++ b/drivers/fpga/Kconfig
+@@ -203,6 +203,16 @@ config FPGA_DFL_NIOS_INTEL_PAC_N3000
+ 	  the card. It also instantiates the SPI master (spi-altera) for
+ 	  the card's BMC (Board Management Controller).
+ 
++config FPGA_DFL_UIO_PDEV
++	tristate "FPGA DFL Driver for Userspace I/O platform devices"
++	depends on FPGA_DFL && UIO_PDRV_GENIRQ
++	help
++	  Enable this to allow some DFL drivers be written in userspace. It
++	  adds the uio_pdrv_genirq platform device with the DFL device's
++	  resources, and lets the generic UIO platform device driver provide
++	  support to userspace access to kernel interrupts and memory
++	  locations.
++
+ config FPGA_DFL_PCI
+ 	tristate "FPGA DFL PCIe Device Driver"
+ 	depends on PCI && FPGA_DFL
+diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
+index 18dc9885883a..e07b3d5b3ee6 100644
+--- a/drivers/fpga/Makefile
++++ b/drivers/fpga/Makefile
+@@ -45,6 +45,7 @@ dfl-afu-objs := dfl-afu-main.o dfl-afu-region.o dfl-afu-dma-region.o
+ dfl-afu-objs += dfl-afu-error.o
+ 
+ obj-$(CONFIG_FPGA_DFL_NIOS_INTEL_PAC_N3000)	+= dfl-n3000-nios.o
++obj-$(CONFIG_FPGA_DFL_UIO_PDEV)	+= dfl-uio-pdev.o
+ 
+ # Drivers for FPGAs which implement DFL
+ obj-$(CONFIG_FPGA_DFL_PCI)		+= dfl-pci.o
+diff --git a/drivers/fpga/dfl-uio-pdev.c b/drivers/fpga/dfl-uio-pdev.c
+new file mode 100644
+index 000000000000..dcb6bd1c616b
+--- /dev/null
++++ b/drivers/fpga/dfl-uio-pdev.c
+@@ -0,0 +1,81 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * DFL driver for Userspace I/O platform devices
++ *
++ * Copyright (C) 2020 Intel Corporation, Inc.
++ */
++#include <linux/dfl.h>
++#include <linux/errno.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/slab.h>
++#include <linux/uio_driver.h>
++
++#define DRIVER_NAME "dfl-uio-pdev"
++
++static int dfl_uio_pdev_probe(struct dfl_device *ddev)
++{
++	struct device *dev = &ddev->dev;
++	struct platform_device_info pdevinfo = { 0 };
++	struct uio_info uio_pdata = { 0 };
++	struct platform_device *uio_pdev;
++	struct resource *res;
++	int i;
++
++	pdevinfo.name = "uio_pdrv_genirq";
++
++	res = kcalloc(ddev->num_irqs + 1, sizeof(*res), GFP_KERNEL);
++	if (!res)
++		return -ENOMEM;
++
++	res[0].parent = &ddev->mmio_res;
++	res[0].flags = IORESOURCE_MEM;
++	res[0].start = ddev->mmio_res.start;
++	res[0].end = ddev->mmio_res.end;
++
++	/* then add irq resource */
++	for (i = 0; i < ddev->num_irqs; i++) {
++		res[i + 1].flags = IORESOURCE_IRQ;
++		res[i + 1].start = ddev->irqs[i];
++		res[i + 1].end = ddev->irqs[i];
++	}
++
++	uio_pdata.name = DRIVER_NAME;
++	uio_pdata.version = "0";
++
++	pdevinfo.res = res;
++	pdevinfo.num_res = ddev->num_irqs + 1;
++	pdevinfo.parent = &ddev->dev;
++	pdevinfo.id = PLATFORM_DEVID_AUTO;
++	pdevinfo.data = &uio_pdata;
++	pdevinfo.size_data = sizeof(uio_pdata);
++
++	uio_pdev = platform_device_register_full(&pdevinfo);
++	if (!IS_ERR(uio_pdev))
++		dev_set_drvdata(dev, uio_pdev);
++
++	kfree(res);
++
++	return PTR_ERR_OR_ZERO(uio_pdev);
++}
++
++static void dfl_uio_pdev_remove(struct dfl_device *ddev)
++{
++	struct platform_device *uio_pdev = dev_get_drvdata(&ddev->dev);
++
++	platform_device_unregister(uio_pdev);
++}
++
++static struct dfl_driver dfl_uio_pdev_driver = {
++	.drv	= {
++		.name       = DRIVER_NAME,
++	},
++	.probe	= dfl_uio_pdev_probe,
++	.remove	= dfl_uio_pdev_remove,
++};
++module_dfl_driver(dfl_uio_pdev_driver);
++
++MODULE_DESCRIPTION("DFL driver for Userspace I/O platform devices");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0010-fpga-dfl-export-network-configuration-info-for-DFL-b.patch new/debian/patches/fpga-ofs/0010-fpga-dfl-export-network-configuration-info-for-DFL-b.patch
--- org/debian/patches/fpga-ofs/0010-fpga-dfl-export-network-configuration-info-for-DFL-b.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0010-fpga-dfl-export-network-configuration-info-for-DFL-b.patch	2021-07-20 06:17:11.336845061 +0200
@@ -0,0 +1,127 @@
+From 06d847d8e36e3e2c0513390a68b66d067cf1b696 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Mon, 9 Mar 2020 23:41:09 +0800
+Subject: [PATCH 010/149] fpga: dfl: export network configuration info for DFL
+ based FPGA
+
+This patch makes preparation for supporting DFL Ether Group private
+feature driver, which reads bitstream_id.vendor_net_cfg field to
+determin the interconnection of network components on FPGA device.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Reviewed-by: Wu Hao <hao.wu@intel.com>
+Reviewed-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+----
+v2: No change
+v3: delete NULL check for dfl_get_bitstream_id() &
+    dfl_dev_get_vendor_net_cfg()
+v4: fix failure of getting vendor net cfg on dfl dev probe.
+     dfl_devices in fme could get its fme device directly by its
+     parent. For other types of dfl_devices, the API still get the
+     fme_dev through cdev.
+---
+ drivers/fpga/dfl-fme-main.c | 10 ++--------
+ drivers/fpga/dfl.c          | 21 +++++++++++++++++++++
+ drivers/fpga/dfl.h          | 12 ++++++++++++
+ include/linux/dfl.h         |  2 ++
+ 4 files changed, 37 insertions(+), 8 deletions(-)
+
+diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
+index 77ea04d4edbe..a2b8ba0bf291 100644
+--- a/drivers/fpga/dfl-fme-main.c
++++ b/drivers/fpga/dfl-fme-main.c
+@@ -46,14 +46,8 @@ static DEVICE_ATTR_RO(ports_num);
+ static ssize_t bitstream_id_show(struct device *dev,
+ 				 struct device_attribute *attr, char *buf)
+ {
+-	void __iomem *base;
+-	u64 v;
+-
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
+-
+-	v = readq(base + FME_HDR_BITSTREAM_ID);
+-
+-	return scnprintf(buf, PAGE_SIZE, "0x%llx\n", (unsigned long long)v);
++	return scnprintf(buf, PAGE_SIZE, "0x%llx\n",
++			 (unsigned long long)dfl_get_bitstream_id(dev));
+ }
+ static DEVICE_ATTR_RO(bitstream_id);
+ 
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index df0ebd2ed0da..e7855b721fd0 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -537,6 +537,27 @@ void dfl_driver_unregister(struct dfl_driver *dfl_drv)
+ }
+ EXPORT_SYMBOL(dfl_driver_unregister);
+ 
++int dfl_dev_get_vendor_net_cfg(struct dfl_device *dfl_dev)
++{
++	struct device *fme_dev;
++	u64 v;
++
++	if (!dfl_dev)
++		return -EINVAL;
++
++	if (dfl_dev->type == FME_ID)
++		fme_dev = dfl_dev->dev.parent;
++	else
++		fme_dev = dfl_dev->cdev->fme_dev;
++
++	if (!fme_dev)
++		return -EINVAL;
++
++	v = dfl_get_bitstream_id(fme_dev);
++	return (int)FIELD_GET(FME_BID_VENDOR_NET_CFG, v);
++}
++EXPORT_SYMBOL_GPL(dfl_dev_get_vendor_net_cfg);
++
+ #define is_header_feature(feature) ((feature)->id == FEATURE_ID_FIU_HEADER)
+ 
+ /**
+diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
+index 2b82c96ba56c..6c7a69612bff 100644
+--- a/drivers/fpga/dfl.h
++++ b/drivers/fpga/dfl.h
+@@ -104,6 +104,9 @@
+ #define FME_CAP_CACHE_SIZE	GENMASK_ULL(43, 32)	/* cache size in KB */
+ #define FME_CAP_CACHE_ASSOC	GENMASK_ULL(47, 44)	/* Associativity */
+ 
++/* FME BITSTREAM_ID Register Bitfield */
++#define FME_BID_VENDOR_NET_CFG	GENMASK_ULL(35, 32)     /* vendor net cfg */
++
+ /* FME Port Offset Register Bitfield */
+ /* Offset to port device feature header */
+ #define FME_PORT_OFST_DFH_OFST	GENMASK_ULL(23, 0)
+@@ -397,6 +400,15 @@ static inline bool is_dfl_feature_present(struct device *dev, u16 id)
+ 	return !!dfl_get_feature_ioaddr_by_id(dev, id);
+ }
+ 
++static inline u64 dfl_get_bitstream_id(struct device *dev)
++{
++	void __iomem *base;
++
++	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
++
++	return readq(base + FME_HDR_BITSTREAM_ID);
++}
++
+ static inline
+ struct device *dfl_fpga_pdata_to_parent(struct dfl_feature_platform_data *pdata)
+ {
+diff --git a/include/linux/dfl.h b/include/linux/dfl.h
+index e1b2471f0f86..5ee2b1e87081 100644
+--- a/include/linux/dfl.h
++++ b/include/linux/dfl.h
+@@ -67,6 +67,8 @@ struct dfl_driver {
+ #define to_dfl_dev(d) container_of(d, struct dfl_device, dev)
+ #define to_dfl_drv(d) container_of(d, struct dfl_driver, drv)
+ 
++int dfl_dev_get_vendor_net_cfg(struct dfl_device *dfl_dev);
++
+ /*
+  * use a macro to avoid include chaining to get THIS_MODULE.
+  */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0011-fpga-dfl-add-an-API-to-get-the-base-device-for-dfl-d.patch new/debian/patches/fpga-ofs/0011-fpga-dfl-add-an-API-to-get-the-base-device-for-dfl-d.patch
--- org/debian/patches/fpga-ofs/0011-fpga-dfl-add-an-API-to-get-the-base-device-for-dfl-d.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0011-fpga-dfl-add-an-API-to-get-the-base-device-for-dfl-d.patch	2021-07-20 06:17:11.340845049 +0200
@@ -0,0 +1,58 @@
+From 664ce3c34e401d107fcfc4e2a8c2e4f7fd0a0c65 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Tue, 21 Apr 2020 22:51:00 +0800
+Subject: [PATCH 011/149] fpga: dfl: add an API to get the base device for dfl
+ device
+
+This patch adds an API for dfl devices to find which physical device
+owns the DFL.
+
+This patch makes preparation for supporting DFL Ether Group private
+feature driver. It uses this information to determine which retimer
+device physically connects to which ether group.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Reviewed-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+----
+v2: change commit msg according to Matthew's suggestion.
+v3: no change.
+---
+ drivers/fpga/dfl.c  | 9 +++++++++
+ include/linux/dfl.h | 1 +
+ 2 files changed, 10 insertions(+)
+
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index e7855b721fd0..cf93cf4b0c75 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -558,6 +558,15 @@ int dfl_dev_get_vendor_net_cfg(struct dfl_device *dfl_dev)
+ }
+ EXPORT_SYMBOL_GPL(dfl_dev_get_vendor_net_cfg);
+ 
++struct device *dfl_dev_get_base_dev(struct dfl_device *dfl_dev)
++{
++	if (!dfl_dev || !dfl_dev->cdev)
++		return NULL;
++
++	return dfl_dev->cdev->parent;
++}
++EXPORT_SYMBOL_GPL(dfl_dev_get_base_dev);
++
+ #define is_header_feature(feature) ((feature)->id == FEATURE_ID_FIU_HEADER)
+ 
+ /**
+diff --git a/include/linux/dfl.h b/include/linux/dfl.h
+index 5ee2b1e87081..dd313f24efef 100644
+--- a/include/linux/dfl.h
++++ b/include/linux/dfl.h
+@@ -68,6 +68,7 @@ struct dfl_driver {
+ #define to_dfl_drv(d) container_of(d, struct dfl_driver, drv)
+ 
+ int dfl_dev_get_vendor_net_cfg(struct dfl_device *dfl_dev);
++struct device *dfl_dev_get_base_dev(struct dfl_device *dfl_dev);
+ 
+ /*
+  * use a macro to avoid include chaining to get THIS_MODULE.
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0012-docs-networking-add-the-document-for-DFL-Ether-Group.patch new/debian/patches/fpga-ofs/0012-docs-networking-add-the-document-for-DFL-Ether-Group.patch
--- org/debian/patches/fpga-ofs/0012-docs-networking-add-the-document-for-DFL-Ether-Group.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0012-docs-networking-add-the-document-for-DFL-Ether-Group.patch	2021-07-20 06:17:11.340845049 +0200
@@ -0,0 +1,138 @@
+From ca1493167c79d7c498b173d3f0e53e86d3b13617 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Fri, 23 Oct 2020 00:41:00 +0800
+Subject: [PATCH 012/149] docs: networking: add the document for DFL Ether
+ Group driver
+
+This patch adds the document for DFL Ether Group driver.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+---
+ .../device_drivers/ethernet/index.rst         |   1 +
+ .../ethernet/intel/dfl-eth-group.rst          | 102 ++++++++++++++++++
+ 2 files changed, 103 insertions(+)
+ create mode 100644 Documentation/networking/device_drivers/ethernet/intel/dfl-eth-group.rst
+
+diff --git a/Documentation/networking/device_drivers/ethernet/index.rst b/Documentation/networking/device_drivers/ethernet/index.rst
+index cbb75a1818c0..eb7c44347a6f 100644
+--- a/Documentation/networking/device_drivers/ethernet/index.rst
++++ b/Documentation/networking/device_drivers/ethernet/index.rst
+@@ -26,6 +26,7 @@ Contents:
+    freescale/gianfar
+    google/gve
+    huawei/hinic
++   intel/dfl-eth-group
+    intel/e100
+    intel/e1000
+    intel/e1000e
+diff --git a/Documentation/networking/device_drivers/ethernet/intel/dfl-eth-group.rst b/Documentation/networking/device_drivers/ethernet/intel/dfl-eth-group.rst
+new file mode 100644
+index 000000000000..525807e9d0dc
+--- /dev/null
++++ b/Documentation/networking/device_drivers/ethernet/intel/dfl-eth-group.rst
+@@ -0,0 +1,102 @@
++.. SPDX-License-Identifier: GPL-2.0+
++
++=======================================================================
++DFL device driver for Ether Group private feature on Intel(R) PAC N3000
++=======================================================================
++
++This is the driver for Ether Group private feature on Intel(R)
++PAC (Programmable Acceleration Card) N3000.
++
++The Intel(R) PAC N3000 is a FPGA based SmartNIC platform for multi-workload
++networking application acceleration. A simple diagram below to for the board:
++
++                     +----------------------------------------+
++                     |                  FPGA                  |
+++----+   +-------+   +-----------+  +----------+  +-----------+   +----------+
++|QSFP|---|retimer|---|Line Side  |--|User logic|--|Host Side  |---|XL710     |
+++----+   +-------+   |Ether Group|  |          |  |Ether Group|   |Ethernet  |
++                     |(PHY + MAC)|  |wiring &  |  |(MAC + PHY)|   |Controller|
++                     +-----------+  |offloading|  +-----------+   +----------+
++                     |              +----------+              |
++                     |                                        |
++                     +----------------------------------------+
++
++The FPGA is composed of FPGA Interface Module (FIM) and Accelerated Function
++Unit (AFU). The FIM implements the basic functionalities for FPGA access,
++management and reprograming, while the AFU is the FPGA reprogramable region for
++users.
++
++The Line Side & Host Side Ether Groups are soft IP blocks embedded in FIM. They
++are internally wire connected to AFU and communicate with AFU with MAC packets.
++The user logic is developed by the FPGA users and re-programmed to AFU,
++providing the user defined wire connections between line side & host side data
++interfaces, as well as the MAC layer offloading.
++
++There are 2 types of interfaces for the Ether Groups:
++
++1. The data interfaces connects the Ether Groups and the AFU, host has no
++ability to control the data stream . So the FPGA is like a pipe between the
++host ethernet controller and the retimer chip.
++
++2. The management interfaces connects the Ether Groups to the host, so host
++could access the Ether Group registers for configuration and statistics
++reading.
++
++The Intel(R) PAC N3000 could be programmed to various configurations (with
++different link numbers and speeds, e.g. 8x10G, 4x25G ...). It is done by
++programing different variants of the Ether Group IP blocks, and doing
++corresponding configuration to the retimer chips.
++
++The DFL Ether Group driver registers netdev for each line side link. Users
++could use standard commands (ethtool, ip, ifconfig) for configuration and
++link state/statistics reading. For host side links, they are always connected
++to the host ethernet controller, so they should always have same features as
++the host ethernet controller. There is no need to register netdevs for them.
++The driver just enables these links on probe.
++
++The retimer chips are managed by onboard BMC (Board Management Controller)
++firmware, host driver is not capable to access them directly. So it is mostly
++like an external fixed PHY. However the link states detected by the retimer
++chips can not be propagated to the Ether Groups for hardware limitation, in
++order to manage the link state, a PHY driver (intel-m10-bmc-retimer) is
++introduced to query the BMC for the retimer's link state. The Ether Group
++driver would connect to the PHY devices and get the link states. The
++intel-m10-bmc-retimer driver creates a peseudo MDIO bus for each board, so
++that the Ether Group driver could find the PHY devices by their peseudo PHY
++addresses.
++
++
++2. Features supported
++=====================
++
++Data Path
++---------
++Since the driver can't control the data stream, the Ether Group driver
++doesn't implement the valid tx/rx functions. Any transmit attempt on these
++links from host will be dropped, and no data could be received to host from
++these links. Users should operate on the netdev of host ethernet controller
++for networking data traffic.
++
++
++Speed/Duplex
++------------
++The Ether Group doesn't support auto-negotiation. The link speed is fixed to
++10G, 25G or 40G full duplex according to which Ether Group IP is programmed.
++
++Statistics
++----------
++The Ether Group IP has the statistics counters for ethernet traffic and errors.
++The user can obtain these MAC-level statistics using "ethtool -S" option.
++
++MTU
++---
++The Ether Group IP is capable of detecting oversized packets. It will not drop
++the packet but pass it up and increment the tx/rx oversize counters. The MTU
++could be changed via ip or ifconfig commands.
++
++Flow Control
++------------
++Ethernet Flow Control (IEEE 802.3x) can be configured with ethtool to enable
++transmitting pause frames. Receiving pause request from outside to Ether Group
++MAC is not supported. The flow control auto-negotiation is not supported. The
++user can enable or disable Tx Flow Control using "ethtool -A eth? tx <on|off>"
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0013-ethernet-m10-retimer-add-support-for-retimers-on-Int.patch new/debian/patches/fpga-ofs/0013-ethernet-m10-retimer-add-support-for-retimers-on-Int.patch
--- org/debian/patches/fpga-ofs/0013-ethernet-m10-retimer-add-support-for-retimers-on-Int.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0013-ethernet-m10-retimer-add-support-for-retimers-on-Int.patch	2021-07-20 06:17:11.344845038 +0200
@@ -0,0 +1,434 @@
+From 3a42989c5287f8e860758f77ea1a1ee827a639f9 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Mon, 23 Mar 2020 15:15:35 +0800
+Subject: [PATCH 013/149] ethernet: m10-retimer: add support for retimers on
+ Intel MAX 10 BMC
+
+This driver supports the ethernet retimers (Parkvale) for the Intel PAC
+(Programmable Acceleration Card) N3000, which is a FPGA based Smart NIC.
+
+Parkvale is an Intel(R) Ethernet serdes transceiver chip that supports up
+to 100G transfer. On Intel PAC N3000 there are 2 Parkvale chips managed
+by the Intel MAX 10 BMC firmware. They are configured in 4 ports 10G/25G
+retimer mode. Host could query their link status via retimer interfaces
+(Shared registers) on Intel MAX 10 BMC.
+
+The driver adds the phy device for each port of the 2 retimer chips.
+Since the phys are not accessed by the real MDIO bus, it creates a virtual
+mdio bus for each NIC device instance, and a dedicated phy driver which
+only provides the supported features and link state.
+
+A DFL Ether Group driver will create net devices and connect to these
+phys.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+----
+v2: pass struct device * to create_altr_spi_controller() instead of
+    struct dfl_device *
+    Add THIS_MODULE param for phy_driver_register()
+v3: fix bug that static struct m10_n3000_pdata will cause problem on
+    multiphy device instances.
+v4: detach the net device when the phy is to be removed.
+     It is possible the phy device is removed before the attached net
+     device. If the phy device is removed silently, kernel bug happens
+     when the net device still tries to operate on the phy.
+v5: replace all the 'pkvl' -> 'retimer'
+---
+ drivers/fpga/dfl-n3000-nios.c                 |  11 +-
+ drivers/mfd/intel-m10-bmc.c                   |  18 ++
+ drivers/net/ethernet/intel/Kconfig            |  12 +
+ drivers/net/ethernet/intel/Makefile           |   2 +
+ .../ethernet/intel/intel-m10-bmc-retimer.c    | 229 ++++++++++++++++++
+ include/linux/mfd/intel-m10-bmc.h             |  16 ++
+ 6 files changed, 286 insertions(+), 2 deletions(-)
+ create mode 100644 drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+
+diff --git a/drivers/fpga/dfl-n3000-nios.c b/drivers/fpga/dfl-n3000-nios.c
+index 7c0af52d87e4..dc0392c00bd4 100644
+--- a/drivers/fpga/dfl-n3000-nios.c
++++ b/drivers/fpga/dfl-n3000-nios.c
+@@ -16,6 +16,7 @@
+ #include <linux/io-64-nonatomic-lo-hi.h>
+ #include <linux/kernel.h>
+ #include <linux/module.h>
++#include <linux/mfd/intel-m10-bmc.h>
+ #include <linux/platform_device.h>
+ #include <linux/regmap.h>
+ #include <linux/stddef.h>
+@@ -163,6 +164,8 @@ struct n3000_nios {
+ 	struct regmap *regmap;
+ 	struct device *dev;
+ 	struct platform_device *altera_spi;
++	struct intel_m10bmc_platdata m10bmc_pdata;
++	struct intel_m10bmc_retimer_pdata m10bmc_retimer_pdata;
+ };
+ 
+ static ssize_t nios_fw_version_show(struct device *dev,
+@@ -420,7 +423,8 @@ static struct spi_board_info m10_n3000_info = {
+ 	.chip_select = 0,
+ };
+ 
+-static int create_altera_spi_controller(struct n3000_nios *nn)
++static int create_altera_spi_controller(struct n3000_nios *nn,
++					struct device *retimer_master)
+ {
+ 	struct altera_spi_platform_data pdata = { 0 };
+ 	struct platform_device_info pdevinfo = { 0 };
+@@ -439,6 +443,9 @@ static int create_altera_spi_controller(struct n3000_nios *nn)
+ 	pdata.bits_per_word_mask =
+ 		SPI_BPW_RANGE_MASK(1, FIELD_GET(N3000_NS_PARAM_DATA_WIDTH, v));
+ 
++	nn->m10bmc_retimer_pdata.retimer_master = retimer_master;
++	nn->m10bmc_pdata.retimer = &nn->m10bmc_retimer_pdata;
++	m10_n3000_info.platform_data = &nn->m10bmc_pdata;
+ 	pdata.num_devices = 1;
+ 	pdata.devices = &m10_n3000_info;
+ 
+@@ -557,7 +564,7 @@ static int n3000_nios_probe(struct dfl_device *ddev)
+ 	if (ret)
+ 		return ret;
+ 
+-	ret = create_altera_spi_controller(nn);
++	ret = create_altera_spi_controller(nn, dfl_dev_get_base_dev(ddev));
+ 	if (ret)
+ 		dev_err(dev, "altera spi controller create failed: %d\n", ret);
+ 
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index b84579b7b4f0..adbfb17713b1 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -23,6 +23,21 @@ static struct mfd_cell m10bmc_pacn3000_subdevs[] = {
+ 	{ .name = "n3000bmc-secure" },
+ };
+ 
++static void
++m10bmc_init_cells_platdata(struct intel_m10bmc_platdata *pdata,
++			   struct mfd_cell *cells, int n_cell)
++{
++	int i;
++
++	for (i = 0; i < n_cell; i++) {
++		if (!strcmp(cells[i].name, "n3000bmc-retimer")) {
++			cells[i].platform_data = pdata->retimer;
++			cells[i].pdata_size =
++				pdata->retimer ? sizeof(*pdata->retimer) : 0;
++		}
++	}
++}
++
+ static struct regmap_config intel_m10bmc_regmap_config = {
+ 	.reg_bits = 32,
+ 	.val_bits = 32,
+@@ -97,6 +112,7 @@ static int check_m10bmc_version(struct intel_m10bmc *ddata)
+ 
+ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ {
++	struct intel_m10bmc_platdata *pdata = dev_get_platdata(&spi->dev);
+ 	const struct spi_device_id *id = spi_get_device_id(spi);
+ 	struct device *dev = &spi->dev;
+ 	struct mfd_cell *cells;
+@@ -134,6 +150,8 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ 		return -ENODEV;
+ 	}
+ 
++	m10bmc_init_cells_platdata(pdata, cells, n_cell);
++
+ 	ret = devm_mfd_add_devices(dev, PLATFORM_DEVID_AUTO, cells, n_cell,
+ 				   NULL, 0, NULL);
+ 	if (ret)
+diff --git a/drivers/net/ethernet/intel/Kconfig b/drivers/net/ethernet/intel/Kconfig
+index 5aa86318ed3e..81c43d4a0cc5 100644
+--- a/drivers/net/ethernet/intel/Kconfig
++++ b/drivers/net/ethernet/intel/Kconfig
+@@ -343,4 +343,16 @@ config IGC
+ 	  To compile this driver as a module, choose M here. The module
+ 	  will be called igc.
+ 
++config INTEL_M10_BMC_RETIMER
++	tristate "Intel(R) MAX 10 BMC ethernet retimer support"
++	depends on MFD_INTEL_M10_BMC
++	select PHYLIB
++        help
++          This driver supports the ethernet retimer (Parkvale) on
++	  Intel(R) MAX 10 BMC, which is used by Intel PAC N3000 FPGA based
++	  Smart NIC.
++
++	  To compile this driver as a module, choose M here. The module
++	  will be called intel-m10-bmc-retimer.
++
+ endif # NET_VENDOR_INTEL
+diff --git a/drivers/net/ethernet/intel/Makefile b/drivers/net/ethernet/intel/Makefile
+index 3075290063f6..596544703803 100644
+--- a/drivers/net/ethernet/intel/Makefile
++++ b/drivers/net/ethernet/intel/Makefile
+@@ -16,3 +16,5 @@ obj-$(CONFIG_IXGB) += ixgb/
+ obj-$(CONFIG_IAVF) += iavf/
+ obj-$(CONFIG_FM10K) += fm10k/
+ obj-$(CONFIG_ICE) += ice/
++
++obj-$(CONFIG_INTEL_M10_BMC_RETIMER) += intel-m10-bmc-retimer.o
+diff --git a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+new file mode 100644
+index 000000000000..c7b05581e546
+--- /dev/null
++++ b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+@@ -0,0 +1,229 @@
++// SPDX-License-Identifier: GPL-2.0
++/* Intel Max10 BMC Retimer Interface Driver
++ *
++ * Copyright (C) 2018-2020 Intel Corporation. All rights reserved.
++ *
++ */
++#include <linux/device.h>
++#include <linux/mfd/intel-m10-bmc.h>
++#include <linux/module.h>
++#include <linux/phy.h>
++#include <linux/platform_device.h>
++
++#define NUM_CHIP	2
++#define MAX_LINK	4
++
++#define BITS_MASK(nbits)	((1 << (nbits)) - 1)
++
++#define N3000BMC_RETIMER_DEV_NAME "n3000bmc-retimer"
++#define M10BMC_RETIMER_MII_NAME "m10bmc retimer mii"
++
++struct m10bmc_retimer {
++	struct device *dev;
++	struct intel_m10bmc *m10bmc;
++	int num_devs;
++	struct device *base_dev;
++	struct mii_bus *retimer_mii_bus;
++};
++
++#define RETIMER_LINK_STAT_BIT(retimer_id, link_id) \
++	BIT(((retimer_id) << 2) + (link_id))
++
++static u32 retimer_get_link(struct m10bmc_retimer *retimer, int index)
++{
++	unsigned int val;
++
++	if (m10bmc_sys_read(retimer->m10bmc, PKVL_LINK_STATUS, &val)) {
++		dev_err(retimer->dev, "fail to read PKVL_LINK_STATUS\n");
++		return 0;
++	}
++
++	if (val & BIT(index))
++		return 1;
++
++	return 0;
++}
++
++static int m10bmc_retimer_phy_match(struct phy_device *phydev)
++{
++	if (phydev->mdio.bus->name &&
++	    !strcmp(phydev->mdio.bus->name, M10BMC_RETIMER_MII_NAME)) {
++		return 1;
++	}
++
++	return 0;
++}
++
++static int m10bmc_retimer_phy_probe(struct phy_device *phydev)
++{
++	struct m10bmc_retimer *retimer = phydev->mdio.bus->priv;
++
++	phydev->priv = retimer;
++
++	return 0;
++}
++
++static void m10bmc_retimer_phy_remove(struct phy_device *phydev)
++{
++	if (phydev->attached_dev)
++		phy_disconnect(phydev);
++}
++
++static int m10bmc_retimer_read_status(struct phy_device *phydev)
++{
++	struct m10bmc_retimer *retimer = phydev->priv;
++
++	phydev->link = retimer_get_link(retimer, phydev->mdio.addr);
++
++	phydev->duplex = DUPLEX_FULL;
++
++	return 0;
++}
++
++static int m10bmc_retimer_get_features(struct phy_device *phydev)
++{
++	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
++			 phydev->supported);
++	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseSR_Full_BIT,
++			 phydev->supported);
++	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseLR_Full_BIT,
++			 phydev->supported);
++
++	linkmode_set_bit(ETHTOOL_LINK_MODE_25000baseCR_Full_BIT,
++			 phydev->supported);
++	linkmode_set_bit(ETHTOOL_LINK_MODE_25000baseSR_Full_BIT,
++			 phydev->supported);
++
++	linkmode_set_bit(ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT,
++			 phydev->supported);
++	linkmode_set_bit(ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT,
++			 phydev->supported);
++	linkmode_set_bit(ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT,
++			 phydev->supported);
++
++	linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->supported);
++
++	return 0;
++}
++
++static struct phy_driver m10bmc_retimer_phy_driver = {
++	.phy_id			= 0xffffffff,
++	.phy_id_mask		= 0xffffffff,
++	.name			= "m10bmc retimer PHY",
++	.match_phy_device	= m10bmc_retimer_phy_match,
++	.probe			= m10bmc_retimer_phy_probe,
++	.remove			= m10bmc_retimer_phy_remove,
++	.read_status		= m10bmc_retimer_read_status,
++	.get_features		= m10bmc_retimer_get_features,
++	.read_mmd		= genphy_read_mmd_unsupported,
++	.write_mmd		= genphy_write_mmd_unsupported,
++};
++
++static int m10bmc_retimer_read(struct mii_bus *bus, int addr, int regnum)
++{
++	struct m10bmc_retimer *retimer = bus->priv;
++
++	if (addr < retimer->num_devs &&
++	    (regnum == MII_PHYSID1 || regnum == MII_PHYSID2))
++		return 0;
++
++	return 0xffff;
++}
++
++static int m10bmc_retimer_write(struct mii_bus *bus, int addr, int regnum, u16 val)
++{
++	return 0;
++}
++
++static int m10bmc_retimer_mii_bus_init(struct m10bmc_retimer *retimer)
++{
++	struct mii_bus *bus;
++	int ret;
++
++	bus = devm_mdiobus_alloc(retimer->dev);
++	if (!bus)
++		return -ENOMEM;
++
++	bus->priv = (void *)retimer;
++	bus->name = M10BMC_RETIMER_MII_NAME;
++	bus->read = m10bmc_retimer_read;
++	bus->write = m10bmc_retimer_write;
++	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii",
++		 dev_name(retimer->base_dev));
++	bus->parent = retimer->dev;
++	bus->phy_mask = ~(BITS_MASK(retimer->num_devs));
++
++	ret = mdiobus_register(bus);
++	if (ret)
++		return ret;
++
++	retimer->retimer_mii_bus = bus;
++
++	return 0;
++}
++
++static void m10bmc_retimer_mii_bus_uinit(struct m10bmc_retimer *retimer)
++{
++	mdiobus_unregister(retimer->retimer_mii_bus);
++}
++
++static int intel_m10bmc_retimer_probe(struct platform_device *pdev)
++{
++	struct intel_m10bmc_retimer_pdata *pdata = dev_get_platdata(&pdev->dev);
++	struct intel_m10bmc *m10bmc = dev_get_drvdata(pdev->dev.parent);
++	struct m10bmc_retimer *retimer;
++
++	retimer = devm_kzalloc(&pdev->dev, sizeof(*retimer), GFP_KERNEL);
++	if (!retimer)
++		return -ENOMEM;
++
++	dev_set_drvdata(&pdev->dev, retimer);
++
++	retimer->dev = &pdev->dev;
++	retimer->m10bmc = m10bmc;
++	retimer->base_dev = pdata->retimer_master;
++	retimer->num_devs = NUM_CHIP * MAX_LINK;
++
++	return m10bmc_retimer_mii_bus_init(retimer);
++}
++
++static int intel_m10bmc_retimer_remove(struct platform_device *pdev)
++{
++	struct m10bmc_retimer *retimer = dev_get_drvdata(&pdev->dev);
++
++	m10bmc_retimer_mii_bus_uinit(retimer);
++
++	return 0;
++}
++
++static struct platform_driver intel_m10bmc_retimer_driver = {
++	.probe = intel_m10bmc_retimer_probe,
++	.remove = intel_m10bmc_retimer_remove,
++	.driver = {
++		.name = N3000BMC_RETIMER_DEV_NAME,
++	},
++};
++
++static int __init intel_m10bmc_retimer_init(void)
++{
++	int ret;
++
++	ret = phy_driver_register(&m10bmc_retimer_phy_driver, THIS_MODULE);
++	if (ret)
++		return ret;
++
++	return platform_driver_register(&intel_m10bmc_retimer_driver);
++}
++module_init(intel_m10bmc_retimer_init);
++
++static void __exit intel_m10bmc_retimer_exit(void)
++{
++	platform_driver_unregister(&intel_m10bmc_retimer_driver);
++	phy_driver_unregister(&m10bmc_retimer_phy_driver);
++}
++module_exit(intel_m10bmc_retimer_exit);
++
++MODULE_ALIAS("platform:" N3000BMC_RETIMER_DEV_NAME);
++MODULE_AUTHOR("Intel Corporation");
++MODULE_DESCRIPTION("Intel MAX 10 BMC retimer driver");
++MODULE_LICENSE("GPL");
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index c8ef2f1654a4..3d9d22c94ae2 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -21,6 +21,22 @@
+ #define M10BMC_VER_PCB_INFO_MSK		GENMASK(31, 24)
+ #define M10BMC_VER_LEGACY_INVALID	0xffffffff
+ 
++/* PKVL related registers, in system register region */
++#define PKVL_LINK_STATUS		0x164
++
++/**
++ * struct intel_m10bmc_retimer_pdata - subdev retimer platform data
++ *
++ * @retimer_master: the NIC device which connects to the retimers on m10bmc
++ */
++struct intel_m10bmc_retimer_pdata {
++	struct device *retimer_master;
++};
++
++struct intel_m10bmc_platdata {
++	struct intel_m10bmc_retimer_pdata *retimer;
++};
++
+ /**
+  * struct intel_m10bmc - Intel MAX 10 BMC parent driver data structure
+  * @dev: this device
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0014-ethernet-dfl-eth-group-add-DFL-eth-group-private-fea.patch new/debian/patches/fpga-ofs/0014-ethernet-dfl-eth-group-add-DFL-eth-group-private-fea.patch
--- org/debian/patches/fpga-ofs/0014-ethernet-dfl-eth-group-add-DFL-eth-group-private-fea.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0014-ethernet-dfl-eth-group-add-DFL-eth-group-private-fea.patch	2021-07-20 06:17:11.344845038 +0200
@@ -0,0 +1,1411 @@
+From 2bd81b3327c17a65bab1cbd391c8b0c86fe4eb75 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Mon, 23 Mar 2020 15:13:45 +0800
+Subject: [PATCH 014/149] ethernet: dfl-eth-group: add DFL eth group private
+ feature driver
+
+This driver supports the DFL Ether Group private feature for the Intel(R)
+PAC N3000 FPGA Smart NIC.
+
+The DFL Ether Group private feature contains an Ether Wrapper and several
+ports (phy-mac pair). There are two types of Ether Groups, line side &
+host side. These 2 types of Ether Groups, together with FPGA internal
+logic, act as several independent pipes between the host Ethernet
+Controller and the front-panel cages. The FPGA logic between the 2 Ether
+Groups implements user defined mac layer offloading.
+
+The line side ether interfaces connect to the Parkvale serdes transceiver
+chips, which are working in 4 ports 10G/25G retimer mode.
+
+There are several configurations (8x10G, 2x1x25G, 2x2x25G ...) for
+different connections between line side and host side. Not all links are
+active in some configurations.
+
+For the line side link, the driver connects to the Parkvale phy device
+and then register net device for each active link.
+
+For the host side link, its link state is always on. The host side link
+always has same features as host side ether controller, so there is no
+need to register a netdev for it. The driver just enables the link on
+probe.
+
+This patch supports the 25G configurations. Support for 10G will be in
+other patches.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+----
+v2: no change
+v3: Add the Documentation for pause_quanta & holdoff.
+    Some minor fix
+v4: initialize ret local variable
+    check netdev for NULL
+    ensure null termination of edev->phy_id
+    declare static for some functions
+    remove phydev field in struct n3000_net_priv
+    fix kernel warning on driver remove
+v5: It is possible the phy device is removed before net device removal,
+    so add the phy device existence check.
+    Add the description of reg_lock
+---
+ .../ABI/testing/sysfs-class-net-dfl-eth-group |  19 +
+ drivers/net/ethernet/intel/Kconfig            |  18 +
+ drivers/net/ethernet/intel/Makefile           |   2 +
+ .../net/ethernet/intel/dfl-eth-group-25g.c    | 525 +++++++++++++++
+ .../net/ethernet/intel/dfl-eth-group-main.c   | 632 ++++++++++++++++++
+ drivers/net/ethernet/intel/dfl-eth-group.h    |  83 +++
+ .../ethernet/intel/intel-m10-bmc-retimer.c    |   4 +-
+ 7 files changed, 1282 insertions(+), 1 deletion(-)
+ create mode 100644 Documentation/ABI/testing/sysfs-class-net-dfl-eth-group
+ create mode 100644 drivers/net/ethernet/intel/dfl-eth-group-25g.c
+ create mode 100644 drivers/net/ethernet/intel/dfl-eth-group-main.c
+ create mode 100644 drivers/net/ethernet/intel/dfl-eth-group.h
+
+diff --git a/Documentation/ABI/testing/sysfs-class-net-dfl-eth-group b/Documentation/ABI/testing/sysfs-class-net-dfl-eth-group
+new file mode 100644
+index 000000000000..ad528f244a2c
+--- /dev/null
++++ b/Documentation/ABI/testing/sysfs-class-net-dfl-eth-group
+@@ -0,0 +1,19 @@
++What:		/sys/class/net/<iface>/tx_pause_frame_quanta
++Date:		Oct 2020
++KernelVersion:	5.11
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:
++		Read-Write. Value representing the tx pause quanta of Pause
++		flow control frames to be sent to remote partner. Read the file
++		for the actual tx pause quanta value. Write the file to set
++		value of the tx pause quanta.
++
++What:		/sys/class/net/<iface>/tx_pause_frame_holdoff
++Date:		Oct 2020
++KernelVersion:	5.11
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:
++		Read-Write. Value representing the separation between 2
++		consecutive XOFF flow control frames. Read the file for the
++		actual separation value. Write the file to set value of the
++		separation.
+diff --git a/drivers/net/ethernet/intel/Kconfig b/drivers/net/ethernet/intel/Kconfig
+index 81c43d4a0cc5..61b5d91bff74 100644
+--- a/drivers/net/ethernet/intel/Kconfig
++++ b/drivers/net/ethernet/intel/Kconfig
+@@ -343,6 +343,24 @@ config IGC
+ 	  To compile this driver as a module, choose M here. The module
+ 	  will be called igc.
+ 
++config FPGA_DFL_ETH_GROUP
++        tristate "DFL Ether Group private feature support"
++        depends on FPGA_DFL && HAS_IOMEM
++        help
++          This driver supports DFL Ether Group private feature for
++	  Intel(R) PAC N3000 FPGA Smart NIC.
++
++	  The DFL Ether Group private feature contains several ether
++	  interfaces, each of them contains an Ether Wrapper and several
++	  ports (phy-mac pairs). There are two types of interfaces, Line
++	  side & CPU side. These 2 types of interfaces, together with FPGA
++	  internal logic, act as several independent pipes between the
++	  host Ethernet Controller and the front-panel cages. The FPGA
++	  logic between 2 interfaces implements user defined mac layer
++	  offloading.
++
++	  This driver implements each active port as a netdev.
++
+ config INTEL_M10_BMC_RETIMER
+ 	tristate "Intel(R) MAX 10 BMC ethernet retimer support"
+ 	depends on MFD_INTEL_M10_BMC
+diff --git a/drivers/net/ethernet/intel/Makefile b/drivers/net/ethernet/intel/Makefile
+index 596544703803..1624c26e8953 100644
+--- a/drivers/net/ethernet/intel/Makefile
++++ b/drivers/net/ethernet/intel/Makefile
+@@ -17,4 +17,6 @@ obj-$(CONFIG_IAVF) += iavf/
+ obj-$(CONFIG_FM10K) += fm10k/
+ obj-$(CONFIG_ICE) += ice/
+ 
++dfl-eth-group-objs := dfl-eth-group-main.o dfl-eth-group-25g.o
++obj-$(CONFIG_FPGA_DFL_ETH_GROUP) += dfl-eth-group.o
+ obj-$(CONFIG_INTEL_M10_BMC_RETIMER) += intel-m10-bmc-retimer.o
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group-25g.c b/drivers/net/ethernet/intel/dfl-eth-group-25g.c
+new file mode 100644
+index 000000000000..a6903640191f
+--- /dev/null
++++ b/drivers/net/ethernet/intel/dfl-eth-group-25g.c
+@@ -0,0 +1,525 @@
++// SPDX-License-Identifier: GPL-2.0
++/* Driver for 25G Ether Group private feature on Intel PAC (Programmable
++ * Acceleration Card) N3000
++ *
++ * Copyright (C) 2019-2020 Intel Corporation, Inc.
++ *
++ * Authors:
++ *   Wu Hao <hao.wu@intel.com>
++ *   Xu Yilun <yilun.xu@intel.com>
++ */
++#include <linux/netdevice.h>
++
++#include "dfl-eth-group.h"
++
++/* 25G PHY/MAC Register */
++#define PHY_CONFIG	0x310
++#define PHY_MAC_RESET_MASK	GENMASK(2, 0)
++#define PHY_PMA_SLOOP		0x313
++#define MAX_TX_SIZE_CONFIG	0x407
++#define MAX_RX_SIZE_CONFIG	0x506
++#define TX_FLOW_CTRL_EN		0x605
++#define TX_FLOW_CTRL_EN_PAUSE	BIT(0)
++#define TX_FLOW_CTRL_QUANTA	0x620
++#define TX_FLOW_CTRL_HOLDOFF	0x628
++#define TX_FLOW_CTRL_SEL	0x640
++#define TX_FLOW_CTRL_SEL_PAUSE	0x0
++#define TX_FLOW_CTRL_SEL_PFC	0x1
++
++static int edev25g40g_reset(struct eth_dev *edev, bool en)
++{
++	struct eth_com *mac = edev->mac;
++	struct device *dev = edev->dev;
++	u32 val;
++	int ret;
++
++	ret = eth_com_read_reg(mac, PHY_CONFIG, &val);
++	if (ret) {
++		dev_err(dev, "fail to read PHY_CONFIG: %d\n", ret);
++		return ret;
++	}
++
++	/* skip if config is in expected state already */
++	if ((((val & PHY_MAC_RESET_MASK) == PHY_MAC_RESET_MASK) && en) ||
++	    (((val & PHY_MAC_RESET_MASK) == 0) && !en))
++		return 0;
++
++	if (en)
++		val |= PHY_MAC_RESET_MASK;
++	else
++		val &= ~PHY_MAC_RESET_MASK;
++
++	ret = eth_com_write_reg(mac, PHY_CONFIG, val);
++	if (ret)
++		dev_err(dev, "fail to write PHY_CONFIG: %d\n", ret);
++
++	return ret;
++}
++
++static ssize_t tx_pause_frame_quanta_show(struct device *d,
++					  struct device_attribute *attr,
++					  char *buf)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(to_net_dev(d));
++	u32 data;
++	int ret;
++
++	ret = eth_com_read_reg(edev->mac, TX_FLOW_CTRL_QUANTA, &data);
++
++	return ret ? : sprintf(buf, "0x%x\n", data);
++}
++
++static ssize_t tx_pause_frame_quanta_store(struct device *d,
++					   struct device_attribute *attr,
++					   const char *buf, size_t len)
++{
++	struct net_device *netdev = to_net_dev(d);
++	struct eth_dev *edev;
++	u32 data;
++	int ret;
++
++	if (kstrtou32(buf, 0, &data))
++		return -EINVAL;
++
++	edev = net_device_to_eth_dev(netdev);
++
++	rtnl_lock();
++
++	if (netif_running(netdev)) {
++		netdev_err(netdev, "must be stopped to change pause param\n");
++		ret = -EBUSY;
++		goto out;
++	}
++
++	ret = eth_com_write_reg(edev->mac, TX_FLOW_CTRL_QUANTA, data);
++
++out:
++	rtnl_unlock();
++
++	return ret ? : len;
++}
++static DEVICE_ATTR_RW(tx_pause_frame_quanta);
++
++static ssize_t tx_pause_frame_holdoff_show(struct device *d,
++					   struct device_attribute *attr,
++					   char *buf)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(to_net_dev(d));
++	u32 data;
++	int ret;
++
++	ret = eth_com_read_reg(edev->mac, TX_FLOW_CTRL_HOLDOFF, &data);
++
++	return ret ? : sprintf(buf, "0x%x\n", data);
++}
++
++static ssize_t tx_pause_frame_holdoff_store(struct device *d,
++					    struct device_attribute *attr,
++					    const char *buf, size_t len)
++{
++	struct net_device *netdev = to_net_dev(d);
++	struct eth_dev *edev;
++	u32 data;
++	int ret;
++
++	if (kstrtou32(buf, 0, &data))
++		return -EINVAL;
++
++	edev = net_device_to_eth_dev(netdev);
++
++	rtnl_lock();
++
++	if (netif_running(netdev)) {
++		netdev_err(netdev, "must be stopped to change pause param\n");
++		ret = -EBUSY;
++		goto out;
++	}
++
++	ret = eth_com_write_reg(edev->mac, TX_FLOW_CTRL_HOLDOFF, data);
++
++out:
++	rtnl_unlock();
++
++	return ret ? : len;
++}
++static DEVICE_ATTR_RW(tx_pause_frame_holdoff);
++
++static struct attribute *edev25g_dev_attrs[] = {
++	&dev_attr_tx_pause_frame_quanta.attr,
++	&dev_attr_tx_pause_frame_holdoff.attr,
++	NULL
++};
++
++/* device attributes */
++static const struct attribute_group edev25g_attr_group = {
++	.attrs = edev25g_dev_attrs,
++};
++
++/* ethtool ops */
++static struct stat_info stats_25g[] = {
++	/* TX Statistics */
++	{STAT_INFO(0x800, "tx_fragments")},
++	{STAT_INFO(0x802, "tx_jabbers")},
++	{STAT_INFO(0x804, "tx_fcs")},
++	{STAT_INFO(0x806, "tx_crc_err")},
++	{STAT_INFO(0x808, "tx_mcast_data_err")},
++	{STAT_INFO(0x80a, "tx_bcast_data_err")},
++	{STAT_INFO(0x80c, "tx_ucast_data_err")},
++	{STAT_INFO(0x80e, "tx_mcast_ctrl_err")},
++	{STAT_INFO(0x810, "tx_bcast_ctrl_err")},
++	{STAT_INFO(0x812, "tx_ucast_ctrl_err")},
++	{STAT_INFO(0x814, "tx_pause_err")},
++	{STAT_INFO(0x816, "tx_64_byte")},
++	{STAT_INFO(0x818, "tx_65_127_byte")},
++	{STAT_INFO(0x81a, "tx_128_255_byte")},
++	{STAT_INFO(0x81c, "tx_256_511_byte")},
++	{STAT_INFO(0x81e, "tx_512_1023_byte")},
++	{STAT_INFO(0x820, "tx_1024_1518_byte")},
++	{STAT_INFO(0x822, "tx_1519_max_byte")},
++	{STAT_INFO(0x824, "tx_oversize")},
++	{STAT_INFO(0x826, "tx_mcast_data_ok")},
++	{STAT_INFO(0x828, "tx_bcast_data_ok")},
++	{STAT_INFO(0x82a, "tx_ucast_data_ok")},
++	{STAT_INFO(0x82c, "tx_mcast_ctrl_ok")},
++	{STAT_INFO(0x82e, "tx_bcast_ctrl_ok")},
++	{STAT_INFO(0x830, "tx_ucast_ctrl_ok")},
++	{STAT_INFO(0x832, "tx_pause")},
++	{STAT_INFO(0x834, "tx_runt")},
++	{STAT_INFO(0x860, "tx_payload_octets_ok")},
++	{STAT_INFO(0x862, "tx_frame_octets_ok")},
++
++	/* RX Statistics */
++	{STAT_INFO(0x900, "rx_fragments")},
++	{STAT_INFO(0x902, "rx_jabbers")},
++	{STAT_INFO(0x904, "rx_fcs")},
++	{STAT_INFO(0x906, "rx_crc_err")},
++	{STAT_INFO(0x908, "rx_mcast_data_err")},
++	{STAT_INFO(0x90a, "rx_bcast_data_err")},
++	{STAT_INFO(0x90c, "rx_ucast_data_err")},
++	{STAT_INFO(0x90e, "rx_mcast_ctrl_err")},
++	{STAT_INFO(0x910, "rx_bcast_ctrl_err")},
++	{STAT_INFO(0x912, "rx_ucast_ctrl_err")},
++	{STAT_INFO(0x914, "rx_pause_err")},
++	{STAT_INFO(0x916, "rx_64_byte")},
++	{STAT_INFO(0x918, "rx_65_127_byte")},
++	{STAT_INFO(0x91a, "rx_128_255_byte")},
++	{STAT_INFO(0x91c, "rx_256_511_byte")},
++	{STAT_INFO(0x91e, "rx_512_1023_byte")},
++	{STAT_INFO(0x920, "rx_1024_1518_byte")},
++	{STAT_INFO(0x922, "rx_1519_max_byte")},
++	{STAT_INFO(0x924, "rx_oversize")},
++	{STAT_INFO(0x926, "rx_mcast_data_ok")},
++	{STAT_INFO(0x928, "rx_bcast_data_ok")},
++	{STAT_INFO(0x92a, "rx_ucast_data_ok")},
++	{STAT_INFO(0x92c, "rx_mcast_ctrl_ok")},
++	{STAT_INFO(0x92e, "rx_bcast_ctrl_ok")},
++	{STAT_INFO(0x930, "rx_ucast_ctrl_ok")},
++	{STAT_INFO(0x932, "rx_pause")},
++	{STAT_INFO(0x934, "rx_runt")},
++	{STAT_INFO(0x960, "rx_payload_octets_ok")},
++	{STAT_INFO(0x962, "rx_frame_octets_ok")},
++};
++
++static void edev25g_get_strings(struct net_device *netdev, u32 stringset, u8 *s)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	unsigned int i;
++
++	if (stringset != ETH_SS_STATS || edev->lw_mac)
++		return;
++
++	for (i = 0; i < ARRAY_SIZE(stats_25g); i++, s += ETH_GSTRING_LEN)
++		memcpy(s, stats_25g[i].string, ETH_GSTRING_LEN);
++}
++
++static int edev25g_get_sset_count(struct net_device *netdev, int stringset)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++
++	if (stringset != ETH_SS_STATS || edev->lw_mac)
++		return -EOPNOTSUPP;
++
++	return (int)ARRAY_SIZE(stats_25g);
++}
++
++static void edev25g_get_stats(struct net_device *netdev,
++			      struct ethtool_stats *stats, u64 *data)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	unsigned int i;
++
++	if (edev->lw_mac || !netif_running(netdev))
++		return;
++
++	for (i = 0; i < ARRAY_SIZE(stats_25g); i++)
++		data[i] = read_mac_stats(edev->mac, stats_25g[i].addr);
++}
++
++static int edev25g_get_link_ksettings(struct net_device *netdev,
++				      struct ethtool_link_ksettings *cmd)
++{
++	if (!netdev->phydev)
++		return -ENODEV;
++
++	phy_ethtool_ksettings_get(netdev->phydev, cmd);
++
++	return 0;
++}
++
++static int edev25g_pause_init(struct net_device *netdev)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++
++	return eth_com_write_reg(edev->mac, TX_FLOW_CTRL_SEL,
++				 TX_FLOW_CTRL_SEL_PAUSE);
++}
++
++static void edev25g_get_pauseparam(struct net_device *netdev,
++				   struct ethtool_pauseparam *pause)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	u32 data;
++	int ret;
++
++	pause->autoneg = 0;
++	pause->rx_pause = 0;
++
++	ret = eth_com_read_reg(edev->mac, TX_FLOW_CTRL_EN, &data);
++	if (ret) {
++		pause->tx_pause = 0;
++		return;
++	}
++
++	pause->tx_pause = (data & TX_FLOW_CTRL_EN_PAUSE) ? 0x1 : 0;
++}
++
++static int edev25g_set_pauseparam(struct net_device *netdev,
++				  struct ethtool_pauseparam *pause)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	bool enable = pause->tx_pause;
++
++	if (pause->autoneg || pause->rx_pause)
++		return -EOPNOTSUPP;
++
++	return eth_com_write_reg(edev->mac, TX_FLOW_CTRL_EN,
++				 enable ? TX_FLOW_CTRL_EN_PAUSE : 0);
++}
++
++static const struct ethtool_ops edev25g_ethtool_ops = {
++	.get_link = ethtool_op_get_link,
++	.get_strings = edev25g_get_strings,
++	.get_sset_count = edev25g_get_sset_count,
++	.get_ethtool_stats = edev25g_get_stats,
++	.get_link_ksettings = edev25g_get_link_ksettings,
++	.get_pauseparam = edev25g_get_pauseparam,
++	.set_pauseparam = edev25g_set_pauseparam,
++};
++
++/* netdev ops */
++static int edev25g_netdev_open(struct net_device *netdev)
++{
++	struct n3000_net_priv *priv = netdev_priv(netdev);
++	struct eth_dev *edev = priv->edev;
++	int ret;
++
++	ret = edev25g40g_reset(edev, false);
++	if (ret)
++		return ret;
++
++	if (netdev->phydev)
++		phy_start(netdev->phydev);
++
++	return 0;
++}
++
++static int edev25g_netdev_stop(struct net_device *netdev)
++{
++	struct n3000_net_priv *priv = netdev_priv(netdev);
++	struct eth_dev *edev = priv->edev;
++	int ret;
++
++	ret = edev25g40g_reset(edev, true);
++	if (ret)
++		return ret;
++
++	if (netdev->phydev)
++		phy_stop(netdev->phydev);
++
++	return 0;
++}
++
++static int edev25g_mtu_init(struct net_device *netdev)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	struct eth_com *mac = edev->mac;
++	u32 tx = 0, rx = 0, mtu;
++	int ret;
++
++	ret = eth_com_read_reg(mac, MAX_TX_SIZE_CONFIG, &tx);
++	if (ret)
++		return ret;
++
++	ret = eth_com_read_reg(mac, MAX_RX_SIZE_CONFIG, &rx);
++	if (ret)
++		return ret;
++
++	mtu = min(min(tx, rx), netdev->max_mtu);
++
++	ret = eth_com_write_reg(mac, MAX_TX_SIZE_CONFIG, rx);
++	if (ret)
++		return ret;
++
++	ret = eth_com_write_reg(mac, MAX_RX_SIZE_CONFIG, tx);
++	if (ret)
++		return ret;
++
++	netdev->mtu = mtu;
++
++	return 0;
++}
++
++static int edev25g_change_mtu(struct net_device *netdev, int new_mtu)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	struct eth_com *mac = edev->mac;
++	int ret;
++
++	ret = eth_com_write_reg(mac, MAX_TX_SIZE_CONFIG, new_mtu);
++	if (ret)
++		return ret;
++
++	ret = eth_com_write_reg(mac, MAX_RX_SIZE_CONFIG, new_mtu);
++	if (ret)
++		return ret;
++
++	netdev->mtu = new_mtu;
++
++	return 0;
++}
++
++static int edev25g_set_loopback(struct net_device *netdev, bool en)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++
++	return eth_com_write_reg(edev->mac, PHY_PMA_SLOOP, en);
++}
++
++static int edev25g_set_features(struct net_device *netdev,
++				netdev_features_t features)
++{
++	netdev_features_t changed = netdev->features ^ features;
++
++	if (changed & NETIF_F_LOOPBACK)
++		return edev25g_set_loopback(netdev,
++					    !!(features & NETIF_F_LOOPBACK));
++
++	return 0;
++}
++
++static const struct net_device_ops edev25g_netdev_ops = {
++	.ndo_open = edev25g_netdev_open,
++	.ndo_stop = edev25g_netdev_stop,
++	.ndo_change_mtu = edev25g_change_mtu,
++	.ndo_set_features = edev25g_set_features,
++	.ndo_start_xmit = n3000_dummy_netdev_xmit,
++};
++
++static void edev25g_adjust_link(struct net_device *netdev)
++{}
++
++static int edev25g_netdev_init(struct net_device *netdev)
++{
++	int ret;
++
++	ret = edev25g_pause_init(netdev);
++	if (ret)
++		return ret;
++
++	ret = edev25g_mtu_init(netdev);
++	if (ret)
++		return ret;
++
++	return edev25g_set_loopback(netdev,
++				    !!(netdev->features & NETIF_F_LOOPBACK));
++}
++
++static int dfl_eth_dev_25g_init(struct eth_dev *edev)
++{
++	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
++	struct device *dev = edev->dev;
++	struct phy_device *phydev;
++	struct net_device *netdev;
++	int ret;
++
++	netdev = n3000_netdev_create(edev);
++	if (!netdev)
++		return -ENOMEM;
++
++	netdev->hw_features |= NETIF_F_LOOPBACK;
++	netdev->netdev_ops = &edev25g_netdev_ops;
++	netdev->ethtool_ops = &edev25g_ethtool_ops;
++
++	phydev = phy_connect(netdev, edev->phy_id, edev25g_adjust_link,
++			     PHY_INTERFACE_MODE_NA);
++	if (IS_ERR(phydev)) {
++		dev_err(dev, "PHY connection failed\n");
++		ret = PTR_ERR(phydev);
++		goto err_free_netdev;
++	}
++
++	linkmode_set_bit(ETHTOOL_LINK_MODE_25000baseCR_Full_BIT, mask);
++	linkmode_set_bit(ETHTOOL_LINK_MODE_25000baseSR_Full_BIT, mask);
++	linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, mask);
++	linkmode_and(phydev->supported, phydev->supported, mask);
++	linkmode_copy(phydev->advertising, phydev->supported);
++
++	phy_attached_info(phydev);
++
++	ret = edev25g_netdev_init(netdev);
++	if (ret) {
++		dev_err(dev, "fail to init netdev %s\n", netdev->name);
++		goto err_phy_disconnect;
++	}
++
++	netdev->sysfs_groups[0] = &edev25g_attr_group;
++
++	netif_carrier_off(netdev);
++	ret = register_netdev(netdev);
++	if (ret) {
++		dev_err(dev, "fail to register netdev %s\n", netdev->name);
++		goto err_phy_disconnect;
++	}
++
++	edev->netdev = netdev;
++
++	return 0;
++
++err_phy_disconnect:
++	if (netdev->phydev)
++		phy_disconnect(phydev);
++err_free_netdev:
++	free_netdev(netdev);
++
++	return ret;
++}
++
++static void dfl_eth_dev_25g_remove(struct eth_dev *edev)
++{
++	struct net_device *netdev = edev->netdev;
++
++	if (netdev->phydev)
++		phy_disconnect(netdev->phydev);
++
++	unregister_netdev(netdev);
++}
++
++struct eth_dev_ops dfl_eth_dev_25g_ops = {
++	.lineside_init = dfl_eth_dev_25g_init,
++	.lineside_remove = dfl_eth_dev_25g_remove,
++	.reset = edev25g40g_reset,
++};
++
++struct eth_dev_ops dfl_eth_dev_40g_ops = {
++	.reset = edev25g40g_reset,
++};
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group-main.c b/drivers/net/ethernet/intel/dfl-eth-group-main.c
+new file mode 100644
+index 000000000000..a29b8b16bdbf
+--- /dev/null
++++ b/drivers/net/ethernet/intel/dfl-eth-group-main.c
+@@ -0,0 +1,632 @@
++// SPDX-License-Identifier: GPL-2.0
++/* DFL device driver for Ether Group private feature on Intel PAC (Programmable
++ * Acceleration Card) N3000
++ *
++ * Copyright (C) 2019-2020 Intel Corporation, Inc.
++ *
++ * Authors:
++ *   Wu Hao <hao.wu@intel.com>
++ *   Xu Yilun <yilun.xu@intel.com>
++ */
++#include <linux/bitfield.h>
++#include <linux/dfl.h>
++#include <linux/errno.h>
++#include <linux/ethtool.h>
++#include <linux/io.h>
++#include <linux/iopoll.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/netdevice.h>
++#include <linux/rtnetlink.h>
++#include <linux/stddef.h>
++#include <linux/types.h>
++
++#include "dfl-eth-group.h"
++
++struct dfl_eth_group {
++	char name[32];
++	struct device *dev;
++	void __iomem *base;
++	/* lock to protect register access of the ether group */
++	struct mutex reg_lock;
++	struct dfl_device *dfl_dev;
++	unsigned int config;
++	unsigned int direction;
++	unsigned int group_id;
++	unsigned int speed;
++	unsigned int lw_mac;
++	unsigned int num_edevs;
++	struct eth_dev *edevs;
++	struct eth_dev_ops *ops;
++};
++
++u64 read_mac_stats(struct eth_com *ecom, unsigned int addr)
++{
++	u32 data_l, data_h;
++
++	if (eth_com_read_reg(ecom, addr, &data_l) ||
++	    eth_com_read_reg(ecom, addr + 1, &data_h))
++		return 0xffffffffffffffffULL;
++
++	return data_l + ((u64)data_h << 32);
++}
++
++netdev_tx_t n3000_dummy_netdev_xmit(struct sk_buff *skb,
++				    struct net_device *dev)
++{
++	kfree_skb(skb);
++	net_warn_ratelimited("%s(): Dropping skb.\n", __func__);
++	return NETDEV_TX_OK;
++}
++
++static void n3000_netdev_setup(struct net_device *netdev)
++{
++	netdev->features = 0;
++	netdev->hard_header_len = 0;
++	netdev->priv_flags |= IFF_NO_QUEUE;
++	netdev->needs_free_netdev = true;
++	netdev->min_mtu = 0;
++	netdev->max_mtu = ETH_MAX_MTU;
++}
++
++struct net_device *n3000_netdev_create(struct eth_dev *edev)
++{
++	struct dfl_eth_group *egroup = edev->egroup;
++	struct n3000_net_priv *priv;
++	struct net_device *netdev;
++	char name[IFNAMSIZ];
++
++	/* The name of n3000 network device is using this format "npacAgBlC"
++	 *
++	 * A is the unique ethdev index
++	 * B is the group id of this ETH Group.
++	 * C is the PHY/MAC link index for Line side ethernet group.
++	 */
++	snprintf(name, IFNAMSIZ, "npac%%dg%ul%u",
++		 egroup->group_id, edev->index);
++
++	netdev = alloc_netdev(sizeof(*priv), name, NET_NAME_UNKNOWN,
++			      n3000_netdev_setup);
++	if (!netdev)
++		return NULL;
++
++	priv = netdev_priv(netdev);
++	priv->edev = edev;
++	SET_NETDEV_DEV(netdev, egroup->dev);
++
++	return netdev;
++}
++
++enum n3000_eth_cfg {
++	ETH_CONFIG_8x10G,
++	ETH_CONFIG_4x25G,
++	ETH_CONFIG_2x1x25G,
++	ETH_CONFIG_4x25G_2x25G,
++	ETH_CONFIG_2x2x25G,
++	ETH_CONFIG_MAX
++};
++
++#define N3000_EDEV_MAX 8
++
++static int phy_addr_table[ETH_CONFIG_MAX][N3000_EDEV_MAX] = {
++	/* 8x10G configuration
++	 *
++	 *    [retimer_dev]   <------->   [eth_dev]
++	 *	  0			   0
++	 *	  1			   1
++	 *	  2			   2
++	 *	  3			   3
++	 *	  4			   4
++	 *	  5			   5
++	 *	  6			   6
++	 *	  7			   7
++	 */
++	[ETH_CONFIG_8x10G] = {0, 1, 2, 3, 4, 5, 6, 7},
++
++	/* 4x25G and 4x25G_2x25G configuration
++	 *
++	 *    [retimer_dev]   <------->   [eth_dev]
++	 *	  0			   0
++	 *	  1			   1
++	 *	  2			   2
++	 *	  3			   3
++	 *	  4
++	 *	  5
++	 *	  6
++	 *	  7
++	 */
++	[ETH_CONFIG_4x25G] = {0, 1, 2, 3, -1, -1, -1, -1},
++	[ETH_CONFIG_4x25G_2x25G] = {0, 1, 2, 3, -1, -1, -1, -1},
++
++	/* 2x1x25G configuration
++	 *
++	 *    [retimer_dev]   <------->   [eth_dev]
++	 *        0                      0
++	 *        1
++	 *        2
++	 *        3
++	 *        4                      1
++	 *        5
++	 *        6
++	 *        7
++	 */
++	[ETH_CONFIG_2x1x25G] = {0, 4, -1, -1, -1, -1, -1, -1},
++
++	/* 2x2x25G configuration
++	 *
++	 *    [retimer_dev]   <------->   [eth_dev]
++	 *	  0			   0
++	 *	  1			   1
++	 *	  2
++	 *	  3
++	 *	  4			   2
++	 *	  5			   3
++	 *	  6
++	 *	  7
++	 */
++	[ETH_CONFIG_2x2x25G] = {0, 1, 4, 5, -1, -1, -1, -1},
++};
++
++#define eth_group_for_each_dev(edev, egp) \
++	for ((edev) = (egp)->edevs; (edev) < (egp)->edevs + (egp)->num_edevs; \
++	     (edev)++)
++
++#define eth_group_reverse_each_dev(edev, egp) \
++	for ((edev)--; (edev) >= (egp)->edevs; (edev)--)
++
++static struct mii_bus *eth_group_get_phy_bus(struct dfl_eth_group *egroup)
++{
++	char mii_name[MII_BUS_ID_SIZE];
++	struct device *base_dev;
++	struct mii_bus *bus;
++
++	base_dev = dfl_dev_get_base_dev(egroup->dfl_dev);
++	if (!base_dev)
++		return ERR_PTR(-ENODEV);
++
++	snprintf(mii_name, MII_BUS_ID_SIZE, DFL_ETH_MII_ID_FMT,
++		 dev_name(base_dev));
++
++	bus = mdio_find_bus(mii_name);
++	if (!bus)
++		return ERR_PTR(-EPROBE_DEFER);
++
++	return bus;
++}
++
++static int eth_dev_get_phy_id(struct eth_dev *edev, struct mii_bus *bus)
++{
++	struct dfl_eth_group *egroup = edev->egroup;
++	struct phy_device *phydev;
++	int phyaddr;
++
++	phyaddr = phy_addr_table[egroup->config][edev->index];
++	if (phyaddr < 0)
++		return -ENODEV;
++
++	phydev = mdiobus_get_phy(bus, phyaddr);
++	if (!phydev) {
++		dev_err(egroup->dev, "fail to get phydev\n");
++		return -EPROBE_DEFER;
++	}
++
++	strncpy(edev->phy_id, phydev_name(phydev), MII_BUS_ID_SIZE + 3);
++	edev->phy_id[MII_BUS_ID_SIZE + 2] = '\0';
++
++	return 0;
++}
++
++static int init_lineside_eth_devs(struct dfl_eth_group *egroup,
++				  struct mii_bus *phy_bus)
++{
++	struct eth_dev *edev;
++	int ret = 0;
++
++	if (!egroup->ops->lineside_init)
++		return -ENODEV;
++
++	eth_group_for_each_dev(edev, egroup) {
++		ret = eth_dev_get_phy_id(edev, phy_bus);
++		if (ret)
++			break;
++
++		ret = egroup->ops->lineside_init(edev);
++		if (ret)
++			break;
++	}
++
++	if (!ret)
++		return 0;
++
++	dev_err(egroup->dev, "failed to init lineside edev %d", edev->index);
++
++	if (egroup->ops->lineside_remove)
++		eth_group_reverse_each_dev(edev, egroup)
++			egroup->ops->lineside_remove(edev);
++
++	return ret;
++}
++
++static void remove_lineside_eth_devs(struct dfl_eth_group *egroup)
++{
++	struct eth_dev *edev;
++
++	if (!egroup->ops->lineside_remove)
++		return;
++
++	eth_group_for_each_dev(edev, egroup)
++		egroup->ops->lineside_remove(edev);
++}
++
++#define ETH_GROUP_INFO		0x8
++#define LIGHT_WEIGHT_MAC	BIT_ULL(25)
++#define INFO_DIRECTION		BIT_ULL(24)
++#define INFO_SPEED		GENMASK_ULL(23, 16)
++#define INFO_PHY_NUM		GENMASK_ULL(15, 8)
++#define INFO_GROUP_ID		GENMASK_ULL(7, 0)
++
++#define ETH_GROUP_CTRL		0x10
++#define CTRL_CMD		GENMASK_ULL(63, 62)
++#define CMD_NOP			0
++#define CMD_RD			1
++#define CMD_WR			2
++#define CTRL_DEV_SELECT		GENMASK_ULL(53, 49)
++#define CTRL_FEAT_SELECT	BIT_ULL(48)
++#define SELECT_IP		0
++#define SELECT_FEAT		1
++#define CTRL_ADDR		GENMASK_ULL(47, 32)
++#define CTRL_WR_DATA		GENMASK_ULL(31, 0)
++
++#define ETH_GROUP_STAT		0x18
++#define STAT_RW_VAL		BIT_ULL(32)
++#define STAT_RD_DATA		GENMASK_ULL(31, 0)
++
++enum ecom_type {
++	ETH_GROUP_PHY	= 1,
++	ETH_GROUP_MAC,
++	ETH_GROUP_ETHER
++};
++
++struct eth_com {
++	struct dfl_eth_group *egroup;
++	unsigned int type;
++	u8 select;
++};
++
++static const char *eth_com_type_string(enum ecom_type type)
++{
++	switch (type) {
++	case ETH_GROUP_PHY:
++		return "phy";
++	case ETH_GROUP_MAC:
++		return "mac";
++	case ETH_GROUP_ETHER:
++		return "ethernet wrapper";
++	default:
++		return "unknown";
++	}
++}
++
++#define eth_com_base(com)	((com)->egroup->base)
++#define eth_com_dev(com)	((com)->egroup->dev)
++
++#define RW_VAL_INVL		1 /* us */
++#define RW_VAL_POLL_TIMEOUT	10 /* us */
++
++static int __do_eth_com_write_reg(struct eth_com *ecom, bool add_feature,
++				  u16 addr, u32 data)
++{
++	void __iomem *base = eth_com_base(ecom);
++	struct device *dev = eth_com_dev(ecom);
++	u64 v = 0;
++
++	dev_dbg(dev, "%s [%s] select 0x%x add_feat %d addr 0x%x data 0x%x\n",
++		__func__, eth_com_type_string(ecom->type),
++		ecom->select, add_feature, addr, data);
++
++	/* only PHY has additional feature registers */
++	if (add_feature && ecom->type != ETH_GROUP_PHY)
++		return -EINVAL;
++
++	v |= FIELD_PREP(CTRL_CMD, CMD_WR);
++	v |= FIELD_PREP(CTRL_DEV_SELECT, ecom->select);
++	v |= FIELD_PREP(CTRL_ADDR, addr);
++	v |= FIELD_PREP(CTRL_WR_DATA, data);
++	v |= FIELD_PREP(CTRL_FEAT_SELECT, !!add_feature);
++
++	writeq(v, base + ETH_GROUP_CTRL);
++
++	if (readq_poll_timeout(base + ETH_GROUP_STAT, v, v & STAT_RW_VAL,
++			       RW_VAL_INVL, RW_VAL_POLL_TIMEOUT))
++		return -ETIMEDOUT;
++
++	return 0;
++}
++
++static int __do_eth_com_read_reg(struct eth_com *ecom, bool add_feature,
++				 u16 addr, u32 *data)
++{
++	void __iomem *base = eth_com_base(ecom);
++	struct device *dev = eth_com_dev(ecom);
++	u64 v = 0;
++
++	dev_dbg(dev, "%s [%s] select %x add_feat %d addr %x\n",
++		__func__, eth_com_type_string(ecom->type),
++		ecom->select, add_feature, addr);
++
++	/* only PHY has additional feature registers */
++	if (add_feature && ecom->type != ETH_GROUP_PHY)
++		return -EINVAL;
++
++	v |= FIELD_PREP(CTRL_CMD, CMD_RD);
++	v |= FIELD_PREP(CTRL_DEV_SELECT, ecom->select);
++	v |= FIELD_PREP(CTRL_ADDR, addr);
++	v |= FIELD_PREP(CTRL_FEAT_SELECT, !!add_feature);
++
++	writeq(v, base + ETH_GROUP_CTRL);
++
++	if (readq_poll_timeout(base + ETH_GROUP_STAT, v, v & STAT_RW_VAL,
++			       RW_VAL_INVL, RW_VAL_POLL_TIMEOUT))
++		return -ETIMEDOUT;
++
++	*data = FIELD_GET(STAT_RD_DATA, v);
++
++	return 0;
++}
++
++int do_eth_com_write_reg(struct eth_com *ecom, bool add_feature,
++			 u16 addr, u32 data)
++{
++	int ret;
++
++	mutex_lock(&ecom->egroup->reg_lock);
++	ret = __do_eth_com_write_reg(ecom, add_feature, addr, data);
++	mutex_unlock(&ecom->egroup->reg_lock);
++	return ret;
++}
++
++int do_eth_com_read_reg(struct eth_com *ecom, bool add_feature,
++			u16 addr, u32 *data)
++{
++	int ret;
++
++	mutex_lock(&ecom->egroup->reg_lock);
++	ret = __do_eth_com_read_reg(ecom, add_feature, addr, data);
++	mutex_unlock(&ecom->egroup->reg_lock);
++	return ret;
++}
++
++static struct eth_com *
++eth_com_create(struct dfl_eth_group *egroup, enum ecom_type type,
++	       unsigned int link_idx)
++{
++	struct eth_com *ecom;
++
++	ecom = devm_kzalloc(egroup->dev, sizeof(*ecom), GFP_KERNEL);
++	if (!ecom)
++		return ERR_PTR(-ENOMEM);
++
++	ecom->egroup = egroup;
++	ecom->type = type;
++
++	if (type == ETH_GROUP_PHY)
++		ecom->select = link_idx * 2 + 2;
++	else if (type == ETH_GROUP_MAC)
++		ecom->select = link_idx * 2 + 3;
++	else if (type == ETH_GROUP_ETHER)
++		ecom->select = 0;
++
++	return ecom;
++}
++
++static int init_eth_dev(struct eth_dev *edev, struct dfl_eth_group *egroup,
++			unsigned int link_idx)
++{
++	edev->egroup = egroup;
++	edev->dev = egroup->dev;
++	edev->index = link_idx;
++	edev->lw_mac = !!egroup->lw_mac;
++	edev->phy = eth_com_create(egroup, ETH_GROUP_PHY, link_idx);
++	if (IS_ERR(edev->phy))
++		return PTR_ERR(edev->phy);
++
++	edev->mac = eth_com_create(egroup, ETH_GROUP_MAC, link_idx);
++	if (IS_ERR(edev->mac))
++		return PTR_ERR(edev->mac);
++
++	return 0;
++}
++
++static int eth_devs_init(struct dfl_eth_group *egroup)
++{
++	int ret, i;
++
++	egroup->edevs = devm_kcalloc(egroup->dev, egroup->num_edevs,
++				     sizeof(*egroup->edevs), GFP_KERNEL);
++	if (!egroup->edevs)
++		return -ENOMEM;
++
++	for (i = 0; i < egroup->num_edevs; i++) {
++		ret = init_eth_dev(&egroup->edevs[i], egroup, i);
++		if (ret)
++			return ret;
++	}
++
++	return 0;
++}
++
++static int eth_group_setup(struct dfl_eth_group *egroup)
++{
++	int net_cfg, ret;
++	u64 v;
++
++	/* read parameters of this ethernet components group */
++	v = readq(egroup->base + ETH_GROUP_INFO);
++
++	egroup->direction = FIELD_GET(INFO_DIRECTION, v);
++	egroup->speed = FIELD_GET(INFO_SPEED, v);
++	egroup->num_edevs = FIELD_GET(INFO_PHY_NUM, v);
++	egroup->group_id = FIELD_GET(INFO_GROUP_ID, v);
++	egroup->lw_mac = FIELD_GET(LIGHT_WEIGHT_MAC, v);
++
++	net_cfg = dfl_dev_get_vendor_net_cfg(egroup->dfl_dev);
++	if (net_cfg < 0)
++		return -EINVAL;
++
++	egroup->config = (unsigned int)net_cfg;
++
++	ret = eth_devs_init(egroup);
++	if (ret)
++		return ret;
++
++	switch (egroup->speed) {
++	case 25:
++		egroup->ops = &dfl_eth_dev_25g_ops;
++		break;
++	case 40:
++		egroup->ops = &dfl_eth_dev_40g_ops;
++		break;
++	}
++
++	mutex_init(&egroup->reg_lock);
++
++	return 0;
++}
++
++static void eth_group_destroy(struct dfl_eth_group *egroup)
++{
++	mutex_destroy(&egroup->reg_lock);
++}
++
++static void eth_group_devs_disable(struct dfl_eth_group *egroup)
++{
++	struct eth_dev *edev;
++
++	eth_group_for_each_dev(edev, egroup)
++		egroup->ops->reset(edev, true);
++}
++
++static int eth_group_devs_enable(struct dfl_eth_group *egroup)
++{
++	struct eth_dev *edev;
++	int ret;
++
++	eth_group_for_each_dev(edev, egroup) {
++		ret = egroup->ops->reset(edev, false);
++		if (ret) {
++			dev_err(egroup->dev, "fail to enable edev%d\n",
++				edev->index);
++			eth_group_devs_disable(egroup);
++			return ret;
++		}
++	}
++
++	return 0;
++}
++
++static int dfl_eth_group_line_side_init(struct dfl_eth_group *egroup)
++{
++	struct mii_bus *phy_bus;
++	int ret;
++
++	if (!egroup->ops || !egroup->ops->reset ||
++	    !egroup->ops->lineside_init || !egroup->ops->lineside_remove)
++		return -EINVAL;
++
++	eth_group_devs_disable(egroup);
++
++	phy_bus = eth_group_get_phy_bus(egroup);
++	if (IS_ERR(phy_bus))
++		return PTR_ERR(phy_bus);
++
++	ret = init_lineside_eth_devs(egroup, phy_bus);
++	put_device(&phy_bus->dev);
++
++	return ret;
++}
++
++static void dfl_eth_group_line_side_uinit(struct dfl_eth_group *egroup)
++{
++	remove_lineside_eth_devs(egroup);
++}
++
++static int dfl_eth_group_host_side_init(struct dfl_eth_group *egroup)
++{
++	if (!egroup->ops || !egroup->ops->reset)
++		return -EINVAL;
++
++	return eth_group_devs_enable(egroup);
++}
++
++static int dfl_eth_group_probe(struct dfl_device *dfl_dev)
++{
++	struct device *dev = &dfl_dev->dev;
++	struct dfl_eth_group *egroup;
++	int ret;
++
++	egroup = devm_kzalloc(dev, sizeof(*egroup), GFP_KERNEL);
++	if (!egroup)
++		return -ENOMEM;
++
++	dev_set_drvdata(&dfl_dev->dev, egroup);
++
++	egroup->dev = dev;
++	egroup->dfl_dev = dfl_dev;
++
++	egroup->base = devm_ioremap_resource(dev, &dfl_dev->mmio_res);
++	if (IS_ERR(egroup->base)) {
++		dev_err(dev, "get mem resource fail!\n");
++		return PTR_ERR(egroup->base);
++	}
++
++	ret = eth_group_setup(egroup);
++	if (ret)
++		return ret;
++
++	if (egroup->direction == 1)
++		ret = dfl_eth_group_line_side_init(egroup);
++	else
++		ret = dfl_eth_group_host_side_init(egroup);
++
++	if (!ret)
++		return 0;
++
++	eth_group_destroy(egroup);
++
++	return ret;
++}
++
++static void dfl_eth_group_remove(struct dfl_device *dfl_dev)
++{
++	struct dfl_eth_group *egroup = dev_get_drvdata(&dfl_dev->dev);
++
++	if (egroup->direction == 1)
++		dfl_eth_group_line_side_uinit(egroup);
++
++	eth_group_devs_disable(egroup);
++	eth_group_destroy(egroup);
++}
++
++#define FME_FEATURE_ID_ETH_GROUP	0x10
++
++static const struct dfl_device_id dfl_eth_group_ids[] = {
++	{ FME_ID, FME_FEATURE_ID_ETH_GROUP },
++	{ }
++};
++
++static struct dfl_driver dfl_eth_group_driver = {
++	.drv	= {
++		.name       = "dfl-eth-group",
++	},
++	.id_table = dfl_eth_group_ids,
++	.probe   = dfl_eth_group_probe,
++	.remove  = dfl_eth_group_remove,
++};
++
++module_dfl_driver(dfl_eth_group_driver);
++
++MODULE_DEVICE_TABLE(dfl, dfl_eth_group_ids);
++MODULE_DESCRIPTION("DFL ether group driver");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group.h b/drivers/net/ethernet/intel/dfl-eth-group.h
+new file mode 100644
+index 000000000000..2e90f86defe2
+--- /dev/null
++++ b/drivers/net/ethernet/intel/dfl-eth-group.h
+@@ -0,0 +1,83 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++
++/* Internal header file for FPGA DFL Ether Group Driver
++ *
++ * Copyright (C) 2020 Intel Corporation. All rights reserved.
++ */
++
++#ifndef __DFL_ETH_GROUP_H__
++#define __DFL_ETH_GROUP_H__
++
++#include <linux/netdevice.h>
++#include <linux/phy.h>
++#include <linux/rtnetlink.h>
++
++/* Used when trying to find a virtual mii bus on a specific dfl device.
++ * dev_name(dfl base device)-mii
++ */
++#define DFL_ETH_MII_ID_FMT "%s-mii"
++
++struct eth_dev {
++	struct dfl_eth_group *egroup;
++	struct device *dev;
++	int index;
++	bool lw_mac;
++	struct eth_com *phy;
++	struct eth_com *mac;
++	struct net_device *netdev;
++
++	char phy_id[MII_BUS_ID_SIZE + 3];
++};
++
++struct eth_dev_ops {
++	int (*lineside_init)(struct eth_dev *edev);
++	void (*lineside_remove)(struct eth_dev *edev);
++	int (*reset)(struct eth_dev *edev, bool en);
++};
++
++struct n3000_net_priv {
++	struct eth_dev *edev;
++};
++
++static inline struct eth_dev *net_device_to_eth_dev(struct net_device *netdev)
++{
++	struct n3000_net_priv *priv = netdev_priv(netdev);
++
++	return priv->edev;
++}
++
++struct stat_info {
++	unsigned int addr;
++	char string[ETH_GSTRING_LEN];
++};
++
++#define STAT_INFO(_addr, _string) \
++	.addr = _addr, .string = _string,
++
++int do_eth_com_write_reg(struct eth_com *ecom, bool add_feature,
++			 u16 addr, u32 data);
++int do_eth_com_read_reg(struct eth_com *ecom, bool add_feature,
++			u16 addr, u32 *data);
++
++#define eth_com_write_reg(ecom, addr, data)	\
++	do_eth_com_write_reg(ecom, false, addr, data)
++
++#define eth_com_read_reg(ecom, addr, data)	\
++	do_eth_com_read_reg(ecom, false, addr, data)
++
++#define eth_com_add_feat_write_reg(ecom, addr, data)	\
++	do_eth_com_write_reg(ecom, true, addr, data)
++
++#define eth_com_add_feat_read_reg(ecom, addr, data)	\
++	do_eth_com_read_reg(ecom, true, addr, data)
++
++u64 read_mac_stats(struct eth_com *ecom, unsigned int addr);
++
++struct net_device *n3000_netdev_create(struct eth_dev *edev);
++netdev_tx_t n3000_dummy_netdev_xmit(struct sk_buff *skb,
++				    struct net_device *dev);
++
++extern struct eth_dev_ops dfl_eth_dev_25g_ops;
++extern struct eth_dev_ops dfl_eth_dev_40g_ops;
++
++#endif /* __DFL_ETH_GROUP_H__ */
+diff --git a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+index c7b05581e546..3f686d23f44a 100644
+--- a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
++++ b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+@@ -10,6 +10,8 @@
+ #include <linux/phy.h>
+ #include <linux/platform_device.h>
+ 
++#include "dfl-eth-group.h"
++
+ #define NUM_CHIP	2
+ #define MAX_LINK	4
+ 
+@@ -148,7 +150,7 @@ static int m10bmc_retimer_mii_bus_init(struct m10bmc_retimer *retimer)
+ 	bus->name = M10BMC_RETIMER_MII_NAME;
+ 	bus->read = m10bmc_retimer_read;
+ 	bus->write = m10bmc_retimer_write;
+-	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii",
++	snprintf(bus->id, MII_BUS_ID_SIZE, DFL_ETH_MII_ID_FMT,
+ 		 dev_name(retimer->base_dev));
+ 	bus->parent = retimer->dev;
+ 	bus->phy_mask = ~(BITS_MASK(retimer->num_devs));
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0015-ethernet-dfl-eth-group-add-support-for-the-10G-confi.patch new/debian/patches/fpga-ofs/0015-ethernet-dfl-eth-group-add-support-for-the-10G-confi.patch
--- org/debian/patches/fpga-ofs/0015-ethernet-dfl-eth-group-add-support-for-the-10G-confi.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0015-ethernet-dfl-eth-group-add-support-for-the-10G-confi.patch	2021-07-20 06:17:11.344845038 +0200
@@ -0,0 +1,623 @@
+From bfa881a4c23635794aa069ed6d7f9feac50743a8 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Wed, 27 May 2020 00:13:45 +0800
+Subject: [PATCH 015/149] ethernet: dfl-eth-group: add support for the 10G
+ configurations
+
+This patch adds 10G configurations support for dfl ether group private
+feature.
+
+10G configurations have different PHY & MAC IP blocks from 25G, so a
+different set of HW operations is implemented, but the software arch is
+quite similar with 25G.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+----
+v2: no change
+v3: no change
+v4: check netdev for NULL
+    declare static for some functions
+    remove phydev field in struct n3000_net_priv
+    fix kernel warning on driver remove
+v5: It is possible the phy device is removed before net device removal,
+    So add the phy device existence check.
+---
+ drivers/net/ethernet/intel/Makefile           |   2 +-
+ .../net/ethernet/intel/dfl-eth-group-10g.c    | 544 ++++++++++++++++++
+ .../net/ethernet/intel/dfl-eth-group-main.c   |   3 +
+ drivers/net/ethernet/intel/dfl-eth-group.h    |   1 +
+ 4 files changed, 549 insertions(+), 1 deletion(-)
+ create mode 100644 drivers/net/ethernet/intel/dfl-eth-group-10g.c
+
+diff --git a/drivers/net/ethernet/intel/Makefile b/drivers/net/ethernet/intel/Makefile
+index 1624c26e8953..be097656a79e 100644
+--- a/drivers/net/ethernet/intel/Makefile
++++ b/drivers/net/ethernet/intel/Makefile
+@@ -17,6 +17,6 @@ obj-$(CONFIG_IAVF) += iavf/
+ obj-$(CONFIG_FM10K) += fm10k/
+ obj-$(CONFIG_ICE) += ice/
+ 
+-dfl-eth-group-objs := dfl-eth-group-main.o dfl-eth-group-25g.o
++dfl-eth-group-objs := dfl-eth-group-main.o dfl-eth-group-10g.o dfl-eth-group-25g.o
+ obj-$(CONFIG_FPGA_DFL_ETH_GROUP) += dfl-eth-group.o
+ obj-$(CONFIG_INTEL_M10_BMC_RETIMER) += intel-m10-bmc-retimer.o
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group-10g.c b/drivers/net/ethernet/intel/dfl-eth-group-10g.c
+new file mode 100644
+index 000000000000..36f9dfcbbe4f
+--- /dev/null
++++ b/drivers/net/ethernet/intel/dfl-eth-group-10g.c
+@@ -0,0 +1,544 @@
++// SPDX-License-Identifier: GPL-2.0
++/* Driver for 10G Ether Group private feature on Intel PAC (Programmable
++ * Acceleration Card) N3000
++ *
++ * Copyright (C) 2019-2020 Intel Corporation, Inc.
++ *
++ * Authors:
++ *   Wu Hao <hao.wu@intel.com>
++ *   Xu Yilun <yilun.xu@intel.com>
++ */
++#include <linux/netdevice.h>
++
++#include "dfl-eth-group.h"
++
++/* 10G PHY Register */
++#define PHY_LOOPBACK		0x2e1
++#define PHY_LOOPBACK_SERIAL	BIT(0)
++
++/* 10G MAC Register */
++#define TX_FRAME_MAXLENGTH	0x2c
++#define TX_PAUSE_FRAME_QUANTA	0x42
++#define TX_PAUSE_FRAME_HOLDOFF	0x43
++#define TX_PAUSE_FRAME_EN	0x44
++#define TX_PAUSE_FRAME_EN_CFG	BIT(0)
++#define RX_FRAME_MAXLENGTH	0xae
++
++/* Additional Feature Register */
++#define ADD_PHY_CTRL		0x0
++#define PHY_RESET		BIT(0)
++
++static int edev10g_reset(struct eth_dev *edev, bool en)
++{
++	struct eth_com *phy = edev->phy;
++	struct device *dev = edev->dev;
++	u32 val;
++	int ret;
++
++	/* 10G eth group supports PHY reset. It uses external reset. */
++	ret = eth_com_add_feat_read_reg(phy, ADD_PHY_CTRL, &val);
++	if (ret) {
++		dev_err(dev, "fail to read ADD_PHY_CTRL reg: %d\n", ret);
++		return ret;
++	}
++
++	/* return if PHY is already in expected state */
++	if ((val & PHY_RESET && en) || (!(val & PHY_RESET) && !en))
++		return 0;
++
++	if (en)
++		val |= PHY_RESET;
++	else
++		val &= ~PHY_RESET;
++
++	ret = eth_com_add_feat_write_reg(phy, ADD_PHY_CTRL, val);
++	if (ret)
++		dev_err(dev, "fail to write ADD_PHY_CTRL reg: %d\n", ret);
++
++	return ret;
++}
++
++static ssize_t tx_pause_frame_quanta_show(struct device *d,
++					  struct device_attribute *attr,
++					  char *buf)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(to_net_dev(d));
++	u32 data;
++	int ret;
++
++	ret = eth_com_read_reg(edev->mac, TX_PAUSE_FRAME_QUANTA, &data);
++
++	return ret ? : sprintf(buf, "0x%x\n", data);
++}
++
++static ssize_t tx_pause_frame_quanta_store(struct device *d,
++					   struct device_attribute *attr,
++					   const char *buf, size_t len)
++{
++	struct net_device *netdev = to_net_dev(d);
++	struct eth_dev *edev;
++	u32 data;
++	int ret;
++
++	if (kstrtou32(buf, 0, &data))
++		return -EINVAL;
++
++	edev = net_device_to_eth_dev(netdev);
++
++	rtnl_lock();
++
++	if (netif_running(netdev)) {
++		netdev_err(netdev, "must be stopped to change pause param\n");
++		ret = -EBUSY;
++		goto out;
++	}
++
++	ret = eth_com_write_reg(edev->mac, TX_PAUSE_FRAME_QUANTA, data);
++
++out:
++	rtnl_unlock();
++
++	return ret ? : len;
++}
++static DEVICE_ATTR_RW(tx_pause_frame_quanta);
++
++static ssize_t tx_pause_frame_holdoff_show(struct device *d,
++					   struct device_attribute *attr,
++					   char *buf)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(to_net_dev(d));
++	u32 data;
++	int ret;
++
++	ret = eth_com_read_reg(edev->mac, TX_PAUSE_FRAME_HOLDOFF, &data);
++
++	return ret ? : sprintf(buf, "0x%x\n", data);
++}
++
++static ssize_t tx_pause_frame_holdoff_store(struct device *d,
++					    struct device_attribute *attr,
++					    const char *buf, size_t len)
++{
++	struct net_device *netdev = to_net_dev(d);
++	struct eth_dev *edev;
++	u32 data;
++	int ret;
++
++	if (kstrtou32(buf, 0, &data))
++		return -EINVAL;
++
++	edev = net_device_to_eth_dev(netdev);
++
++	rtnl_lock();
++
++	if (netif_running(netdev)) {
++		netdev_err(netdev, "must be stopped to change pause param\n");
++		ret = -EBUSY;
++		goto out;
++	}
++
++	ret = eth_com_write_reg(edev->mac, TX_PAUSE_FRAME_HOLDOFF, data);
++
++out:
++	rtnl_unlock();
++
++	return ret ? : len;
++}
++static DEVICE_ATTR_RW(tx_pause_frame_holdoff);
++
++static struct attribute *edev10g_dev_attrs[] = {
++	&dev_attr_tx_pause_frame_quanta.attr,
++	&dev_attr_tx_pause_frame_holdoff.attr,
++	NULL
++};
++
++/* device attributes */
++static const struct attribute_group edev10g_attr_group = {
++	.attrs = edev10g_dev_attrs,
++};
++
++/* ethtool ops */
++static struct stat_info stats_10g[] = {
++	/* TX Statistics */
++	{STAT_INFO(0x142, "tx_frame_ok")},
++	{STAT_INFO(0x144, "tx_frame_err")},
++	{STAT_INFO(0x146, "tx_frame_crc_err")},
++	{STAT_INFO(0x148, "tx_octets_ok")},
++	{STAT_INFO(0x14a, "tx_pause_mac_ctrl_frames")},
++	{STAT_INFO(0x14c, "tx_if_err")},
++	{STAT_INFO(0x14e, "tx_unicast_frame_ok")},
++	{STAT_INFO(0x150, "tx_unicast_frame_err")},
++	{STAT_INFO(0x152, "tx_multicast_frame_ok")},
++	{STAT_INFO(0x154, "tx_multicast_frame_err")},
++	{STAT_INFO(0x156, "tx_broadcast_frame_ok")},
++	{STAT_INFO(0x158, "tx_broadcast_frame_err")},
++	{STAT_INFO(0x15a, "tx_ether_octets")},
++	{STAT_INFO(0x15c, "tx_ether_pkts")},
++	{STAT_INFO(0x15e, "tx_ether_undersize_pkts")},
++	{STAT_INFO(0x160, "tx_ether_oversize_pkts")},
++	{STAT_INFO(0x162, "tx_ether_pkts_64_octets")},
++	{STAT_INFO(0x164, "tx_ether_pkts_65_127_octets")},
++	{STAT_INFO(0x166, "tx_ether_pkts_128_255_octets")},
++	{STAT_INFO(0x168, "tx_ether_pkts_256_511_octets")},
++	{STAT_INFO(0x16a, "tx_ether_pkts_512_1023_octets")},
++	{STAT_INFO(0x16c, "tx_ether_pkts_1024_1518_octets")},
++	{STAT_INFO(0x16e, "tx_ether_pkts_1519_x_octets")},
++	{STAT_INFO(0x176, "tx_unicast_mac_ctrl_frames")},
++	{STAT_INFO(0x178, "tx_multicast_mac_ctrl_frames")},
++	{STAT_INFO(0x17a, "tx_broadcast_mac_ctrl_frames")},
++	{STAT_INFO(0x17c, "tx_pfc_mac_ctrl_frames")},
++
++	/* RX Statistics */
++	{STAT_INFO(0x1c2, "rx_frame_ok")},
++	{STAT_INFO(0x1c4, "rx_frame_err")},
++	{STAT_INFO(0x1c6, "rx_frame_crc_err")},
++	{STAT_INFO(0x1c8, "rx_octets_ok")},
++	{STAT_INFO(0x1ca, "rx_pause_mac_ctrl_frames")},
++	{STAT_INFO(0x1cc, "rx_if_err")},
++	{STAT_INFO(0x1ce, "rx_unicast_frame_ok")},
++	{STAT_INFO(0x1d0, "rx_unicast_frame_err")},
++	{STAT_INFO(0x1d2, "rx_multicast_frame_ok")},
++	{STAT_INFO(0x1d4, "rx_multicast_frame_err")},
++	{STAT_INFO(0x1d6, "rx_broadcast_frame_ok")},
++	{STAT_INFO(0x1d8, "rx_broadcast_frame_err")},
++	{STAT_INFO(0x1da, "rx_ether_octets")},
++	{STAT_INFO(0x1dc, "rx_ether_pkts")},
++	{STAT_INFO(0x1de, "rx_ether_undersize_pkts")},
++	{STAT_INFO(0x1e0, "rx_ether_oversize_pkts")},
++	{STAT_INFO(0x1e2, "rx_ether_pkts_64_octets")},
++	{STAT_INFO(0x1e4, "rx_ether_pkts_65_127_octets")},
++	{STAT_INFO(0x1e6, "rx_ether_pkts_128_255_octets")},
++	{STAT_INFO(0x1e8, "rx_ether_pkts_256_511_octets")},
++	{STAT_INFO(0x1ea, "rx_ether_pkts_512_1023_octets")},
++	{STAT_INFO(0x1ec, "rx_ether_pkts_1024_1518_octets")},
++	{STAT_INFO(0x1ee, "rx_ether_pkts_1519_x_octets")},
++	{STAT_INFO(0x1f0, "rx_ether_fragments")},
++	{STAT_INFO(0x1f2, "rx_ether_jabbers")},
++	{STAT_INFO(0x1f4, "rx_ether_crc_err")},
++	{STAT_INFO(0x1f6, "rx_unicast_mac_ctrl_frames")},
++	{STAT_INFO(0x1f8, "rx_multicast_mac_ctrl_frames")},
++	{STAT_INFO(0x1fa, "rx_broadcast_mac_ctrl_frames")},
++	{STAT_INFO(0x1fc, "rx_pfc_mac_ctrl_frames")},
++};
++
++static void edev10g_get_strings(struct net_device *netdev, u32 stringset, u8 *s)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	unsigned int i;
++
++	if (stringset != ETH_SS_STATS || edev->lw_mac)
++		return;
++
++	for (i = 0; i < ARRAY_SIZE(stats_10g); i++, s += ETH_GSTRING_LEN)
++		memcpy(s, stats_10g[i].string, ETH_GSTRING_LEN);
++}
++
++static int edev10g_get_sset_count(struct net_device *netdev, int stringset)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++
++	if (stringset != ETH_SS_STATS || edev->lw_mac)
++		return -EOPNOTSUPP;
++
++	return (int)ARRAY_SIZE(stats_10g);
++}
++
++static void edev10g_get_stats(struct net_device *netdev,
++			      struct ethtool_stats *stats, u64 *data)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	unsigned int i;
++
++	if (edev->lw_mac || !netif_running(netdev))
++		return;
++
++	for (i = 0; i < ARRAY_SIZE(stats_10g); i++)
++		data[i] = read_mac_stats(edev->mac, stats_10g[i].addr);
++}
++
++static int edev10g_get_link_ksettings(struct net_device *netdev,
++				      struct ethtool_link_ksettings *cmd)
++{
++	if (!netdev->phydev)
++		return -ENODEV;
++
++	phy_ethtool_ksettings_get(netdev->phydev, cmd);
++
++	return 0;
++}
++
++static void edev10g_get_pauseparam(struct net_device *netdev,
++				   struct ethtool_pauseparam *pause)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	u32 data;
++	int ret;
++
++	pause->autoneg = 0;
++	pause->rx_pause = 0;
++
++	ret = eth_com_read_reg(edev->mac, TX_PAUSE_FRAME_EN, &data);
++	if (ret) {
++		pause->tx_pause = 0;
++		return;
++	}
++
++	pause->tx_pause = (data & TX_PAUSE_FRAME_EN_CFG) ? 0x1 : 0;
++}
++
++static int edev10g_set_pauseparam(struct net_device *netdev,
++				  struct ethtool_pauseparam *pause)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	struct eth_com *mac = edev->mac;
++	bool enable = pause->tx_pause;
++	u32 data;
++	int ret;
++
++	if (pause->autoneg || pause->rx_pause)
++		return -EOPNOTSUPP;
++
++	if (netif_running(netdev)) {
++		netdev_err(netdev, "must be stopped to change pause param\n");
++		return -EBUSY;
++	}
++
++	ret = eth_com_read_reg(mac, TX_PAUSE_FRAME_EN, &data);
++	if (ret)
++		return ret;
++
++	if (enable)
++		data |= TX_PAUSE_FRAME_EN_CFG;
++	else
++		data &= ~TX_PAUSE_FRAME_EN_CFG;
++
++	return eth_com_write_reg(mac, TX_PAUSE_FRAME_EN, data);
++}
++
++static const struct ethtool_ops edev10g_ethtool_ops = {
++	.get_link = ethtool_op_get_link,
++	.get_strings = edev10g_get_strings,
++	.get_sset_count = edev10g_get_sset_count,
++	.get_ethtool_stats = edev10g_get_stats,
++	.get_link_ksettings = edev10g_get_link_ksettings,
++	.get_pauseparam = edev10g_get_pauseparam,
++	.set_pauseparam = edev10g_set_pauseparam,
++};
++
++/* netdev ops */
++static int edev10g_netdev_open(struct net_device *netdev)
++{
++	struct n3000_net_priv *priv = netdev_priv(netdev);
++	struct eth_dev *edev = priv->edev;
++	int ret;
++
++	ret = edev10g_reset(edev, false);
++	if (ret)
++		return ret;
++
++	if (netdev->phydev)
++		phy_start(netdev->phydev);
++
++	return 0;
++}
++
++static int edev10g_netdev_stop(struct net_device *netdev)
++{
++	struct n3000_net_priv *priv = netdev_priv(netdev);
++	struct eth_dev *edev = priv->edev;
++	int ret;
++
++	ret = edev10g_reset(edev, true);
++	if (ret)
++		return ret;
++
++	if (netdev->phydev)
++		phy_stop(netdev->phydev);
++
++	return 0;
++}
++
++static int edev10g_mtu_init(struct net_device *netdev)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	struct eth_com *mac = edev->mac;
++	u32 tx = 0, rx = 0, mtu;
++	int ret;
++
++	ret = eth_com_read_reg(mac, TX_FRAME_MAXLENGTH, &tx);
++	if (ret)
++		return ret;
++
++	ret = eth_com_read_reg(mac, RX_FRAME_MAXLENGTH, &rx);
++	if (ret)
++		return ret;
++
++	mtu = min(min(tx, rx), netdev->max_mtu);
++
++	ret = eth_com_write_reg(mac, TX_FRAME_MAXLENGTH, rx);
++	if (ret)
++		return ret;
++
++	ret = eth_com_write_reg(mac, RX_FRAME_MAXLENGTH, tx);
++	if (ret)
++		return ret;
++
++	netdev->mtu = mtu;
++
++	return 0;
++}
++
++static int edev10g_change_mtu(struct net_device *netdev, int new_mtu)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	struct eth_com *mac = edev->mac;
++	int ret;
++
++	if (netif_running(netdev)) {
++		netdev_err(netdev, "must be stopped to change mtu\n");
++		return -EBUSY;
++	}
++
++	ret = eth_com_write_reg(mac, TX_FRAME_MAXLENGTH, new_mtu);
++	if (ret)
++		return ret;
++
++	ret = eth_com_write_reg(mac, RX_FRAME_MAXLENGTH, new_mtu);
++	if (ret)
++		return ret;
++
++	netdev->mtu = new_mtu;
++
++	return 0;
++}
++
++static int edev10g_set_loopback(struct net_device *netdev, bool en)
++{
++	struct eth_dev *edev = net_device_to_eth_dev(netdev);
++	struct eth_com *phy = edev->phy;
++	u32 data;
++	int ret;
++
++	ret = eth_com_read_reg(phy, PHY_LOOPBACK, &data);
++	if (ret)
++		return ret;
++
++	if (en)
++		data |= PHY_LOOPBACK_SERIAL;
++	else
++		data &= ~PHY_LOOPBACK_SERIAL;
++
++	return eth_com_write_reg(phy, PHY_LOOPBACK, data);
++}
++
++static int edev10g_set_features(struct net_device *netdev,
++				netdev_features_t features)
++{
++	netdev_features_t changed = netdev->features ^ features;
++
++	if (changed & NETIF_F_LOOPBACK)
++		return edev10g_set_loopback(netdev,
++					    !!(features & NETIF_F_LOOPBACK));
++
++	return 0;
++}
++
++static const struct net_device_ops edev10g_netdev_ops = {
++	.ndo_open = edev10g_netdev_open,
++	.ndo_stop = edev10g_netdev_stop,
++	.ndo_change_mtu = edev10g_change_mtu,
++	.ndo_set_features = edev10g_set_features,
++	.ndo_start_xmit = n3000_dummy_netdev_xmit,
++};
++
++static void edev10g_adjust_link(struct net_device *netdev)
++{}
++
++static int edev10g_netdev_init(struct net_device *netdev)
++{
++	int ret;
++
++	ret = edev10g_mtu_init(netdev);
++	if (ret)
++		return ret;
++
++	return edev10g_set_loopback(netdev,
++				   !!(netdev->features & NETIF_F_LOOPBACK));
++}
++
++static int dfl_eth_dev_10g_init(struct eth_dev *edev)
++{
++	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
++	struct device *dev = edev->dev;
++	struct phy_device *phydev;
++	struct net_device *netdev;
++	int ret;
++
++	netdev = n3000_netdev_create(edev);
++	if (!netdev)
++		return -ENOMEM;
++
++	netdev->hw_features |= NETIF_F_LOOPBACK;
++	netdev->netdev_ops = &edev10g_netdev_ops;
++	netdev->ethtool_ops = &edev10g_ethtool_ops;
++
++	phydev = phy_connect(netdev, edev->phy_id, edev10g_adjust_link,
++			     PHY_INTERFACE_MODE_NA);
++	if (IS_ERR(phydev)) {
++		dev_err(dev, "PHY connection failed\n");
++		ret = PTR_ERR(phydev);
++		goto err_free_netdev;
++	}
++
++	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, mask);
++	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseSR_Full_BIT, mask);
++	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseLR_Full_BIT, mask);
++	linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, mask);
++	linkmode_and(phydev->supported, phydev->supported, mask);
++	linkmode_copy(phydev->advertising, phydev->supported);
++
++	phy_attached_info(phydev);
++
++	ret = edev10g_netdev_init(netdev);
++	if (ret) {
++		dev_err(dev, "fail to init netdev %s\n", netdev->name);
++		goto err_phy_disconnect;
++	}
++
++	netdev->sysfs_groups[0] = &edev10g_attr_group;
++
++	netif_carrier_off(netdev);
++	ret = register_netdev(netdev);
++	if (ret) {
++		dev_err(dev, "fail to register netdev %s\n", netdev->name);
++		goto err_phy_disconnect;
++	}
++
++	edev->netdev = netdev;
++
++	return 0;
++
++err_phy_disconnect:
++	if (netdev->phydev)
++		phy_disconnect(phydev);
++err_free_netdev:
++	free_netdev(netdev);
++
++	return ret;
++}
++
++static void dfl_eth_dev_10g_remove(struct eth_dev *edev)
++{
++	struct net_device *netdev = edev->netdev;
++
++	if (netdev->phydev)
++		phy_disconnect(netdev->phydev);
++
++	unregister_netdev(netdev);
++}
++
++struct eth_dev_ops dfl_eth_dev_10g_ops = {
++	.lineside_init = dfl_eth_dev_10g_init,
++	.lineside_remove = dfl_eth_dev_10g_remove,
++	.reset = edev10g_reset,
++};
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group-main.c b/drivers/net/ethernet/intel/dfl-eth-group-main.c
+index a29b8b16bdbf..89b4450a1c87 100644
+--- a/drivers/net/ethernet/intel/dfl-eth-group-main.c
++++ b/drivers/net/ethernet/intel/dfl-eth-group-main.c
+@@ -481,6 +481,9 @@ static int eth_group_setup(struct dfl_eth_group *egroup)
+ 		return ret;
+ 
+ 	switch (egroup->speed) {
++	case 10:
++		egroup->ops = &dfl_eth_dev_10g_ops;
++		break;
+ 	case 25:
+ 		egroup->ops = &dfl_eth_dev_25g_ops;
+ 		break;
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group.h b/drivers/net/ethernet/intel/dfl-eth-group.h
+index 2e90f86defe2..63f49a039cf2 100644
+--- a/drivers/net/ethernet/intel/dfl-eth-group.h
++++ b/drivers/net/ethernet/intel/dfl-eth-group.h
+@@ -77,6 +77,7 @@ struct net_device *n3000_netdev_create(struct eth_dev *edev);
+ netdev_tx_t n3000_dummy_netdev_xmit(struct sk_buff *skb,
+ 				    struct net_device *dev);
+ 
++extern struct eth_dev_ops dfl_eth_dev_10g_ops;
+ extern struct eth_dev_ops dfl_eth_dev_25g_ops;
+ extern struct eth_dev_ops dfl_eth_dev_40g_ops;
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0016-ethernet-m10-retimer-expose-the-retimer-firmware-ver.patch new/debian/patches/fpga-ofs/0016-ethernet-m10-retimer-expose-the-retimer-firmware-ver.patch
--- org/debian/patches/fpga-ofs/0016-ethernet-m10-retimer-expose-the-retimer-firmware-ver.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0016-ethernet-m10-retimer-expose-the-retimer-firmware-ver.patch	2021-07-20 06:17:11.348845026 +0200
@@ -0,0 +1,132 @@
+From 68ef6ca286083e217ac9242a907605eabfc7766e Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Wed, 10 Jun 2020 15:53:36 +0800
+Subject: [PATCH 016/149] ethernet: m10-retimer: expose the retimer firmware
+ version information
+
+This patch creates two sysfs interfaces for each retimer chip (retimer A &
+retimer B). They expose the firmware version information to userspace.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+----
+v3: no change.
+---
+ .../sysfs-driver-intel-m10-bmc-retimer        | 31 +++++++++++++++++
+ .../ethernet/intel/intel-m10-bmc-retimer.c    | 33 +++++++++++++++++++
+ include/linux/mfd/intel-m10-bmc.h             |  4 +++
+ 3 files changed, 68 insertions(+)
+ create mode 100644 Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-retimer
+
+diff --git a/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-retimer b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-retimer
+new file mode 100644
+index 000000000000..a84db188233e
+--- /dev/null
++++ b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-retimer
+@@ -0,0 +1,31 @@
++What:		/sys/bus/platform/devices/n3000bmc-retimer.*.auto/A_sbus_version
++Date:		Sep 2020
++KernelVersion:	5.10
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Read only. Returns the Transceiver bus firmware version of
++		retimer chip A.
++		Format: "0x%04x".
++
++What:		/sys/bus/platform/devices/n3000bmc-retimer.*.auto/A_serdes_version
++Date:		Sep 2020
++KernelVersion:	5.10
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Read only. Returns the SERDES firmware version of retimer
++		chip A.
++		Format: "0x%04x".
++
++What:		/sys/bus/platform/devices/n3000bmc-retimer.*.auto/B_sbus_version
++Date:		Sep 2020
++KernelVersion:  5.10
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Read only. Returns the Transceiver bus firmware version of
++		retimer chip B.
++		Format: "0x%04x".
++
++What:		/sys/bus/platform/devices/n3000bmc-retimer.*.auto/B_serdes_version
++Date:		Sep 2020
++KernelVersion:  5.10
++Contact:	Xu Yilun <yilun.xu@intel.com>
++Description:	Read only. Returns the SERDES firmware version of retimer
++		chip B.
++		Format: "0x%04x".
+diff --git a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+index 3f686d23f44a..d20776a96600 100644
+--- a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
++++ b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+@@ -4,6 +4,7 @@
+  * Copyright (C) 2018-2020 Intel Corporation. All rights reserved.
+  *
+  */
++#include <linux/bitfield.h>
+ #include <linux/device.h>
+ #include <linux/mfd/intel-m10-bmc.h>
+ #include <linux/module.h>
+@@ -28,6 +29,37 @@ struct m10bmc_retimer {
+ 	struct mii_bus *retimer_mii_bus;
+ };
+ 
++#define retimer_version_attr(chip, type, reg, field)			\
++static ssize_t								\
++chip##_##type##_version_show(struct device *dev,				\
++			     struct device_attribute *attr, char *buf)	\
++{									\
++	struct m10bmc_retimer *retimer = dev_get_drvdata(dev);		\
++	unsigned int val;						\
++	int ret;							\
++									\
++	ret = m10bmc_sys_read(retimer->m10bmc, reg, &val);		\
++	if (ret)							\
++		return ret;						\
++									\
++	return sprintf(buf, "0x%04x\n", (u16)FIELD_GET(field, val));	\
++}									\
++static DEVICE_ATTR_RO(chip##_##type##_version)
++
++retimer_version_attr(A, sbus, PKVL_A_VERSION, SBUS_VERSION);
++retimer_version_attr(A, serdes, PKVL_A_VERSION, SERDES_VERSION);
++retimer_version_attr(B, sbus, PKVL_B_VERSION, SBUS_VERSION);
++retimer_version_attr(B, serdes, PKVL_B_VERSION, SERDES_VERSION);
++
++static struct attribute *m10bmc_retimer_attrs[] = {
++	&dev_attr_A_sbus_version.attr,
++	&dev_attr_A_serdes_version.attr,
++	&dev_attr_B_sbus_version.attr,
++	&dev_attr_B_serdes_version.attr,
++	NULL,
++};
++ATTRIBUTE_GROUPS(m10bmc_retimer);
++
+ #define RETIMER_LINK_STAT_BIT(retimer_id, link_id) \
+ 	BIT(((retimer_id) << 2) + (link_id))
+ 
+@@ -203,6 +235,7 @@ static struct platform_driver intel_m10bmc_retimer_driver = {
+ 	.remove = intel_m10bmc_retimer_remove,
+ 	.driver = {
+ 		.name = N3000BMC_RETIMER_DEV_NAME,
++		.dev_groups = m10bmc_retimer_groups,
+ 	},
+ };
+ 
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 3d9d22c94ae2..f9a56e17d3d6 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -23,6 +23,10 @@
+ 
+ /* PKVL related registers, in system register region */
+ #define PKVL_LINK_STATUS		0x164
++#define PKVL_A_VERSION			0x254
++#define PKVL_B_VERSION			0x258
++#define SERDES_VERSION			GENMASK(15, 0)
++#define SBUS_VERSION			GENMASK(31, 16)
+ 
+ /**
+  * struct intel_m10bmc_retimer_pdata - subdev retimer platform data
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0017-fpga-dfl-afu-add-read-only-write-only-dma-mapping-su.patch new/debian/patches/fpga-ofs/0017-fpga-dfl-afu-add-read-only-write-only-dma-mapping-su.patch
--- org/debian/patches/fpga-ofs/0017-fpga-dfl-afu-add-read-only-write-only-dma-mapping-su.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0017-fpga-dfl-afu-add-read-only-write-only-dma-mapping-su.patch	2021-07-20 06:17:11.348845026 +0200
@@ -0,0 +1,230 @@
+From d2b65a5e883bb44ba80cb8dc0f20fa4159649c21 Mon Sep 17 00:00:00 2001
+From: Michael Adler <Michael.Adler@intel.com>
+Date: Thu, 7 May 2020 19:30:56 +0800
+Subject: [PATCH 017/149] fpga: dfl: afu: add read-only/write-only dma mapping
+ support
+
+This patch adds support for Read-only and Write-only DMA mapping
+through existing DMA_MAP/UNMAP ioctl interface, it introduces
+two new flags DFL_DMA_MAP_FLAG_READ (mem to dev) and
+DFL_DMA_MAP_FLAG_WRITE (dev to mem).
+
+Signed-off-by: Michael Adler <Michael.Adler@intel.com>
+Signed-off-by: Wu Hao <hao.wu@intel.com>
+---
+ drivers/fpga/dfl-afu-dma-region.c | 37 ++++++++++++++++++++++++++-----
+ drivers/fpga/dfl-afu-main.c       |  6 +++--
+ drivers/fpga/dfl-afu.h            |  7 ++++--
+ include/uapi/linux/fpga-dfl.h     | 10 ++++++++-
+ 4 files changed, 49 insertions(+), 11 deletions(-)
+
+diff --git a/drivers/fpga/dfl-afu-dma-region.c b/drivers/fpga/dfl-afu-dma-region.c
+index 02b60fde0430..faeb65107eff 100644
+--- a/drivers/fpga/dfl-afu-dma-region.c
++++ b/drivers/fpga/dfl-afu-dma-region.c
+@@ -9,7 +9,7 @@
+  *   Xiao Guangrong <guangrong.xiao@linux.intel.com>
+  */
+ 
+-#include <linux/dma-mapping.h>
++#include <linux/fpga-dfl.h>
+ #include <linux/sched/signal.h>
+ #include <linux/uaccess.h>
+ #include <linux/mm.h>
+@@ -36,6 +36,7 @@ static int afu_dma_pin_pages(struct dfl_feature_platform_data *pdata,
+ {
+ 	int npages = region->length >> PAGE_SHIFT;
+ 	struct device *dev = &pdata->dev->dev;
++	unsigned int flags = 0;
+ 	int ret, pinned;
+ 
+ 	ret = account_locked_vm(current->mm, npages, true);
+@@ -48,7 +49,10 @@ static int afu_dma_pin_pages(struct dfl_feature_platform_data *pdata,
+ 		goto unlock_vm;
+ 	}
+ 
+-	pinned = pin_user_pages_fast(region->user_addr, npages, FOLL_WRITE,
++	if (region->direction != DMA_TO_DEVICE)
++		flags |= FOLL_WRITE;
++
++	pinned = pin_user_pages_fast(region->user_addr, npages, flags,
+ 				     region->pages);
+ 	if (pinned < 0) {
+ 		ret = pinned;
+@@ -287,11 +291,31 @@ afu_dma_region_find_iova(struct dfl_feature_platform_data *pdata, u64 iova)
+ 	return afu_dma_region_find(pdata, iova, 0);
+ }
+ 
++static enum dma_data_direction dma_flag_to_dir(u32 flags)
++{
++	u32 mask = DFL_DMA_MAP_FLAG_READ | DFL_DMA_MAP_FLAG_WRITE;
++
++	/*
++	 * DMA is bidirectional if both read and write are specified or if
++	 * neither read nor write is specified. The latter supports legacy
++	 * code, which did not pass any flags.
++	 */
++	switch (flags & mask) {
++	case DFL_DMA_MAP_FLAG_READ:
++		return DMA_TO_DEVICE;
++	case DFL_DMA_MAP_FLAG_WRITE:
++		return DMA_FROM_DEVICE;
++	}
++
++	return DMA_BIDIRECTIONAL;
++}
++
+ /**
+  * afu_dma_map_region - map memory region for dma
+  * @pdata: feature device platform data
+  * @user_addr: address of the memory region
+  * @length: size of the memory region
++ * @flags: dma mapping flags
+  * @iova: pointer of iova address
+  *
+  * Map memory region defined by @user_addr and @length, and return dma address
+@@ -299,7 +323,7 @@ afu_dma_region_find_iova(struct dfl_feature_platform_data *pdata, u64 iova)
+  * Return 0 for success, otherwise error code.
+  */
+ int afu_dma_map_region(struct dfl_feature_platform_data *pdata,
+-		       u64 user_addr, u64 length, u64 *iova)
++		       u64 user_addr, u64 length, u32 flags, u64 *iova)
+ {
+ 	struct dfl_afu_dma_region *region;
+ 	int ret;
+@@ -321,6 +345,7 @@ int afu_dma_map_region(struct dfl_feature_platform_data *pdata,
+ 
+ 	region->user_addr = user_addr;
+ 	region->length = length;
++	region->direction = dma_flag_to_dir(flags);
+ 
+ 	/* Pin the user memory region */
+ 	ret = afu_dma_pin_pages(pdata, region);
+@@ -340,7 +365,7 @@ int afu_dma_map_region(struct dfl_feature_platform_data *pdata,
+ 	region->iova = dma_map_page(dfl_fpga_pdata_to_parent(pdata),
+ 				    region->pages[0], 0,
+ 				    region->length,
+-				    DMA_BIDIRECTIONAL);
++				    region->direction);
+ 	if (dma_mapping_error(dfl_fpga_pdata_to_parent(pdata), region->iova)) {
+ 		dev_err(&pdata->dev->dev, "failed to map for dma\n");
+ 		ret = -EFAULT;
+@@ -361,7 +386,7 @@ int afu_dma_map_region(struct dfl_feature_platform_data *pdata,
+ 
+ unmap_dma:
+ 	dma_unmap_page(dfl_fpga_pdata_to_parent(pdata),
+-		       region->iova, region->length, DMA_BIDIRECTIONAL);
++		       region->iova, region->length, region->direction);
+ unpin_pages:
+ 	afu_dma_unpin_pages(pdata, region);
+ free_region:
+@@ -397,7 +422,7 @@ int afu_dma_unmap_region(struct dfl_feature_platform_data *pdata, u64 iova)
+ 	mutex_unlock(&pdata->lock);
+ 
+ 	dma_unmap_page(dfl_fpga_pdata_to_parent(pdata),
+-		       region->iova, region->length, DMA_BIDIRECTIONAL);
++		       region->iova, region->length, region->direction);
+ 	afu_dma_unpin_pages(pdata, region);
+ 	kfree(region);
+ 
+diff --git a/drivers/fpga/dfl-afu-main.c b/drivers/fpga/dfl-afu-main.c
+index 753cda4b2568..64fff9d6cf2e 100644
+--- a/drivers/fpga/dfl-afu-main.c
++++ b/drivers/fpga/dfl-afu-main.c
+@@ -695,6 +695,7 @@ static long afu_ioctl_get_region_info(struct dfl_feature_platform_data *pdata,
+ static long
+ afu_ioctl_dma_map(struct dfl_feature_platform_data *pdata, void __user *arg)
+ {
++	u32 dma_mask = DFL_DMA_MAP_FLAG_READ | DFL_DMA_MAP_FLAG_WRITE;
+ 	struct dfl_fpga_port_dma_map map;
+ 	unsigned long minsz;
+ 	long ret;
+@@ -704,10 +705,11 @@ afu_ioctl_dma_map(struct dfl_feature_platform_data *pdata, void __user *arg)
+ 	if (copy_from_user(&map, arg, minsz))
+ 		return -EFAULT;
+ 
+-	if (map.argsz < minsz || map.flags)
++	if (map.argsz < minsz || map.flags & ~dma_mask)
+ 		return -EINVAL;
+ 
+-	ret = afu_dma_map_region(pdata, map.user_addr, map.length, &map.iova);
++	ret = afu_dma_map_region(pdata, map.user_addr, map.length, map.flags,
++				 &map.iova);
+ 	if (ret)
+ 		return ret;
+ 
+diff --git a/drivers/fpga/dfl-afu.h b/drivers/fpga/dfl-afu.h
+index 576e94960086..22d46e284cfc 100644
+--- a/drivers/fpga/dfl-afu.h
++++ b/drivers/fpga/dfl-afu.h
+@@ -17,6 +17,7 @@
+ #ifndef __DFL_AFU_H
+ #define __DFL_AFU_H
+ 
++#include <linux/dma-mapping.h>
+ #include <linux/mm.h>
+ 
+ #include "dfl.h"
+@@ -41,7 +42,7 @@ struct dfl_afu_mmio_region {
+ };
+ 
+ /**
+- * struct fpga_afu_dma_region - afu DMA region data structure
++ * struct dfl_afu_dma_region - afu DMA region data structure
+  *
+  * @user_addr: region userspace virtual address.
+  * @length: region length.
+@@ -49,6 +50,7 @@ struct dfl_afu_mmio_region {
+  * @pages: ptr to pages of this region.
+  * @node: rb tree node.
+  * @in_use: flag to indicate if this region is in_use.
++ * @direction: dma data direction.
+  */
+ struct dfl_afu_dma_region {
+ 	u64 user_addr;
+@@ -57,6 +59,7 @@ struct dfl_afu_dma_region {
+ 	struct page **pages;
+ 	struct rb_node node;
+ 	bool in_use;
++	enum dma_data_direction direction;
+ };
+ 
+ /**
+@@ -96,7 +99,7 @@ int afu_mmio_region_get_by_offset(struct dfl_feature_platform_data *pdata,
+ void afu_dma_region_init(struct dfl_feature_platform_data *pdata);
+ void afu_dma_region_destroy(struct dfl_feature_platform_data *pdata);
+ int afu_dma_map_region(struct dfl_feature_platform_data *pdata,
+-		       u64 user_addr, u64 length, u64 *iova);
++		       u64 user_addr, u64 length, u32 flags, u64 *iova);
+ int afu_dma_unmap_region(struct dfl_feature_platform_data *pdata, u64 iova);
+ struct dfl_afu_dma_region *
+ afu_dma_region_find(struct dfl_feature_platform_data *pdata,
+diff --git a/include/uapi/linux/fpga-dfl.h b/include/uapi/linux/fpga-dfl.h
+index 1621b077bf21..72d68e205eb9 100644
+--- a/include/uapi/linux/fpga-dfl.h
++++ b/include/uapi/linux/fpga-dfl.h
+@@ -121,12 +121,20 @@ struct dfl_fpga_port_region_info {
+  * Map the dma memory per user_addr and length which are provided by caller.
+  * Driver fills the iova in provided struct afu_port_dma_map.
+  * This interface only accepts page-size aligned user memory for dma mapping.
++ *
++ * Setting only one of DFL_DMA_MAP_FLAG_READ or WRITE limits FPGA-initiated
++ * DMA requests to only reads or only writes. To be back-compatiable with
++ * legacy driver, setting neither flag is equivalent to setting both flags:
++ * both read and write are requests permitted.
++ *
+  * Return: 0 on success, -errno on failure.
+  */
+ struct dfl_fpga_port_dma_map {
+ 	/* Input */
+ 	__u32 argsz;		/* Structure length */
+-	__u32 flags;		/* Zero for now */
++	__u32 flags;
++#define DFL_DMA_MAP_FLAG_READ	(1 << 0)/* readable from device */
++#define DFL_DMA_MAP_FLAG_WRITE	(1 << 1)/* writable from device */
+ 	__u64 user_addr;        /* Process virtual address */
+ 	__u64 length;           /* Length of mapping (bytes)*/
+ 	/* Output */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0018-fpga-dfl-afu-add-FOLL_LONGTERM-flag-when-pin-user-pa.patch new/debian/patches/fpga-ofs/0018-fpga-dfl-afu-add-FOLL_LONGTERM-flag-when-pin-user-pa.patch
--- org/debian/patches/fpga-ofs/0018-fpga-dfl-afu-add-FOLL_LONGTERM-flag-when-pin-user-pa.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0018-fpga-dfl-afu-add-FOLL_LONGTERM-flag-when-pin-user-pa.patch	2021-07-20 06:17:11.348845026 +0200
@@ -0,0 +1,30 @@
+From b0b4472b243a9c2a025ec6b45e6659b9032e593e Mon Sep 17 00:00:00 2001
+From: Wu Hao <hao.wu@intel.com>
+Date: Thu, 7 May 2020 19:30:57 +0800
+Subject: [PATCH 018/149] fpga: dfl: afu: add FOLL_LONGTERM flag when pin user
+ pages
+
+This patch add FOLL_LONGTERM flag in case the buffers are
+used for DMA.
+
+Signed-off-by: Wu Hao <hao.wu@intel.com>
+---
+ drivers/fpga/dfl-afu-dma-region.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/dfl-afu-dma-region.c b/drivers/fpga/dfl-afu-dma-region.c
+index faeb65107eff..84abbecfb66a 100644
+--- a/drivers/fpga/dfl-afu-dma-region.c
++++ b/drivers/fpga/dfl-afu-dma-region.c
+@@ -36,7 +36,7 @@ static int afu_dma_pin_pages(struct dfl_feature_platform_data *pdata,
+ {
+ 	int npages = region->length >> PAGE_SHIFT;
+ 	struct device *dev = &pdata->dev->dev;
+-	unsigned int flags = 0;
++	unsigned int flags = FOLL_LONGTERM;
+ 	int ret, pinned;
+ 
+ 	ret = account_locked_vm(current->mm, npages, true);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0019-fpga-dfl-afu-harden-port-enable-logic.patch new/debian/patches/fpga-ofs/0019-fpga-dfl-afu-harden-port-enable-logic.patch
--- org/debian/patches/fpga-ofs/0019-fpga-dfl-afu-harden-port-enable-logic.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0019-fpga-dfl-afu-harden-port-enable-logic.patch	2021-07-20 06:17:11.352845015 +0200
@@ -0,0 +1,123 @@
+From 24d4277b16e768f12909206c6e042ae582a2c1a3 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 2 Sep 2020 14:16:13 -0700
+Subject: [PATCH 019/149] fpga: dfl: afu: harden port enable logic
+
+It is recommended that the driver poll for ACK == 0 after
+enabling the port. This change adds the recommended poll.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl-afu-error.c |  2 +-
+ drivers/fpga/dfl-afu-main.c  | 29 +++++++++++++++++++++--------
+ drivers/fpga/dfl-afu.h       |  2 +-
+ 3 files changed, 23 insertions(+), 10 deletions(-)
+
+diff --git a/drivers/fpga/dfl-afu-error.c b/drivers/fpga/dfl-afu-error.c
+index c4691187cca9..0806532a3e9f 100644
+--- a/drivers/fpga/dfl-afu-error.c
++++ b/drivers/fpga/dfl-afu-error.c
+@@ -103,7 +103,7 @@ static int afu_port_err_clear(struct device *dev, u64 err)
+ 	__afu_port_err_mask(dev, false);
+ 
+ 	/* Enable the Port by clear the reset */
+-	__afu_port_enable(pdev);
++	ret = __afu_port_enable(pdev);
+ 
+ done:
+ 	mutex_unlock(&pdata->lock);
+diff --git a/drivers/fpga/dfl-afu-main.c b/drivers/fpga/dfl-afu-main.c
+index 64fff9d6cf2e..b56d6a0ce7bd 100644
+--- a/drivers/fpga/dfl-afu-main.c
++++ b/drivers/fpga/dfl-afu-main.c
+@@ -21,6 +21,9 @@
+ 
+ #include "dfl-afu.h"
+ 
++#define RST_POLL_INVL 10 /* us */
++#define RST_POLL_TIMEOUT 1000 /* us */
++
+ /**
+  * __afu_port_enable - enable a port by clear reset
+  * @pdev: port platform device.
+@@ -32,7 +35,7 @@
+  *
+  * The caller needs to hold lock for protection.
+  */
+-void __afu_port_enable(struct platform_device *pdev)
++int __afu_port_enable(struct platform_device *pdev)
+ {
+ 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
+ 	void __iomem *base;
+@@ -41,7 +44,7 @@ void __afu_port_enable(struct platform_device *pdev)
+ 	WARN_ON(!pdata->disable_count);
+ 
+ 	if (--pdata->disable_count != 0)
+-		return;
++		return 0;
+ 
+ 	base = dfl_get_feature_ioaddr_by_id(&pdev->dev, PORT_FEATURE_ID_HEADER);
+ 
+@@ -49,10 +52,20 @@ void __afu_port_enable(struct platform_device *pdev)
+ 	v = readq(base + PORT_HDR_CTRL);
+ 	v &= ~PORT_CTRL_SFTRST;
+ 	writeq(v, base + PORT_HDR_CTRL);
+-}
+ 
+-#define RST_POLL_INVL 10 /* us */
+-#define RST_POLL_TIMEOUT 1000 /* us */
++	/*
++	 * HW clears the ack bit to indicate that the port is fully out
++	 * of reset.
++	 */
++	if (readq_poll_timeout(base + PORT_HDR_CTRL, v,
++			       !(v & PORT_CTRL_SFTRST_ACK),
++			       RST_POLL_INVL, RST_POLL_TIMEOUT)) {
++		dev_err(&pdev->dev, "timeout, failure to enable device\n");
++		return -ETIMEDOUT;
++	}
++
++	return 0;
++}
+ 
+ /**
+  * __afu_port_disable - disable a port by hold reset
+@@ -111,7 +124,7 @@ static int __port_reset(struct platform_device *pdev)
+ 
+ 	ret = __afu_port_disable(pdev);
+ 	if (!ret)
+-		__afu_port_enable(pdev);
++		ret = __afu_port_enable(pdev);
+ 
+ 	return ret;
+ }
+@@ -874,11 +887,11 @@ static int afu_dev_destroy(struct platform_device *pdev)
+ static int port_enable_set(struct platform_device *pdev, bool enable)
+ {
+ 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
+-	int ret = 0;
++	int ret;
+ 
+ 	mutex_lock(&pdata->lock);
+ 	if (enable)
+-		__afu_port_enable(pdev);
++		ret = __afu_port_enable(pdev);
+ 	else
+ 		ret = __afu_port_disable(pdev);
+ 	mutex_unlock(&pdata->lock);
+diff --git a/drivers/fpga/dfl-afu.h b/drivers/fpga/dfl-afu.h
+index 22d46e284cfc..7c297834be05 100644
+--- a/drivers/fpga/dfl-afu.h
++++ b/drivers/fpga/dfl-afu.h
+@@ -83,7 +83,7 @@ struct dfl_afu {
+ };
+ 
+ /* hold pdata->lock when call __afu_port_enable/disable */
+-void __afu_port_enable(struct platform_device *pdev);
++int __afu_port_enable(struct platform_device *pdev);
+ int __afu_port_disable(struct platform_device *pdev);
+ 
+ void afu_mmio_region_init(struct dfl_feature_platform_data *pdata);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0020-fpga-sec-mgr-fpga-security-manager-class-driver.patch new/debian/patches/fpga-ofs/0020-fpga-sec-mgr-fpga-security-manager-class-driver.patch
--- org/debian/patches/fpga-ofs/0020-fpga-sec-mgr-fpga-security-manager-class-driver.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0020-fpga-sec-mgr-fpga-security-manager-class-driver.patch	2021-07-20 06:17:11.364844981 +0200
@@ -0,0 +1,811 @@
+From cf095c3df46de7038347a8e3b99e2c6caa967a74 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:38 -0700
+Subject: [PATCH 020/149] fpga: sec-mgr: fpga security manager class driver
+
+Create the FPGA Security Manager class driver. The security
+manager provides interfaces to manage secure updates for the
+FPGA and BMC images that are stored in FLASH. The driver can
+also be used to update root entry hashes and to cancel code
+signing keys.
+
+This patch creates the class driver and provides sysfs
+interfaces for displaying root entry hashes, canceled code
+signing keys and flash counts.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+---
+ .../ABI/testing/sysfs-class-fpga-sec-mgr      |  67 +++
+ Documentation/fpga/fpga-sec-mgr.rst           |  50 ++
+ Documentation/fpga/index.rst                  |   1 +
+ MAINTAINERS                                   |   9 +
+ drivers/fpga/Kconfig                          |   9 +
+ drivers/fpga/Makefile                         |   3 +
+ drivers/fpga/fpga-sec-mgr.c                   | 487 ++++++++++++++++++
+ include/linux/fpga/fpga-sec-mgr.h             |  83 +++
+ 8 files changed, 709 insertions(+)
+ create mode 100644 Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+ create mode 100644 Documentation/fpga/fpga-sec-mgr.rst
+ create mode 100644 drivers/fpga/fpga-sec-mgr.c
+ create mode 100644 include/linux/fpga/fpga-sec-mgr.h
+
+diff --git a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+new file mode 100644
+index 000000000000..843f0b58f171
+--- /dev/null
++++ b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+@@ -0,0 +1,67 @@
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/name
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Name of low level fpga security manager driver.
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/sr_root_entry_hash
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns the root entry hash for the static
++		region if one is programmed, else it returns the
++		string: "hash not programmed".  This file is only
++		visible if the underlying device supports it.
++		Format: "0x%x".
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/pr_root_entry_hash
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns the root entry hash for the partial
++		reconfiguration region if one is programmed, else it
++		returns the string: "hash not programmed".  This file
++		is only visible if the underlying device supports it.
++		Format: "0x%x".
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/bmc_root_entry_hash
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns the root entry hash for the BMC image
++		if one is programmed, else it returns the string:
++		"hash not programmed".  This file is only visible if the
++		underlying device supports it.
++		Format: "0x%x".
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/sr_canceled_csks
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns a list of indices for canceled code
++		signing keys for the static region. The standard bitmap
++		list format is used (e.g. "1,2-6,9").
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/pr_canceled_csks
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns a list of indices for canceled code
++		signing keys for the partial reconfiguration region. The
++		standard bitmap list format is used (e.g. "1,2-6,9").
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/bmc_canceled_csks
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns a list of indices for canceled code
++		signing keys for the BMC.  The standard bitmap list format
++		is used (e.g. "1,2-6,9").
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/user_flash_count
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns number of times the user image for the
++		static region has been flashed.
++		Format: "%u".
+diff --git a/Documentation/fpga/fpga-sec-mgr.rst b/Documentation/fpga/fpga-sec-mgr.rst
+new file mode 100644
+index 000000000000..4a1d6519b1d3
+--- /dev/null
++++ b/Documentation/fpga/fpga-sec-mgr.rst
+@@ -0,0 +1,50 @@
++.. SPDX-License-Identifier: GPL-2.0
++
++========================================
++FPGA Security Manager Class Driver
++========================================
++
++The FPGA Security Manager class driver provides a common
++API for user-space tools to manage updates for secure FPGA
++devices. Device drivers that instantiate the Security
++Manager class driver will interact with a HW secure update
++engine in order to transfer new FPGA and BMC images to FLASH so
++that they will be automatically loaded when the FPGA card reboots.
++
++A significant difference between the FPGA Manager and the FPGA
++Security Manager is that the FPGA Manager does a live update (Partial
++Reconfiguration) to a device, whereas the FPGA Security Manager
++updates the FLASH images for the Static Region and the BMC so that
++they will be loaded the next time the FPGA card boots. Security is
++enforced by hardware and firmware. The security manager interacts
++with the firmware to initiate an update, pass in the necessary data,
++and collect status on the update.
++
++In addition to managing secure updates of the FPGA and BMC images,
++the FPGA Security Manager update process may also used to
++program root entry hashes and cancellation keys for the FPGA static
++region, the FPGA partial reconfiguration region, and the BMC.
++
++Secure updates make use of the request_firmware framework, which
++requires that image files are accessible under /lib/firmware. A request
++for a secure update returns immediately, while the update itself
++proceeds in the context of a kernel worker thread. Sysfs files provide
++a means for monitoring the progress of a secure update and for
++retrieving error information in the event of a failure.
++
++Sysfs Attributes
++================
++
++The API consists of two groups of sysfs attributes as described below.
++
++1. Files in the *security* sub-directory can be used to read security
++   information including: Root Entry Hashes (REH), Cancelled Code
++   Signing Keys (CSK), and the flash update count for FPGA images.
++
++2. Files in the *update* sub-directory can be used to instantiate and
++   monitor a secure update.
++
++
++See `<../ABI/testing/sysfs-class-fpga-sec-mgr>`__ for a full
++description of the sysfs attributes for the FPGA Security
++Manager.
+diff --git a/Documentation/fpga/index.rst b/Documentation/fpga/index.rst
+index 5fd3c379e1c8..4a03efc35fb9 100644
+--- a/Documentation/fpga/index.rst
++++ b/Documentation/fpga/index.rst
+@@ -9,6 +9,7 @@ fpga
+ 
+     dfl
+     dfl-n3000-nios
++    fpga-sec-mgr
+ 
+ .. only::  subproject and html
+ 
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 64d3dc5b7589..8d0bc717d377 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -6912,6 +6912,15 @@ F:	Documentation/fpga/
+ F:	drivers/fpga/
+ F:	include/linux/fpga/
+ 
++FPGA SECURITY MANAGER DRIVERS
++M:	Russ Weight <russell.h.weight@intel.com>
++L:	linux-fpga@vger.kernel.org
++S:	Maintained
++F:	Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
++F:	Documentation/fpga/fpga-sec-mgr.rst
++F:	drivers/fpga/fpga-sec-mgr.c
++F:	include/linux/fpga/fpga-sec-mgr.h
++
+ FPU EMULATOR
+ M:	Bill Metzenthen <billm@melbpc.org.au>
+ S:	Maintained
+diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
+index c72559e2fc88..3ce1baa65379 100644
+--- a/drivers/fpga/Kconfig
++++ b/drivers/fpga/Kconfig
+@@ -237,4 +237,13 @@ config FPGA_MGR_ZYNQMP_FPGA
+ 	  to configure the programmable logic(PL) through PS
+ 	  on ZynqMP SoC.
+ 
++config FPGA_SEC_MGR
++	tristate "FPGA Security Manager"
++	help
++	  The Security Manager class driver presents a common
++	  user API for managing secure updates for FPGA
++	  devices, including flash images for the FPGA static
++	  region and for the BMC. Select this option to enable
++	  updates for secure FPGA devices.
++
+ endif # FPGA
+diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
+index e07b3d5b3ee6..a1c4669eb25d 100644
+--- a/drivers/fpga/Makefile
++++ b/drivers/fpga/Makefile
+@@ -21,6 +21,9 @@ obj-$(CONFIG_FPGA_MGR_ZYNQMP_FPGA)	+= zynqmp-fpga.o
+ obj-$(CONFIG_ALTERA_PR_IP_CORE)         += altera-pr-ip-core.o
+ obj-$(CONFIG_ALTERA_PR_IP_CORE_PLAT)    += altera-pr-ip-core-plat.o
+ 
++# FPGA Security Manager Framework
++obj-$(CONFIG_FPGA_SEC_MGR)		+= fpga-sec-mgr.o
++
+ # FPGA Bridge Drivers
+ obj-$(CONFIG_FPGA_BRIDGE)		+= fpga-bridge.o
+ obj-$(CONFIG_SOCFPGA_FPGA_BRIDGE)	+= altera-hps2fpga.o altera-fpga2sdram.o
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+new file mode 100644
+index 000000000000..95b5a7ccbe44
+--- /dev/null
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -0,0 +1,487 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * FPGA Security Manager
++ *
++ * Copyright (C) 2019-2020 Intel Corporation, Inc.
++ */
++
++#include <linux/fpga/fpga-sec-mgr.h>
++#include <linux/idr.h>
++#include <linux/module.h>
++#include <linux/slab.h>
++#include <linux/vmalloc.h>
++
++static DEFINE_IDA(fpga_sec_mgr_ida);
++static struct class *fpga_sec_mgr_class;
++
++struct fpga_sec_mgr_devres {
++	struct fpga_sec_mgr *smgr;
++};
++
++#define to_sec_mgr(d) container_of(d, struct fpga_sec_mgr, dev)
++
++static ssize_t
++show_canceled_csk(struct fpga_sec_mgr *smgr,
++		  int (*get_csk)(struct fpga_sec_mgr *smgr,
++				 unsigned long *csk_map, unsigned int nbits),
++		  int (*get_csk_nbits)(struct fpga_sec_mgr *smgr),
++		  char *buf)
++{
++	unsigned long *csk_map = NULL;
++	unsigned int nbits;
++	int ret;
++
++	ret = get_csk_nbits(smgr);
++	if (ret < 0)
++		return ret;
++
++	nbits = (unsigned int)ret;
++	csk_map = vmalloc(sizeof(unsigned long) * BITS_TO_LONGS(nbits));
++	if (!csk_map)
++		return -ENOMEM;
++
++	ret = get_csk(smgr, csk_map, nbits);
++	if (ret)
++		goto vfree_exit;
++
++	ret = bitmap_print_to_pagebuf(1, buf, csk_map, nbits);
++
++vfree_exit:
++	vfree(csk_map);
++	return ret;
++}
++
++static ssize_t
++show_root_entry_hash(struct fpga_sec_mgr *smgr,
++		     int (*get_reh)(struct fpga_sec_mgr *smgr, u8 *hash,
++				    unsigned int size),
++		     int (*get_reh_size)(struct fpga_sec_mgr *smgr),
++		     char *buf)
++{
++	int size, i, cnt, ret;
++	u8 *hash;
++
++	ret = get_reh_size(smgr);
++	if (ret < 0)
++		return ret;
++	else if (!ret)
++		return sysfs_emit(buf, "hash not programmed\n");
++
++	size = ret;
++	hash = vmalloc(size);
++	if (!hash)
++		return -ENOMEM;
++
++	ret = get_reh(smgr, hash, size);
++	if (ret)
++		goto vfree_exit;
++
++	cnt = sprintf(buf, "0x");
++	for (i = 0; i < size; i++)
++		cnt += sprintf(buf + cnt, "%02x", hash[i]);
++	cnt += sprintf(buf + cnt, "\n");
++
++vfree_exit:
++	vfree(hash);
++	return ret ? : cnt;
++}
++
++#define DEVICE_ATTR_SEC_CSK(_name) \
++static ssize_t _name##_canceled_csks_show(struct device *dev, \
++					  struct device_attribute *attr, \
++					  char *buf) \
++{ \
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev); \
++	return show_canceled_csk(smgr, \
++	       smgr->sops->_name##_canceled_csks, \
++	       smgr->sops->_name##_canceled_csk_nbits, buf); \
++} \
++static DEVICE_ATTR_RO(_name##_canceled_csks)
++
++#define DEVICE_ATTR_SEC_ROOT_ENTRY_HASH(_name) \
++static ssize_t _name##_root_entry_hash_show(struct device *dev, \
++				     struct device_attribute *attr, \
++				     char *buf) \
++{ \
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev); \
++	return show_root_entry_hash(smgr, \
++	       smgr->sops->_name##_root_entry_hash, \
++	       smgr->sops->_name##_reh_size, buf); \
++} \
++static DEVICE_ATTR_RO(_name##_root_entry_hash)
++
++static ssize_t user_flash_count_show(struct device *dev,
++				     struct device_attribute *attr, char *buf)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
++	int cnt = smgr->sops->user_flash_count(smgr);
++
++	return cnt < 0 ? cnt : sysfs_emit(buf, "%u\n", cnt);
++}
++static DEVICE_ATTR_RO(user_flash_count);
++
++DEVICE_ATTR_SEC_ROOT_ENTRY_HASH(sr);
++DEVICE_ATTR_SEC_ROOT_ENTRY_HASH(pr);
++DEVICE_ATTR_SEC_ROOT_ENTRY_HASH(bmc);
++DEVICE_ATTR_SEC_CSK(sr);
++DEVICE_ATTR_SEC_CSK(pr);
++DEVICE_ATTR_SEC_CSK(bmc);
++
++static struct attribute *sec_mgr_security_attrs[] = {
++	&dev_attr_user_flash_count.attr,
++	&dev_attr_bmc_root_entry_hash.attr,
++	&dev_attr_sr_root_entry_hash.attr,
++	&dev_attr_pr_root_entry_hash.attr,
++	&dev_attr_sr_canceled_csks.attr,
++	&dev_attr_pr_canceled_csks.attr,
++	&dev_attr_bmc_canceled_csks.attr,
++	NULL,
++};
++
++#define check_attr(attribute, _name) \
++	((attribute) == &dev_attr_##_name.attr && smgr->sops->_name)
++
++static umode_t sec_mgr_visible(struct kobject *kobj,
++			       struct attribute *attr, int n)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(kobj_to_dev(kobj));
++
++	/*
++	 * Only display optional sysfs attributes if a
++	 * corresponding handler is provided
++	 */
++	if (check_attr(attr, user_flash_count) ||
++	    check_attr(attr, bmc_root_entry_hash) ||
++	    check_attr(attr, sr_root_entry_hash) ||
++	    check_attr(attr, pr_root_entry_hash) ||
++	    check_attr(attr, sr_canceled_csks) ||
++	    check_attr(attr, pr_canceled_csks) ||
++	    check_attr(attr, bmc_canceled_csks))
++		return attr->mode;
++
++	return 0;
++}
++
++static struct attribute_group sec_mgr_security_attr_group = {
++	.name = "security",
++	.attrs = sec_mgr_security_attrs,
++	.is_visible = sec_mgr_visible,
++};
++
++static ssize_t name_show(struct device *dev,
++			 struct device_attribute *attr, char *buf)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
++
++	return sysfs_emit(buf, "%s\n", smgr->name);
++}
++static DEVICE_ATTR_RO(name);
++
++static struct attribute *sec_mgr_attrs[] = {
++	&dev_attr_name.attr,
++	NULL,
++};
++
++static struct attribute_group sec_mgr_attr_group = {
++	.attrs = sec_mgr_attrs,
++};
++
++static const struct attribute_group *fpga_sec_mgr_attr_groups[] = {
++	&sec_mgr_attr_group,
++	&sec_mgr_security_attr_group,
++	NULL,
++};
++
++static bool check_sysfs_handler(struct device *dev,
++				void *sysfs_handler, void *size_handler,
++				const char *sysfs_handler_name,
++				const char *size_handler_name)
++{
++	/*
++	 * sysfs_handler and size_handler must either both be
++	 * defined or both be NULL.
++	 */
++	if (sysfs_handler && !size_handler) {
++		dev_err(dev, "%s registered without %s\n",
++			sysfs_handler_name, size_handler_name);
++		return false;
++	} else if (!sysfs_handler && size_handler) {
++		dev_err(dev, "%s registered without %s\n",
++			size_handler_name, sysfs_handler_name);
++		return false;
++	}
++	return true;
++}
++
++#define check_reh_handler(_dev, _sops, _name) \
++	check_sysfs_handler(_dev, (_sops)->_name##_root_entry_hash, \
++			    (_sops)->_name##_reh_size, \
++			    __stringify(_name##_root_entry_hash), \
++			    __stringify(_name##_reh_size))
++
++#define check_csk_handler(_dev, _sops, _name) \
++	check_sysfs_handler(_dev, (_sops)->_name##_canceled_csks, \
++			    (_sops)->_name##_canceled_csk_nbits, \
++			    __stringify(_name##_canceled_csks), \
++			    __stringify(_name##_canceled_csk_nbits))
++
++/**
++ * fpga_sec_mgr_create - create and initialize an FPGA
++ *			  security manager struct
++ *
++ * @dev:  fpga security manager device from pdev
++ * @name: fpga security manager name
++ * @sops: pointer to a structure of fpga callback functions
++ * @priv: fpga security manager private data
++ *
++ * The caller of this function is responsible for freeing the struct
++ * with ifpg_sec_mgr_free(). Using devm_fpga_sec_mgr_create() instead
++ * is recommended.
++ *
++ * Return: pointer to struct fpga_sec_mgr or NULL
++ */
++struct fpga_sec_mgr *
++fpga_sec_mgr_create(struct device *dev, const char *name,
++		    const struct fpga_sec_mgr_ops *sops, void *priv)
++{
++	struct fpga_sec_mgr *smgr;
++	int id, ret;
++
++	if (!check_reh_handler(dev, sops, bmc) ||
++	    !check_reh_handler(dev, sops, sr) ||
++	    !check_reh_handler(dev, sops, pr) ||
++	    !check_csk_handler(dev, sops, bmc) ||
++	    !check_csk_handler(dev, sops, sr) ||
++	    !check_csk_handler(dev, sops, pr)) {
++		return NULL;
++	}
++
++	if (!name || !strlen(name)) {
++		dev_err(dev, "Attempt to register with no name!\n");
++		return NULL;
++	}
++
++	smgr = kzalloc(sizeof(*smgr), GFP_KERNEL);
++	if (!smgr)
++		return NULL;
++
++	id = ida_simple_get(&fpga_sec_mgr_ida, 0, 0, GFP_KERNEL);
++	if (id < 0)
++		goto error_kfree;
++
++	mutex_init(&smgr->lock);
++
++	smgr->name = name;
++	smgr->priv = priv;
++	smgr->sops = sops;
++
++	device_initialize(&smgr->dev);
++	smgr->dev.class = fpga_sec_mgr_class;
++	smgr->dev.parent = dev;
++	smgr->dev.id = id;
++
++	ret = dev_set_name(&smgr->dev, "fpga_sec%d", id);
++	if (ret) {
++		dev_err(dev, "Failed to set device name: fpga_sec%d\n", id);
++		goto error_device;
++	}
++
++	return smgr;
++
++error_device:
++	ida_simple_remove(&fpga_sec_mgr_ida, id);
++
++error_kfree:
++	kfree(smgr);
++
++	return NULL;
++}
++EXPORT_SYMBOL_GPL(fpga_sec_mgr_create);
++
++/**
++ * fpga_sec_mgr_free - free an FPGA security manager created
++ *			with fpga_sec_mgr_create()
++ *
++ * @smgr:	FPGA security manager structure
++ */
++void fpga_sec_mgr_free(struct fpga_sec_mgr *smgr)
++{
++	ida_simple_remove(&fpga_sec_mgr_ida, smgr->dev.id);
++	kfree(smgr);
++}
++EXPORT_SYMBOL_GPL(fpga_sec_mgr_free);
++
++static void devm_fpga_sec_mgr_release(struct device *dev, void *res)
++{
++	struct fpga_sec_mgr_devres *dr = res;
++
++	fpga_sec_mgr_free(dr->smgr);
++}
++
++/**
++ * devm_fpga_sec_mgr_create - create and initialize an FPGA
++ *			       security manager struct
++ *
++ * @dev:  fpga security manager device from pdev
++ * @name: fpga security manager name
++ * @sops: pointer to a structure of fpga callback functions
++ * @priv: fpga security manager private data
++ *
++ * This function is intended for use in a FPGA Security manager
++ * driver's probe function.  After the security manager driver creates
++ * the fpga_sec_mgr struct with devm_fpga_sec_mgr_create(), it should
++ * register it with devm_fpga_sec_mgr_register().
++ * The fpga_sec_mgr struct allocated with this function will be freed
++ * automatically on driver detach.
++ *
++ * Return: pointer to struct fpga_sec_mgr or NULL
++ */
++struct fpga_sec_mgr *
++devm_fpga_sec_mgr_create(struct device *dev, const char *name,
++			 const struct fpga_sec_mgr_ops *sops, void *priv)
++{
++	struct fpga_sec_mgr_devres *dr;
++
++	dr = devres_alloc(devm_fpga_sec_mgr_release, sizeof(*dr), GFP_KERNEL);
++	if (!dr)
++		return NULL;
++
++	dr->smgr = fpga_sec_mgr_create(dev, name, sops, priv);
++	if (!dr->smgr) {
++		devres_free(dr);
++		return NULL;
++	}
++
++	devres_add(dev, dr);
++
++	return dr->smgr;
++}
++EXPORT_SYMBOL_GPL(devm_fpga_sec_mgr_create);
++
++/**
++ * fpga_sec_mgr_register - register an FPGA security manager
++ *
++ * @smgr: fpga security manager struct
++ *
++ * Return: 0 on success, negative error code otherwise.
++ */
++int fpga_sec_mgr_register(struct fpga_sec_mgr *smgr)
++{
++	int ret;
++
++	ret = device_add(&smgr->dev);
++	if (ret)
++		goto error_device;
++
++	dev_info(&smgr->dev, "%s registered\n", smgr->name);
++
++	return 0;
++
++error_device:
++	ida_simple_remove(&fpga_sec_mgr_ida, smgr->dev.id);
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(fpga_sec_mgr_register);
++
++/**
++ * fpga_sec_mgr_unregister - unregister an FPGA security manager
++ *
++ * @mgr: fpga manager struct
++ *
++ * This function is intended for use in an FPGA security manager
++ * driver's remove() function.
++ */
++void fpga_sec_mgr_unregister(struct fpga_sec_mgr *smgr)
++{
++	dev_info(&smgr->dev, "%s %s\n", __func__, smgr->name);
++
++	device_unregister(&smgr->dev);
++}
++EXPORT_SYMBOL_GPL(fpga_sec_mgr_unregister);
++
++static int fpga_sec_mgr_devres_match(struct device *dev, void *res,
++				     void *match_data)
++{
++	struct fpga_sec_mgr_devres *dr = res;
++
++	return match_data == dr->smgr;
++}
++
++static void devm_fpga_sec_mgr_unregister(struct device *dev, void *res)
++{
++	struct fpga_sec_mgr_devres *dr = res;
++
++	fpga_sec_mgr_unregister(dr->smgr);
++}
++
++/**
++ * devm_fpga_sec_mgr_register - resource managed variant of
++ *				fpga_sec_mgr_register()
++ *
++ * @dev: managing device for this FPGA security manager
++ * @smgr: fpga security manager struct
++ *
++ * This is the devres variant of fpga_sec_mgr_register() for which the
++ * unregister function will be called automatically when the managing
++ * device is detached.
++ */
++int devm_fpga_sec_mgr_register(struct device *dev, struct fpga_sec_mgr *smgr)
++{
++	struct fpga_sec_mgr_devres *dr;
++	int ret;
++
++	/*
++	 * Make sure that the struct fpga_sec_mgr * that is passed in is
++	 * managed itself.
++	 */
++	if (WARN_ON(!devres_find(dev, devm_fpga_sec_mgr_release,
++				 fpga_sec_mgr_devres_match, smgr)))
++		return -EINVAL;
++
++	dr = devres_alloc(devm_fpga_sec_mgr_unregister, sizeof(*dr), GFP_KERNEL);
++	if (!dr)
++		return -ENOMEM;
++
++	ret = fpga_sec_mgr_register(smgr);
++	if (ret) {
++		devres_free(dr);
++		return ret;
++	}
++
++	dr->smgr = smgr;
++	devres_add(dev, dr);
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(devm_fpga_sec_mgr_register);
++
++static void fpga_sec_mgr_dev_release(struct device *dev)
++{
++}
++
++static int __init fpga_sec_mgr_class_init(void)
++{
++	pr_info("FPGA Security Manager\n");
++
++	fpga_sec_mgr_class = class_create(THIS_MODULE, "fpga_sec_mgr");
++	if (IS_ERR(fpga_sec_mgr_class))
++		return PTR_ERR(fpga_sec_mgr_class);
++
++	fpga_sec_mgr_class->dev_groups = fpga_sec_mgr_attr_groups;
++	fpga_sec_mgr_class->dev_release = fpga_sec_mgr_dev_release;
++
++	return 0;
++}
++
++static void __exit fpga_sec_mgr_class_exit(void)
++{
++	class_destroy(fpga_sec_mgr_class);
++	ida_destroy(&fpga_sec_mgr_ida);
++}
++
++MODULE_DESCRIPTION("FPGA Security Manager Driver");
++MODULE_LICENSE("GPL v2");
++
++subsys_initcall(fpga_sec_mgr_class_init);
++module_exit(fpga_sec_mgr_class_exit)
+diff --git a/include/linux/fpga/fpga-sec-mgr.h b/include/linux/fpga/fpga-sec-mgr.h
+new file mode 100644
+index 000000000000..dd596c6c3748
+--- /dev/null
++++ b/include/linux/fpga/fpga-sec-mgr.h
+@@ -0,0 +1,83 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Header file for FPGA Security Manager
++ *
++ * Copyright (C) 2019-2020 Intel Corporation, Inc.
++ */
++#ifndef _LINUX_FPGA_SEC_MGR_H
++#define _LINUX_FPGA_SEC_MGR_H
++
++#include <linux/device.h>
++#include <linux/mutex.h>
++#include <linux/types.h>
++
++struct fpga_sec_mgr;
++
++/**
++ * struct fpga_sec_mgr_ops - device specific operations
++ * @user_flash_count:	    Optional: Return sysfs string output for FPGA
++ *			    image flash count
++ * @sr_root_entry_hash:	    Optional: Return sysfs string output for static
++ *			    region root entry hash
++ * @pr_root_entry_hash:	    Optional: Return sysfs string output for partial
++ *			    reconfiguration root entry hash
++ * @bmc_root_entry_hash:    Optional: Return sysfs string output for BMC
++ *			    root entry hash
++ * @sr_canceled_csks:	    Optional: Return sysfs string output for static
++ *			    region canceled keys
++ * @pr_canceled_csks:	    Optional: Return sysfs string output for partial
++ *			    reconfiguration canceled keys
++ * @bmc_canceled_csks:	    Optional: Return sysfs string output for bmc
++ *			    canceled keys
++ * @bmc_canceled_csk_nbits: Optional: Return BMC canceled csk vector bit count
++ * @sr_canceled_csk_nbits:  Optional: Return SR canceled csk vector bit count
++ * @pr_canceled_csk_nbits:  Optional: Return PR canceled csk vector bit count
++ * @bmc_reh_size:	    Optional: Return byte size for BMC root entry hash
++ * @sr_reh_size:	    Optional: Return byte size for SR root entry hash
++ * @pr_reh_size:	    Optional: Return byte size for PR root entry hash
++ */
++struct fpga_sec_mgr_ops {
++	int (*user_flash_count)(struct fpga_sec_mgr *smgr);
++	int (*bmc_root_entry_hash)(struct fpga_sec_mgr *smgr, u8 *hash,
++				   unsigned int size);
++	int (*sr_root_entry_hash)(struct fpga_sec_mgr *smgr, u8 *hash,
++				  unsigned int size);
++	int (*pr_root_entry_hash)(struct fpga_sec_mgr *smgr, u8 *hash,
++				  unsigned int size);
++	int (*bmc_canceled_csks)(struct fpga_sec_mgr *smgr,
++				 unsigned long *csk_map, unsigned int nbits);
++	int (*sr_canceled_csks)(struct fpga_sec_mgr *smgr,
++				unsigned long *csk_map, unsigned int nbits);
++	int (*pr_canceled_csks)(struct fpga_sec_mgr *smgr,
++				unsigned long *csk_map, unsigned int nbits);
++	int (*bmc_reh_size)(struct fpga_sec_mgr *smgr);
++	int (*sr_reh_size)(struct fpga_sec_mgr *smgr);
++	int (*pr_reh_size)(struct fpga_sec_mgr *smgr);
++	int (*bmc_canceled_csk_nbits)(struct fpga_sec_mgr *smgr);
++	int (*sr_canceled_csk_nbits)(struct fpga_sec_mgr *smgr);
++	int (*pr_canceled_csk_nbits)(struct fpga_sec_mgr *smgr);
++};
++
++struct fpga_sec_mgr {
++	const char *name;
++	struct device dev;
++	const struct fpga_sec_mgr_ops *sops;
++	struct mutex lock;		/* protect data structure contents */
++	void *priv;
++};
++
++struct fpga_sec_mgr *
++fpga_sec_mgr_create(struct device *dev, const char *name,
++		    const struct fpga_sec_mgr_ops *sops, void *priv);
++
++struct fpga_sec_mgr *
++devm_fpga_sec_mgr_create(struct device *dev, const char *name,
++			 const struct fpga_sec_mgr_ops *sops, void *priv);
++
++int fpga_sec_mgr_register(struct fpga_sec_mgr *smgr);
++int devm_fpga_sec_mgr_register(struct device *dev,
++			       struct fpga_sec_mgr *smgr);
++void fpga_sec_mgr_unregister(struct fpga_sec_mgr *smgr);
++void fpga_sec_mgr_free(struct fpga_sec_mgr *smgr);
++
++#endif
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0021-fpga-sec-mgr-enable-secure-updates.patch new/debian/patches/fpga-ofs/0021-fpga-sec-mgr-enable-secure-updates.patch
--- org/debian/patches/fpga-ofs/0021-fpga-sec-mgr-enable-secure-updates.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0021-fpga-sec-mgr-enable-secure-updates.patch	2021-07-20 06:17:11.364844981 +0200
@@ -0,0 +1,367 @@
+From 071d6caafef8631c29c2f11e5a1d4365677a8714 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:39 -0700
+Subject: [PATCH 021/149] fpga: sec-mgr: enable secure updates
+
+Extend the FPGA Security Manager class driver to
+include an update/filename sysfs node that can be used
+to initiate a security update.  The filename of a secure
+update file (BMC image, FPGA image, Root Entry Hash image,
+or Code Signing Key cancellation image) can be written to
+this sysfs entry to cause a secure update to occur.
+
+The write of the filename will return immediately, and the
+update will begin in the context of a kernel worker thread.
+This tool utilizes the request_firmware framework, which
+requires that the image file reside under /lib/firmware.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+---
+ .../ABI/testing/sysfs-class-fpga-sec-mgr      |  13 ++
+ drivers/fpga/fpga-sec-mgr.c                   | 164 ++++++++++++++++++
+ include/linux/fpga/fpga-sec-mgr.h             |  49 ++++++
+ 3 files changed, 226 insertions(+)
+
+diff --git a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+index 843f0b58f171..5f10496b2a54 100644
+--- a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
++++ b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+@@ -65,3 +65,16 @@ Contact:	Russ Weight <russell.h.weight@intel.com>
+ Description:	Read only. Returns number of times the user image for the
+ 		static region has been flashed.
+ 		Format: "%u".
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/filename
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Write only. Write the filename of an image
++		file to this sysfs file to initiate a secure
++		update. The file must have an appropriate header
++		which, among other things, identifies the target
++		for the update. This mechanism is used to update
++		BMC images, BMC firmware, Static Region images,
++		and Root Entry Hashes, and to cancel Code Signing
++		Keys (CSK).
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index 95b5a7ccbe44..8248b86ad098 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -5,8 +5,11 @@
+  * Copyright (C) 2019-2020 Intel Corporation, Inc.
+  */
+ 
++#include <linux/delay.h>
++#include <linux/firmware.h>
+ #include <linux/fpga/fpga-sec-mgr.h>
+ #include <linux/idr.h>
++#include <linux/kernel.h>
+ #include <linux/module.h>
+ #include <linux/slab.h>
+ #include <linux/vmalloc.h>
+@@ -18,6 +21,8 @@ struct fpga_sec_mgr_devres {
+ 	struct fpga_sec_mgr *smgr;
+ };
+ 
++#define WRITE_BLOCK_SIZE 0x4000	/* Update remaining_size every 0x4000 bytes */
++
+ #define to_sec_mgr(d) container_of(d, struct fpga_sec_mgr, dev)
+ 
+ static ssize_t
+@@ -138,6 +143,94 @@ static struct attribute *sec_mgr_security_attrs[] = {
+ 	NULL,
+ };
+ 
++static void fpga_sec_dev_error(struct fpga_sec_mgr *smgr,
++			       enum fpga_sec_err err_code)
++{
++	smgr->err_code = err_code;
++	smgr->sops->cancel(smgr);
++}
++
++static void progress_complete(struct fpga_sec_mgr *smgr)
++{
++	mutex_lock(&smgr->lock);
++	smgr->progress = FPGA_SEC_PROG_IDLE;
++	complete_all(&smgr->update_done);
++	mutex_unlock(&smgr->lock);
++}
++
++static void fpga_sec_mgr_update(struct work_struct *work)
++{
++	u32 size, blk_size, offset = 0;
++	struct fpga_sec_mgr *smgr;
++	const struct firmware *fw;
++	enum fpga_sec_err ret;
++
++	smgr = container_of(work, struct fpga_sec_mgr, work);
++
++	get_device(&smgr->dev);
++	if (request_firmware(&fw, smgr->filename, &smgr->dev)) {
++		smgr->err_code = FPGA_SEC_ERR_FILE_READ;
++		goto idle_exit;
++	}
++
++	smgr->data = fw->data;
++	smgr->remaining_size = fw->size;
++
++	if (!try_module_get(smgr->dev.parent->driver->owner)) {
++		smgr->err_code = FPGA_SEC_ERR_BUSY;
++		goto release_fw_exit;
++	}
++
++	smgr->progress = FPGA_SEC_PROG_PREPARING;
++	ret = smgr->sops->prepare(smgr);
++	if (ret != FPGA_SEC_ERR_NONE) {
++		fpga_sec_dev_error(smgr, ret);
++		goto modput_exit;
++	}
++
++	smgr->progress = FPGA_SEC_PROG_WRITING;
++	size = smgr->remaining_size;
++	while (size) {
++		blk_size = min_t(u32, size, WRITE_BLOCK_SIZE);
++		size -= blk_size;
++		ret = smgr->sops->write_blk(smgr, offset, blk_size);
++		if (ret != FPGA_SEC_ERR_NONE) {
++			fpga_sec_dev_error(smgr, ret);
++			goto done;
++		}
++
++		smgr->remaining_size = size;
++		offset += blk_size;
++	}
++
++	smgr->progress = FPGA_SEC_PROG_PROGRAMMING;
++	ret = smgr->sops->poll_complete(smgr);
++	if (ret != FPGA_SEC_ERR_NONE)
++		fpga_sec_dev_error(smgr, ret);
++
++done:
++	if (smgr->sops->cleanup)
++		smgr->sops->cleanup(smgr);
++
++modput_exit:
++	module_put(smgr->dev.parent->driver->owner);
++
++release_fw_exit:
++	smgr->data = NULL;
++	release_firmware(fw);
++
++idle_exit:
++	/*
++	 * Note: smgr->remaining_size is left unmodified here to
++	 * provide additional information on errors. It will be
++	 * reinitialized when the next secure update begins.
++	 */
++	kfree(smgr->filename);
++	smgr->filename = NULL;
++	put_device(&smgr->dev);
++	progress_complete(smgr);
++}
++
+ #define check_attr(attribute, _name) \
+ 	((attribute) == &dev_attr_##_name.attr && smgr->sops->_name)
+ 
+@@ -168,6 +261,48 @@ static struct attribute_group sec_mgr_security_attr_group = {
+ 	.is_visible = sec_mgr_visible,
+ };
+ 
++static ssize_t filename_store(struct device *dev, struct device_attribute *attr,
++			      const char *buf, size_t count)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
++	int ret = count;
++
++	if (count == 0 || count >= PATH_MAX)
++		return -EINVAL;
++
++	mutex_lock(&smgr->lock);
++	if (smgr->driver_unload || smgr->progress != FPGA_SEC_PROG_IDLE) {
++		ret = -EBUSY;
++		goto unlock_exit;
++	}
++
++	smgr->filename = kstrndup(buf, count - 1, GFP_KERNEL);
++	if (!smgr->filename) {
++		ret = -ENOMEM;
++		goto unlock_exit;
++	}
++
++	smgr->err_code = FPGA_SEC_ERR_NONE;
++	smgr->progress = FPGA_SEC_PROG_READING;
++	reinit_completion(&smgr->update_done);
++	schedule_work(&smgr->work);
++
++unlock_exit:
++	mutex_unlock(&smgr->lock);
++	return ret;
++}
++static DEVICE_ATTR_WO(filename);
++
++static struct attribute *sec_mgr_update_attrs[] = {
++	&dev_attr_filename.attr,
++	NULL,
++};
++
++static struct attribute_group sec_mgr_update_attr_group = {
++	.name = "update",
++	.attrs = sec_mgr_update_attrs,
++};
++
+ static ssize_t name_show(struct device *dev,
+ 			 struct device_attribute *attr, char *buf)
+ {
+@@ -189,6 +324,7 @@ static struct attribute_group sec_mgr_attr_group = {
+ static const struct attribute_group *fpga_sec_mgr_attr_groups[] = {
+ 	&sec_mgr_attr_group,
+ 	&sec_mgr_security_attr_group,
++	&sec_mgr_update_attr_group,
+ 	NULL,
+ };
+ 
+@@ -247,6 +383,12 @@ fpga_sec_mgr_create(struct device *dev, const char *name,
+ 	struct fpga_sec_mgr *smgr;
+ 	int id, ret;
+ 
++	if (!sops || !sops->cancel || !sops->prepare ||
++	    !sops->write_blk || !sops->poll_complete) {
++		dev_err(dev, "Attempt to register without required ops\n");
++		return NULL;
++	}
++
+ 	if (!check_reh_handler(dev, sops, bmc) ||
+ 	    !check_reh_handler(dev, sops, sr) ||
+ 	    !check_reh_handler(dev, sops, pr) ||
+@@ -274,6 +416,8 @@ fpga_sec_mgr_create(struct device *dev, const char *name,
+ 	smgr->name = name;
+ 	smgr->priv = priv;
+ 	smgr->sops = sops;
++	init_completion(&smgr->update_done);
++	INIT_WORK(&smgr->work, fpga_sec_mgr_update);
+ 
+ 	device_initialize(&smgr->dev);
+ 	smgr->dev.class = fpga_sec_mgr_class;
+@@ -391,11 +535,31 @@ EXPORT_SYMBOL_GPL(fpga_sec_mgr_register);
+  *
+  * This function is intended for use in an FPGA security manager
+  * driver's remove() function.
++ *
++ * For some devices, once the secure update has begun authentication
++ * the hardware cannot be signaled to stop, and the driver will not
++ * exit until the hardware signals completion.  This could be 30+
++ * minutes of waiting. The driver_unload flag enableds a force-unload
++ * of the driver (e.g. modprobe -r) by signaling the parent driver to
++ * exit even if the hardware update is incomplete. The driver_unload
++ * flag also prevents new updates from starting once the unregister
++ * process has begun.
+  */
+ void fpga_sec_mgr_unregister(struct fpga_sec_mgr *smgr)
+ {
+ 	dev_info(&smgr->dev, "%s %s\n", __func__, smgr->name);
+ 
++	mutex_lock(&smgr->lock);
++	smgr->driver_unload = true;
++	if (smgr->progress == FPGA_SEC_PROG_IDLE) {
++		mutex_unlock(&smgr->lock);
++		goto unregister;
++	}
++
++	mutex_unlock(&smgr->lock);
++	wait_for_completion(&smgr->update_done);
++
++unregister:
+ 	device_unregister(&smgr->dev);
+ }
+ EXPORT_SYMBOL_GPL(fpga_sec_mgr_unregister);
+diff --git a/include/linux/fpga/fpga-sec-mgr.h b/include/linux/fpga/fpga-sec-mgr.h
+index dd596c6c3748..d2e482456d16 100644
+--- a/include/linux/fpga/fpga-sec-mgr.h
++++ b/include/linux/fpga/fpga-sec-mgr.h
+@@ -7,12 +7,26 @@
+ #ifndef _LINUX_FPGA_SEC_MGR_H
+ #define _LINUX_FPGA_SEC_MGR_H
+ 
++#include <linux/completion.h>
+ #include <linux/device.h>
+ #include <linux/mutex.h>
+ #include <linux/types.h>
+ 
+ struct fpga_sec_mgr;
+ 
++enum fpga_sec_err {
++	FPGA_SEC_ERR_NONE,
++	FPGA_SEC_ERR_HW_ERROR,
++	FPGA_SEC_ERR_TIMEOUT,
++	FPGA_SEC_ERR_CANCELED,
++	FPGA_SEC_ERR_BUSY,
++	FPGA_SEC_ERR_INVALID_SIZE,
++	FPGA_SEC_ERR_RW_ERROR,
++	FPGA_SEC_ERR_WEAROUT,
++	FPGA_SEC_ERR_FILE_READ,
++	FPGA_SEC_ERR_MAX
++};
++
+ /**
+  * struct fpga_sec_mgr_ops - device specific operations
+  * @user_flash_count:	    Optional: Return sysfs string output for FPGA
+@@ -35,6 +49,17 @@ struct fpga_sec_mgr;
+  * @bmc_reh_size:	    Optional: Return byte size for BMC root entry hash
+  * @sr_reh_size:	    Optional: Return byte size for SR root entry hash
+  * @pr_reh_size:	    Optional: Return byte size for PR root entry hash
++ * @prepare:		    Required: Prepare secure update
++ * @write_blk:		    Required: Write a block of data
++ * @poll_complete:	    Required: Check for the completion of the
++ *			    HW authentication/programming process. This
++ *			    function should check for smgr->driver_unload
++ *			    and abort with FPGA_SEC_ERR_CANCELED when true.
++ * @cancel:		    Required: Signal HW to cancel update
++ * @cleanup:		    Optional: Complements the prepare()
++ *			    function and is called at the completion
++ *			    of the update, whether success or failure,
++ *			    if the prepare function succeeded.
+  */
+ struct fpga_sec_mgr_ops {
+ 	int (*user_flash_count)(struct fpga_sec_mgr *smgr);
+@@ -56,6 +81,22 @@ struct fpga_sec_mgr_ops {
+ 	int (*bmc_canceled_csk_nbits)(struct fpga_sec_mgr *smgr);
+ 	int (*sr_canceled_csk_nbits)(struct fpga_sec_mgr *smgr);
+ 	int (*pr_canceled_csk_nbits)(struct fpga_sec_mgr *smgr);
++	enum fpga_sec_err (*prepare)(struct fpga_sec_mgr *smgr);
++	enum fpga_sec_err (*write_blk)(struct fpga_sec_mgr *smgr,
++				       u32 offset, u32 size);
++	enum fpga_sec_err (*poll_complete)(struct fpga_sec_mgr *smgr);
++	void (*cleanup)(struct fpga_sec_mgr *smgr);
++	enum fpga_sec_err (*cancel)(struct fpga_sec_mgr *smgr);
++};
++
++/* Update progress codes */
++enum fpga_sec_prog {
++	FPGA_SEC_PROG_IDLE,
++	FPGA_SEC_PROG_READING,
++	FPGA_SEC_PROG_PREPARING,
++	FPGA_SEC_PROG_WRITING,
++	FPGA_SEC_PROG_PROGRAMMING,
++	FPGA_SEC_PROG_MAX
+ };
+ 
+ struct fpga_sec_mgr {
+@@ -63,6 +104,14 @@ struct fpga_sec_mgr {
+ 	struct device dev;
+ 	const struct fpga_sec_mgr_ops *sops;
+ 	struct mutex lock;		/* protect data structure contents */
++	struct work_struct work;
++	struct completion update_done;
++	char *filename;
++	const u8 *data;			/* pointer to update data */
++	u32 remaining_size;		/* size remaining to transfer */
++	enum fpga_sec_prog progress;
++	enum fpga_sec_err err_code;	/* security manager error code */
++	bool driver_unload;
+ 	void *priv;
+ };
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0022-fpga-sec-mgr-expose-sec-mgr-update-status.patch new/debian/patches/fpga-ofs/0022-fpga-sec-mgr-expose-sec-mgr-update-status.patch
--- org/debian/patches/fpga-ofs/0022-fpga-sec-mgr-expose-sec-mgr-update-status.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0022-fpga-sec-mgr-expose-sec-mgr-update-status.patch	2021-07-20 06:17:11.364844981 +0200
@@ -0,0 +1,134 @@
+From 5156e34682158946bd47ec9b1082531b71a4216d Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:40 -0700
+Subject: [PATCH 022/149] fpga: sec-mgr: expose sec-mgr update status
+
+Extend the FPGA Security Manager class driver to
+include an update/status sysfs node that can be polled
+and read to monitor the progress of an ongoing secure
+update. Sysfs_notify() is used to signal transitions
+between different phases of the update process.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+---
+ .../ABI/testing/sysfs-class-fpga-sec-mgr      | 11 +++++
+ drivers/fpga/fpga-sec-mgr.c                   | 42 +++++++++++++++++--
+ 2 files changed, 49 insertions(+), 4 deletions(-)
+
+diff --git a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+index 5f10496b2a54..69b4cf7e1cd4 100644
+--- a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
++++ b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+@@ -78,3 +78,14 @@ Description:	Write only. Write the filename of an image
+ 		BMC images, BMC firmware, Static Region images,
+ 		and Root Entry Hashes, and to cancel Code Signing
+ 		Keys (CSK).
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/status
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read-only. Returns a string describing the current
++		status of an update. The string will be one of the
++		following: idle, reading, preparing, writing,
++		programming. Userspace code can poll on this file,
++		as it will be signaled by sysfs_notify() on each
++		state change.
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index 8248b86ad098..65b89248bd85 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -143,6 +143,13 @@ static struct attribute *sec_mgr_security_attrs[] = {
+ 	NULL,
+ };
+ 
++static void update_progress(struct fpga_sec_mgr *smgr,
++			    enum fpga_sec_prog new_progress)
++{
++	smgr->progress = new_progress;
++	sysfs_notify(&smgr->dev.kobj, "update", "status");
++}
++
+ static void fpga_sec_dev_error(struct fpga_sec_mgr *smgr,
+ 			       enum fpga_sec_err err_code)
+ {
+@@ -153,7 +160,7 @@ static void fpga_sec_dev_error(struct fpga_sec_mgr *smgr,
+ static void progress_complete(struct fpga_sec_mgr *smgr)
+ {
+ 	mutex_lock(&smgr->lock);
+-	smgr->progress = FPGA_SEC_PROG_IDLE;
++	update_progress(smgr, FPGA_SEC_PROG_IDLE);
+ 	complete_all(&smgr->update_done);
+ 	mutex_unlock(&smgr->lock);
+ }
+@@ -181,14 +188,14 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ 		goto release_fw_exit;
+ 	}
+ 
+-	smgr->progress = FPGA_SEC_PROG_PREPARING;
++	update_progress(smgr, FPGA_SEC_PROG_PREPARING);
+ 	ret = smgr->sops->prepare(smgr);
+ 	if (ret != FPGA_SEC_ERR_NONE) {
+ 		fpga_sec_dev_error(smgr, ret);
+ 		goto modput_exit;
+ 	}
+ 
+-	smgr->progress = FPGA_SEC_PROG_WRITING;
++	update_progress(smgr, FPGA_SEC_PROG_WRITING);
+ 	size = smgr->remaining_size;
+ 	while (size) {
+ 		blk_size = min_t(u32, size, WRITE_BLOCK_SIZE);
+@@ -203,7 +210,7 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ 		offset += blk_size;
+ 	}
+ 
+-	smgr->progress = FPGA_SEC_PROG_PROGRAMMING;
++	update_progress(smgr, FPGA_SEC_PROG_PROGRAMMING);
+ 	ret = smgr->sops->poll_complete(smgr);
+ 	if (ret != FPGA_SEC_ERR_NONE)
+ 		fpga_sec_dev_error(smgr, ret);
+@@ -261,6 +268,32 @@ static struct attribute_group sec_mgr_security_attr_group = {
+ 	.is_visible = sec_mgr_visible,
+ };
+ 
++static const char * const sec_mgr_prog_str[] = {
++	"idle",			/* FPGA_SEC_PROG_IDLE */
++	"reading",		/* FPGA_SEC_PROG_READING */
++	"preparing",		/* FPGA_SEC_PROG_PREPARING */
++	"writing",		/* FPGA_SEC_PROG_WRITING */
++	"programming"		/* FPGA_SEC_PROG_PROGRAMMING */
++};
++
++static ssize_t
++status_show(struct device *dev, struct device_attribute *attr, char *buf)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
++	const char *status = "unknown-status";
++	enum fpga_sec_prog progress;
++
++	progress = smgr->progress;
++	if (progress < FPGA_SEC_PROG_MAX)
++		status = sec_mgr_prog_str[progress];
++	else
++		dev_err(dev, "Invalid status during secure update: %d\n",
++			progress);
++
++	return sysfs_emit(buf, "%s\n", status);
++}
++static DEVICE_ATTR_RO(status);
++
+ static ssize_t filename_store(struct device *dev, struct device_attribute *attr,
+ 			      const char *buf, size_t count)
+ {
+@@ -295,6 +328,7 @@ static DEVICE_ATTR_WO(filename);
+ 
+ static struct attribute *sec_mgr_update_attrs[] = {
+ 	&dev_attr_filename.attr,
++	&dev_attr_status.attr,
+ 	NULL,
+ };
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0023-fpga-sec-mgr-expose-sec-mgr-update-errors.patch new/debian/patches/fpga-ofs/0023-fpga-sec-mgr-expose-sec-mgr-update-errors.patch
--- org/debian/patches/fpga-ofs/0023-fpga-sec-mgr-expose-sec-mgr-update-errors.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0023-fpga-sec-mgr-expose-sec-mgr-update-errors.patch	2021-07-20 06:17:11.364844981 +0200
@@ -0,0 +1,191 @@
+From 1f5ca26070ed3e2da69ccf32f9bf115900e36358 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:41 -0700
+Subject: [PATCH 023/149] fpga: sec-mgr: expose sec-mgr update errors
+
+Extend the FPGA Security Manager class driver to include
+an update/error sysfs node that can be read for error
+information when a secure update fails.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+---
+ .../ABI/testing/sysfs-class-fpga-sec-mgr      | 17 ++++
+ drivers/fpga/fpga-sec-mgr.c                   | 83 ++++++++++++++++---
+ include/linux/fpga/fpga-sec-mgr.h             |  1 +
+ 3 files changed, 89 insertions(+), 12 deletions(-)
+
+diff --git a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+index 69b4cf7e1cd4..560513653c70 100644
+--- a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
++++ b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+@@ -89,3 +89,20 @@ Description:	Read-only. Returns a string describing the current
+ 		programming. Userspace code can poll on this file,
+ 		as it will be signaled by sysfs_notify() on each
+ 		state change.
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/error
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read-only. Returns a string describing the failure
++		of a secure update. This string will be in the form
++		of <STATUS>:<ERROR>, where <STATUS> will be one of
++		the status strings described for the status sysfs
++		file and <ERROR> will be one of the following:
++		hw-error, timeout, user-abort, device-busy,
++		invalid-file-size, read-write-error, flash-wearout,
++		file-read-error.  The error sysfs file is only
++		meaningful when the secure update engine is in the
++		idle state. If this file is read while a secure
++		update is in progress, then the read will fail with
++		EBUSY.
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index 65b89248bd85..54f3713ba64c 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -150,10 +150,16 @@ static void update_progress(struct fpga_sec_mgr *smgr,
+ 	sysfs_notify(&smgr->dev.kobj, "update", "status");
+ }
+ 
++static void set_error(struct fpga_sec_mgr *smgr, enum fpga_sec_err err_code)
++{
++	smgr->err_state = smgr->progress;
++	smgr->err_code = err_code;
++}
++
+ static void fpga_sec_dev_error(struct fpga_sec_mgr *smgr,
+ 			       enum fpga_sec_err err_code)
+ {
+-	smgr->err_code = err_code;
++	set_error(smgr, err_code);
+ 	smgr->sops->cancel(smgr);
+ }
+ 
+@@ -176,7 +182,7 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ 
+ 	get_device(&smgr->dev);
+ 	if (request_firmware(&fw, smgr->filename, &smgr->dev)) {
+-		smgr->err_code = FPGA_SEC_ERR_FILE_READ;
++		set_error(smgr, FPGA_SEC_ERR_FILE_READ);
+ 		goto idle_exit;
+ 	}
+ 
+@@ -184,7 +190,7 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ 	smgr->remaining_size = fw->size;
+ 
+ 	if (!try_module_get(smgr->dev.parent->driver->owner)) {
+-		smgr->err_code = FPGA_SEC_ERR_BUSY;
++		set_error(smgr, FPGA_SEC_ERR_BUSY);
+ 		goto release_fw_exit;
+ 	}
+ 
+@@ -276,24 +282,76 @@ static const char * const sec_mgr_prog_str[] = {
+ 	"programming"		/* FPGA_SEC_PROG_PROGRAMMING */
+ };
+ 
+-static ssize_t
+-status_show(struct device *dev, struct device_attribute *attr, char *buf)
++static const char * const sec_mgr_err_str[] = {
++	"none",			/* FPGA_SEC_ERR_NONE */
++	"hw-error",		/* FPGA_SEC_ERR_HW_ERROR */
++	"timeout",		/* FPGA_SEC_ERR_TIMEOUT */
++	"user-abort",		/* FPGA_SEC_ERR_CANCELED */
++	"device-busy",		/* FPGA_SEC_ERR_BUSY */
++	"invalid-file-size",	/* FPGA_SEC_ERR_INVALID_SIZE */
++	"read-write-error",	/* FPGA_SEC_ERR_RW_ERROR */
++	"flash-wearout",	/* FPGA_SEC_ERR_WEAROUT */
++	"file-read-error"	/* FPGA_SEC_ERR_FILE_READ */
++};
++
++static const char *sec_progress(struct device *dev, enum fpga_sec_prog prog)
+ {
+-	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
+ 	const char *status = "unknown-status";
+-	enum fpga_sec_prog progress;
+ 
+-	progress = smgr->progress;
+-	if (progress < FPGA_SEC_PROG_MAX)
+-		status = sec_mgr_prog_str[progress];
++	if (prog < FPGA_SEC_PROG_MAX)
++		status = sec_mgr_prog_str[prog];
+ 	else
+ 		dev_err(dev, "Invalid status during secure update: %d\n",
+-			progress);
++			prog);
++
++	return status;
++}
++
++static const char *sec_error(struct device *dev, enum fpga_sec_err err_code)
++{
++	const char *error = "unknown-error";
++
++	if (err_code < FPGA_SEC_ERR_MAX)
++		error = sec_mgr_err_str[err_code];
++	else
++		dev_err(dev, "Invalid error code during secure update: %d\n",
++			err_code);
++
++	return error;
++}
++
++static ssize_t
++status_show(struct device *dev, struct device_attribute *attr, char *buf)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
+ 
+-	return sysfs_emit(buf, "%s\n", status);
++	return sysfs_emit(buf, "%s\n", sec_progress(dev, smgr->progress));
+ }
+ static DEVICE_ATTR_RO(status);
+ 
++static ssize_t
++error_show(struct device *dev, struct device_attribute *attr, char *buf)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
++	int ret;
++
++	mutex_lock(&smgr->lock);
++
++	if (smgr->progress != FPGA_SEC_PROG_IDLE)
++		ret = -EBUSY;
++	else if (!smgr->err_code)
++		ret = 0;
++	else
++		ret = sysfs_emit(buf, "%s:%s\n",
++				 sec_progress(dev, smgr->err_state),
++				 sec_error(dev, smgr->err_code));
++
++	mutex_unlock(&smgr->lock);
++
++	return ret;
++}
++static DEVICE_ATTR_RO(error);
++
+ static ssize_t filename_store(struct device *dev, struct device_attribute *attr,
+ 			      const char *buf, size_t count)
+ {
+@@ -329,6 +387,7 @@ static DEVICE_ATTR_WO(filename);
+ static struct attribute *sec_mgr_update_attrs[] = {
+ 	&dev_attr_filename.attr,
+ 	&dev_attr_status.attr,
++	&dev_attr_error.attr,
+ 	NULL,
+ };
+ 
+diff --git a/include/linux/fpga/fpga-sec-mgr.h b/include/linux/fpga/fpga-sec-mgr.h
+index d2e482456d16..ee4230c9830d 100644
+--- a/include/linux/fpga/fpga-sec-mgr.h
++++ b/include/linux/fpga/fpga-sec-mgr.h
+@@ -110,6 +110,7 @@ struct fpga_sec_mgr {
+ 	const u8 *data;			/* pointer to update data */
+ 	u32 remaining_size;		/* size remaining to transfer */
+ 	enum fpga_sec_prog progress;
++	enum fpga_sec_prog err_state;	/* progress state at time of failure */
+ 	enum fpga_sec_err err_code;	/* security manager error code */
+ 	bool driver_unload;
+ 	void *priv;
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0024-fpga-sec-mgr-expose-sec-mgr-update-size.patch new/debian/patches/fpga-ofs/0024-fpga-sec-mgr-expose-sec-mgr-update-size.patch
--- org/debian/patches/fpga-ofs/0024-fpga-sec-mgr-expose-sec-mgr-update-size.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0024-fpga-sec-mgr-expose-sec-mgr-update-size.patch	2021-07-20 06:17:11.368844970 +0200
@@ -0,0 +1,71 @@
+From 9cfa8a940efc9c85e563d40fe20c1cf70d75ee1d Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:42 -0700
+Subject: [PATCH 024/149] fpga: sec-mgr: expose sec-mgr update size
+
+Extend the FPGA Security Manager class driver to include
+an update/remaining_size sysfs node that can be read to
+determine how much data remains to be transferred to the
+secure update engine. This file can be used to monitor
+progress during the "writing" phase of an update.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+---
+ Documentation/ABI/testing/sysfs-class-fpga-sec-mgr | 11 +++++++++++
+ drivers/fpga/fpga-sec-mgr.c                        | 10 ++++++++++
+ 2 files changed, 21 insertions(+)
+
+diff --git a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+index 560513653c70..61432a3a06a2 100644
+--- a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
++++ b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+@@ -90,6 +90,17 @@ Description:	Read-only. Returns a string describing the current
+ 		as it will be signaled by sysfs_notify() on each
+ 		state change.
+ 
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/remaining_size
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read-only. Returns the size of data that remains to
++		be written to the secure update engine. The size
++		value is initialized to the full size of the file
++		image and the value is updated periodically during
++		the "writing" phase of the update.
++		Format: "%u".
++
+ What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/error
+ Date:		Oct 2020
+ KernelVersion:  5.11
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index 54f3713ba64c..f380c4385929 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -352,6 +352,15 @@ error_show(struct device *dev, struct device_attribute *attr, char *buf)
+ }
+ static DEVICE_ATTR_RO(error);
+ 
++static ssize_t remaining_size_show(struct device *dev,
++				   struct device_attribute *attr, char *buf)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
++
++	return sysfs_emit(buf, "%u\n", smgr->remaining_size);
++}
++static DEVICE_ATTR_RO(remaining_size);
++
+ static ssize_t filename_store(struct device *dev, struct device_attribute *attr,
+ 			      const char *buf, size_t count)
+ {
+@@ -388,6 +397,7 @@ static struct attribute *sec_mgr_update_attrs[] = {
+ 	&dev_attr_filename.attr,
+ 	&dev_attr_status.attr,
+ 	&dev_attr_error.attr,
++	&dev_attr_remaining_size.attr,
+ 	NULL,
+ };
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0025-fpga-sec-mgr-enable-cancel-of-secure-update.patch new/debian/patches/fpga-ofs/0025-fpga-sec-mgr-enable-cancel-of-secure-update.patch
--- org/debian/patches/fpga-ofs/0025-fpga-sec-mgr-enable-cancel-of-secure-update.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0025-fpga-sec-mgr-enable-cancel-of-secure-update.patch	2021-07-20 06:17:11.368844970 +0200
@@ -0,0 +1,170 @@
+From ace2c82a036a7d59a00ea90f9d03ad185bb74ad4 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:43 -0700
+Subject: [PATCH 025/149] fpga: sec-mgr: enable cancel of secure update
+
+Extend the FPGA Security Manager class driver to include
+an update/cancel sysfs file that can be written to request
+that an update be canceled. The write may return EBUSY if
+the update has progressed to the point that it cannot be
+canceled by software or ENODEV if there is no update in
+progress.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+---
+ .../ABI/testing/sysfs-class-fpga-sec-mgr      | 10 ++++
+ drivers/fpga/fpga-sec-mgr.c                   | 59 +++++++++++++++++--
+ include/linux/fpga/fpga-sec-mgr.h             |  1 +
+ 3 files changed, 66 insertions(+), 4 deletions(-)
+
+diff --git a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+index 61432a3a06a2..814271aede05 100644
+--- a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
++++ b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+@@ -79,6 +79,16 @@ Description:	Write only. Write the filename of an image
+ 		and Root Entry Hashes, and to cancel Code Signing
+ 		Keys (CSK).
+ 
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/cancel
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Write-only. Write a "1" to this file to request
++		that a current update be canceled. This request
++		will be rejected (EBUSY) if the programming phase
++		has already started or (ENODEV) if there is no
++		update in progress.
++
+ What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/status
+ Date:		Oct 2020
+ KernelVersion:  5.11
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index f380c4385929..9ec7092e9ede 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -163,6 +163,23 @@ static void fpga_sec_dev_error(struct fpga_sec_mgr *smgr,
+ 	smgr->sops->cancel(smgr);
+ }
+ 
++static int progress_transition(struct fpga_sec_mgr *smgr,
++			       enum fpga_sec_prog new_progress)
++{
++	int ret = 0;
++
++	mutex_lock(&smgr->lock);
++	if (smgr->request_cancel) {
++		set_error(smgr, FPGA_SEC_ERR_CANCELED);
++		smgr->sops->cancel(smgr);
++		ret = -ECANCELED;
++	} else {
++		update_progress(smgr, new_progress);
++	}
++	mutex_unlock(&smgr->lock);
++	return ret;
++}
++
+ static void progress_complete(struct fpga_sec_mgr *smgr)
+ {
+ 	mutex_lock(&smgr->lock);
+@@ -194,16 +211,20 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ 		goto release_fw_exit;
+ 	}
+ 
+-	update_progress(smgr, FPGA_SEC_PROG_PREPARING);
++	if (progress_transition(smgr, FPGA_SEC_PROG_PREPARING))
++		goto modput_exit;
++
+ 	ret = smgr->sops->prepare(smgr);
+ 	if (ret != FPGA_SEC_ERR_NONE) {
+ 		fpga_sec_dev_error(smgr, ret);
+ 		goto modput_exit;
+ 	}
+ 
+-	update_progress(smgr, FPGA_SEC_PROG_WRITING);
++	if (progress_transition(smgr, FPGA_SEC_PROG_WRITING))
++		goto done;
++
+ 	size = smgr->remaining_size;
+-	while (size) {
++	while (size && !smgr->request_cancel) {
+ 		blk_size = min_t(u32, size, WRITE_BLOCK_SIZE);
+ 		size -= blk_size;
+ 		ret = smgr->sops->write_blk(smgr, offset, blk_size);
+@@ -216,7 +237,9 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ 		offset += blk_size;
+ 	}
+ 
+-	update_progress(smgr, FPGA_SEC_PROG_PROGRAMMING);
++	if (progress_transition(smgr, FPGA_SEC_PROG_PROGRAMMING))
++		goto done;
++
+ 	ret = smgr->sops->poll_complete(smgr);
+ 	if (ret != FPGA_SEC_ERR_NONE)
+ 		fpga_sec_dev_error(smgr, ret);
+@@ -383,6 +406,7 @@ static ssize_t filename_store(struct device *dev, struct device_attribute *attr,
+ 	}
+ 
+ 	smgr->err_code = FPGA_SEC_ERR_NONE;
++	smgr->request_cancel = false;
+ 	smgr->progress = FPGA_SEC_PROG_READING;
+ 	reinit_completion(&smgr->update_done);
+ 	schedule_work(&smgr->work);
+@@ -393,8 +417,32 @@ static ssize_t filename_store(struct device *dev, struct device_attribute *attr,
+ }
+ static DEVICE_ATTR_WO(filename);
+ 
++static ssize_t cancel_store(struct device *dev, struct device_attribute *attr,
++			    const char *buf, size_t count)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
++	bool cancel;
++	int ret = count;
++
++	if (kstrtobool(buf, &cancel) || !cancel)
++		return -EINVAL;
++
++	mutex_lock(&smgr->lock);
++	if (smgr->progress == FPGA_SEC_PROG_PROGRAMMING)
++		ret = -EBUSY;
++	else if (smgr->progress == FPGA_SEC_PROG_IDLE)
++		ret = -ENODEV;
++	else
++		smgr->request_cancel = true;
++	mutex_unlock(&smgr->lock);
++
++	return ret;
++}
++static DEVICE_ATTR_WO(cancel);
++
+ static struct attribute *sec_mgr_update_attrs[] = {
+ 	&dev_attr_filename.attr,
++	&dev_attr_cancel.attr,
+ 	&dev_attr_status.attr,
+ 	&dev_attr_error.attr,
+ 	&dev_attr_remaining_size.attr,
+@@ -659,6 +707,9 @@ void fpga_sec_mgr_unregister(struct fpga_sec_mgr *smgr)
+ 		goto unregister;
+ 	}
+ 
++	if (smgr->progress != FPGA_SEC_PROG_PROGRAMMING)
++		smgr->request_cancel = true;
++
+ 	mutex_unlock(&smgr->lock);
+ 	wait_for_completion(&smgr->update_done);
+ 
+diff --git a/include/linux/fpga/fpga-sec-mgr.h b/include/linux/fpga/fpga-sec-mgr.h
+index ee4230c9830d..c6906c6d1d41 100644
+--- a/include/linux/fpga/fpga-sec-mgr.h
++++ b/include/linux/fpga/fpga-sec-mgr.h
+@@ -112,6 +112,7 @@ struct fpga_sec_mgr {
+ 	enum fpga_sec_prog progress;
+ 	enum fpga_sec_prog err_state;	/* progress state at time of failure */
+ 	enum fpga_sec_err err_code;	/* security manager error code */
++	bool request_cancel;
+ 	bool driver_unload;
+ 	void *priv;
+ };
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0026-fpga-sec-mgr-expose-hardware-error-info.patch new/debian/patches/fpga-ofs/0026-fpga-sec-mgr-expose-hardware-error-info.patch
--- org/debian/patches/fpga-ofs/0026-fpga-sec-mgr-expose-hardware-error-info.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0026-fpga-sec-mgr-expose-hardware-error-info.patch	2021-07-20 06:17:11.368844970 +0200
@@ -0,0 +1,164 @@
+From a41e98aac4d94b230f2c28e47986a7e108fb70ca Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:44 -0700
+Subject: [PATCH 026/149] fpga: sec-mgr: expose hardware error info
+
+Extend the FPGA Security Manager class driver to include
+an optional update/hw_errinfo sysfs node that can be used
+to retrieve 64 bits of device specific error information
+following a secure update failure.
+
+The underlying driver must provide a get_hw_errinfo() callback
+function to enable this feature. This data is treated as
+opaque by the class driver. It is left to user-space software
+or support personnel to interpret this data.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+---
+ .../ABI/testing/sysfs-class-fpga-sec-mgr      | 14 +++++++
+ drivers/fpga/fpga-sec-mgr.c                   | 38 +++++++++++++++++++
+ include/linux/fpga/fpga-sec-mgr.h             |  5 +++
+ 3 files changed, 57 insertions(+)
+
+diff --git a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+index 814271aede05..5a2dad0d0941 100644
+--- a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
++++ b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+@@ -127,3 +127,17 @@ Description:	Read-only. Returns a string describing the failure
+ 		idle state. If this file is read while a secure
+ 		update is in progress, then the read will fail with
+ 		EBUSY.
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/hw_errinfo
++Date:		Oct 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read-only. Returns a 64 bit error value providing
++		hardware specific information that may be useful in
++		debugging errors that occur during FPGA image updates.
++		This file is only visible if the underlying device
++		supports it. The hw_errinfo value is only accessible
++		when the secure update engine is in the idle state.
++		If this file is read while a secure update is in
++		progress, then the read will fail with EBUSY.
++		Format: "0x%llx".
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index 9ec7092e9ede..7ea60147b248 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -156,10 +156,17 @@ static void set_error(struct fpga_sec_mgr *smgr, enum fpga_sec_err err_code)
+ 	smgr->err_code = err_code;
+ }
+ 
++static void set_hw_errinfo(struct fpga_sec_mgr *smgr)
++{
++	if (smgr->sops->get_hw_errinfo)
++		smgr->hw_errinfo = smgr->sops->get_hw_errinfo(smgr);
++}
++
+ static void fpga_sec_dev_error(struct fpga_sec_mgr *smgr,
+ 			       enum fpga_sec_err err_code)
+ {
+ 	set_error(smgr, err_code);
++	set_hw_errinfo(smgr);
+ 	smgr->sops->cancel(smgr);
+ }
+ 
+@@ -375,6 +382,23 @@ error_show(struct device *dev, struct device_attribute *attr, char *buf)
+ }
+ static DEVICE_ATTR_RO(error);
+ 
++static ssize_t
++hw_errinfo_show(struct device *dev, struct device_attribute *attr, char *buf)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
++	int ret;
++
++	mutex_lock(&smgr->lock);
++	if (smgr->progress != FPGA_SEC_PROG_IDLE)
++		ret = -EBUSY;
++	else
++		ret = sysfs_emit(buf, "0x%llx\n", smgr->hw_errinfo);
++	mutex_unlock(&smgr->lock);
++
++	return ret;
++}
++static DEVICE_ATTR_RO(hw_errinfo);
++
+ static ssize_t remaining_size_show(struct device *dev,
+ 				   struct device_attribute *attr, char *buf)
+ {
+@@ -406,6 +430,7 @@ static ssize_t filename_store(struct device *dev, struct device_attribute *attr,
+ 	}
+ 
+ 	smgr->err_code = FPGA_SEC_ERR_NONE;
++	smgr->hw_errinfo = 0;
+ 	smgr->request_cancel = false;
+ 	smgr->progress = FPGA_SEC_PROG_READING;
+ 	reinit_completion(&smgr->update_done);
+@@ -440,18 +465,31 @@ static ssize_t cancel_store(struct device *dev, struct device_attribute *attr,
+ }
+ static DEVICE_ATTR_WO(cancel);
+ 
++static umode_t
++sec_mgr_update_visible(struct kobject *kobj, struct attribute *attr, int n)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(kobj_to_dev(kobj));
++
++	if (attr == &dev_attr_hw_errinfo.attr && !smgr->sops->get_hw_errinfo)
++		return 0;
++
++	return attr->mode;
++}
++
+ static struct attribute *sec_mgr_update_attrs[] = {
+ 	&dev_attr_filename.attr,
+ 	&dev_attr_cancel.attr,
+ 	&dev_attr_status.attr,
+ 	&dev_attr_error.attr,
+ 	&dev_attr_remaining_size.attr,
++	&dev_attr_hw_errinfo.attr,
+ 	NULL,
+ };
+ 
+ static struct attribute_group sec_mgr_update_attr_group = {
+ 	.name = "update",
+ 	.attrs = sec_mgr_update_attrs,
++	.is_visible = sec_mgr_update_visible,
+ };
+ 
+ static ssize_t name_show(struct device *dev,
+diff --git a/include/linux/fpga/fpga-sec-mgr.h b/include/linux/fpga/fpga-sec-mgr.h
+index c6906c6d1d41..697cf28b6a99 100644
+--- a/include/linux/fpga/fpga-sec-mgr.h
++++ b/include/linux/fpga/fpga-sec-mgr.h
+@@ -60,6 +60,9 @@ enum fpga_sec_err {
+  *			    function and is called at the completion
+  *			    of the update, whether success or failure,
+  *			    if the prepare function succeeded.
++ * @get_hw_errinfo:	    Optional: Return u64 hw specific error info.
++ *			    The software err_code may used to determine
++ *			    whether the hw error info is applicable.
+  */
+ struct fpga_sec_mgr_ops {
+ 	int (*user_flash_count)(struct fpga_sec_mgr *smgr);
+@@ -87,6 +90,7 @@ struct fpga_sec_mgr_ops {
+ 	enum fpga_sec_err (*poll_complete)(struct fpga_sec_mgr *smgr);
+ 	void (*cleanup)(struct fpga_sec_mgr *smgr);
+ 	enum fpga_sec_err (*cancel)(struct fpga_sec_mgr *smgr);
++	u64 (*get_hw_errinfo)(struct fpga_sec_mgr *smgr);
+ };
+ 
+ /* Update progress codes */
+@@ -112,6 +116,7 @@ struct fpga_sec_mgr {
+ 	enum fpga_sec_prog progress;
+ 	enum fpga_sec_prog err_state;	/* progress state at time of failure */
+ 	enum fpga_sec_err err_code;	/* security manager error code */
++	u64 hw_errinfo;			/* 64 bits of HW specific error info */
+ 	bool request_cancel;
+ 	bool driver_unload;
+ 	void *priv;
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0027-mfd-intel-m10-bmc-support-for-MAX10-BMC-Secure-Updat.patch new/debian/patches/fpga-ofs/0027-mfd-intel-m10-bmc-support-for-MAX10-BMC-Secure-Updat.patch
--- org/debian/patches/fpga-ofs/0027-mfd-intel-m10-bmc-support-for-MAX10-BMC-Secure-Updat.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0027-mfd-intel-m10-bmc-support-for-MAX10-BMC-Secure-Updat.patch	2021-07-20 06:17:11.368844970 +0200
@@ -0,0 +1,121 @@
+From 5a9b07b028b093db28b22ad9c7f05ef562706da2 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:45 -0700
+Subject: [PATCH 027/149] mfd: intel-m10-bmc: support for MAX10 BMC Secure
+ Updates
+
+Add macros and definitions required by the MAX10 BMC
+Secure Update driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Acked-by: Lee Jones <lee.jones@linaro.org>
+---
+ include/linux/mfd/intel-m10-bmc.h | 85 +++++++++++++++++++++++++++++++
+ 1 file changed, 85 insertions(+)
+
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index f9a56e17d3d6..64a82949f5cc 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -13,6 +13,9 @@
+ #define M10BMC_SYS_BASE			0x300800
+ #define M10BMC_MEM_END			0x200000fc
+ 
++#define M10BMC_STAGING_BASE		0x18000000
++#define M10BMC_STAGING_SIZE		0x3800000
++
+ /* Register offset of system registers */
+ #define NIOS2_FW_VERSION		0x0
+ #define M10BMC_TEST_REG			0x3c
+@@ -28,6 +31,88 @@
+ #define SERDES_VERSION			GENMASK(15, 0)
+ #define SBUS_VERSION			GENMASK(31, 16)
+ 
++/* Secure update doorbell register, in system register region */
++#define M10BMC_DOORBELL			0x400
++
++/* Authorization Result register, in system register region */
++#define M10BMC_AUTH_RESULT		0x404
++
++/* Doorbell register fields */
++#define DRBL_RSU_REQUEST		BIT(0)
++#define DRBL_RSU_PROGRESS		GENMASK(7, 4)
++#define DRBL_HOST_STATUS		GENMASK(11, 8)
++#define DRBL_RSU_STATUS			GENMASK(23, 16)
++#define DRBL_PKVL_EEPROM_LOAD_SEC	BIT(24)
++#define DRBL_PKVL1_POLL_EN		BIT(25)
++#define DRBL_PKVL2_POLL_EN		BIT(26)
++#define DRBL_CONFIG_SEL			BIT(28)
++#define DRBL_REBOOT_REQ			BIT(29)
++#define DRBL_REBOOT_DISABLED		BIT(30)
++
++/* Progress states */
++#define RSU_PROG_IDLE			0x0
++#define RSU_PROG_PREPARE		0x1
++#define RSU_PROG_READY			0x3
++#define RSU_PROG_AUTHENTICATING		0x4
++#define RSU_PROG_COPYING		0x5
++#define RSU_PROG_UPDATE_CANCEL		0x6
++#define RSU_PROG_PROGRAM_KEY_HASH	0x7
++#define RSU_PROG_RSU_DONE		0x8
++#define RSU_PROG_PKVL_PROM_DONE		0x9
++
++/* Device and error states */
++#define RSU_STAT_NORMAL			0x0
++#define RSU_STAT_TIMEOUT		0x1
++#define RSU_STAT_AUTH_FAIL		0x2
++#define RSU_STAT_COPY_FAIL		0x3
++#define RSU_STAT_FATAL			0x4
++#define RSU_STAT_PKVL_REJECT		0x5
++#define RSU_STAT_NON_INC		0x6
++#define RSU_STAT_ERASE_FAIL		0x7
++#define RSU_STAT_WEAROUT		0x8
++#define RSU_STAT_NIOS_OK		0x80
++#define RSU_STAT_USER_OK		0x81
++#define RSU_STAT_FACTORY_OK		0x82
++#define RSU_STAT_USER_FAIL		0x83
++#define RSU_STAT_FACTORY_FAIL		0x84
++#define RSU_STAT_NIOS_FLASH_ERR		0x85
++#define RSU_STAT_FPGA_FLASH_ERR		0x86
++
++#define HOST_STATUS_IDLE		0x0
++#define HOST_STATUS_WRITE_DONE		0x1
++#define HOST_STATUS_ABORT_RSU		0x2
++
++#define rsu_prog(doorbell)	FIELD_GET(DRBL_RSU_PROGRESS, doorbell)
++#define rsu_stat(doorbell)	FIELD_GET(DRBL_RSU_STATUS, doorbell)
++
++/* interval 100ms and timeout 5s */
++#define NIOS_HANDSHAKE_INTERVAL_US	(100 * 1000)
++#define NIOS_HANDSHAKE_TIMEOUT_US	(5 * 1000 * 1000)
++
++/* RSU PREP Timeout (2 minutes) to erase flash staging area */
++#define RSU_PREP_INTERVAL_MS		100
++#define RSU_PREP_TIMEOUT_MS		(2 * 60 * 1000)
++
++/* RSU Complete Timeout (40 minutes) for full flash update */
++#define RSU_COMPLETE_INTERVAL_MS	1000
++#define RSU_COMPLETE_TIMEOUT_MS		(40 * 60 * 1000)
++
++/* Addresses for security related data in FLASH */
++#define BMC_REH_ADDR	0x17ffc004
++#define BMC_PROG_ADDR	0x17ffc000
++#define BMC_PROG_MAGIC	0x5746
++
++#define SR_REH_ADDR	0x17ffd004
++#define SR_PROG_ADDR	0x17ffd000
++#define SR_PROG_MAGIC	0x5253
++
++#define PR_REH_ADDR	0x17ffe004
++#define PR_PROG_ADDR	0x17ffe000
++#define PR_PROG_MAGIC	0x5250
++
++/* Address of inverted bit vector containing user the image FLASH count */
++#define USER_FLASH_COUNT 0x17ffb000
++
+ /**
+  * struct intel_m10bmc_retimer_pdata - subdev retimer platform data
+  *
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0028-fpga-m10bmc-sec-create-max10-bmc-secure-update-drive.patch new/debian/patches/fpga-ofs/0028-fpga-m10bmc-sec-create-max10-bmc-secure-update-drive.patch
--- org/debian/patches/fpga-ofs/0028-fpga-m10bmc-sec-create-max10-bmc-secure-update-drive.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0028-fpga-m10bmc-sec-create-max10-bmc-secure-update-drive.patch	2021-07-20 06:17:11.380844935 +0200
@@ -0,0 +1,235 @@
+From 32037fe9fa9e8e02f02af66402c657aa7e21e5f5 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:46 -0700
+Subject: [PATCH 028/149] fpga: m10bmc-sec: create max10 bmc secure update
+ driver
+
+Create a platform driver that can be invoked as a sub
+driver for the Intel MAX10 BMC in order to support
+secure updates. This sub-driver will invoke an
+instance of the FPGA Security Manager class driver
+in order to expose sysfs interfaces for managing and
+monitoring secure updates to FPGA and BMC images.
+
+This patch creates the MAX10 BMC Secure Update driver and
+provides support for displaying the current root entry hashes
+for the FPGA static region, the FPGA PR region, and the MAX10
+BMC.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ MAINTAINERS                         |   1 +
+ drivers/fpga/Kconfig                |  11 ++
+ drivers/fpga/Makefile               |   3 +
+ drivers/fpga/intel-m10-bmc-secure.c | 153 ++++++++++++++++++++++++++++
+ 4 files changed, 168 insertions(+)
+ create mode 100644 drivers/fpga/intel-m10-bmc-secure.c
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 8d0bc717d377..545b79be393d 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -6919,6 +6919,7 @@ S:	Maintained
+ F:	Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+ F:	Documentation/fpga/fpga-sec-mgr.rst
+ F:	drivers/fpga/fpga-sec-mgr.c
++F:	drivers/fpga/intel-m10-bmc-secure.c
+ F:	include/linux/fpga/fpga-sec-mgr.h
+ 
+ FPU EMULATOR
+diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
+index 3ce1baa65379..92b572fd1729 100644
+--- a/drivers/fpga/Kconfig
++++ b/drivers/fpga/Kconfig
+@@ -246,4 +246,15 @@ config FPGA_SEC_MGR
+ 	  region and for the BMC. Select this option to enable
+ 	  updates for secure FPGA devices.
+ 
++config IFPGA_M10_BMC_SECURE
++	tristate "Intel MAX10 BMC Secure Update driver"
++	depends on MFD_INTEL_M10_BMC && FPGA_SEC_MGR
++	help
++	  Secure update support for the Intel MAX10 board management
++	  controller.
++
++	  This is a subdriver of the Intel MAX10 board management controller
++	  (BMC) and provides support for secure updates for the BMC image,
++	  the FPGA image, the Root Entry Hashes, etc.
++
+ endif # FPGA
+diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
+index a1c4669eb25d..b1112d80c4f4 100644
+--- a/drivers/fpga/Makefile
++++ b/drivers/fpga/Makefile
+@@ -24,6 +24,9 @@ obj-$(CONFIG_ALTERA_PR_IP_CORE_PLAT)    += altera-pr-ip-core-plat.o
+ # FPGA Security Manager Framework
+ obj-$(CONFIG_FPGA_SEC_MGR)		+= fpga-sec-mgr.o
+ 
++# FPGA Secure Update Drivers
++obj-$(CONFIG_IFPGA_M10_BMC_SECURE)	+= intel-m10-bmc-secure.o
++
+ # FPGA Bridge Drivers
+ obj-$(CONFIG_FPGA_BRIDGE)		+= fpga-bridge.o
+ obj-$(CONFIG_SOCFPGA_FPGA_BRIDGE)	+= altera-hps2fpga.o altera-fpga2sdram.o
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+new file mode 100644
+index 000000000000..b04b2c383847
+--- /dev/null
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -0,0 +1,153 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Intel Max10 Board Management Controller Secure Update Driver
++ *
++ * Copyright (C) 2019-2020 Intel Corporation. All rights reserved.
++ *
++ */
++#include <linux/bitfield.h>
++#include <linux/device.h>
++#include <linux/fpga/fpga-sec-mgr.h>
++#include <linux/mfd/intel-m10-bmc.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/vmalloc.h>
++
++struct m10bmc_sec {
++	struct device *dev;
++	struct intel_m10bmc *m10bmc;
++};
++
++/* Root Entry Hash (REH) support */
++#define REH_SHA256_SIZE		32
++#define REH_SHA384_SIZE		48
++#define REH_MAGIC		GENMASK(15, 0)
++#define REH_SHA_NUM_BYTES	GENMASK(31, 16)
++
++static int m10bmc_reh_size(struct fpga_sec_mgr *smgr,
++			   u32 exp_magic, u32 prog_addr)
++{
++	struct m10bmc_sec *sec = smgr->priv;
++	int sha_num_bytes, ret;
++	u32 magic;
++
++	ret = m10bmc_raw_read(sec->m10bmc, prog_addr, &magic);
++	if (ret)
++		return ret;
++
++	dev_dbg(sec->dev, "%s magic 0x%08x\n", __func__, magic);
++
++	/*
++	 * If no magic number, then no Root Entry Hash (REH) is programmed,
++	 * so the REH size is zero.
++	 */
++	if (FIELD_GET(REH_MAGIC, magic) != exp_magic)
++		return 0;
++
++	sha_num_bytes = FIELD_GET(REH_SHA_NUM_BYTES, magic) / 8;
++	if (sha_num_bytes != REH_SHA256_SIZE &&
++	    sha_num_bytes != REH_SHA384_SIZE)   {
++		dev_err(sec->dev, "%s bad sha num bytes %d\n", __func__,
++			sha_num_bytes);
++		return -EINVAL;
++	}
++
++	return sha_num_bytes;
++}
++
++static int m10bmc_bmc_reh_size(struct fpga_sec_mgr *smgr)
++{
++	return m10bmc_reh_size(smgr, BMC_PROG_MAGIC, BMC_PROG_ADDR);
++}
++
++static int m10bmc_sr_reh_size(struct fpga_sec_mgr *smgr)
++{
++	return m10bmc_reh_size(smgr, SR_PROG_MAGIC, SR_PROG_ADDR);
++}
++
++static int m10bmc_pr_reh_size(struct fpga_sec_mgr *smgr)
++{
++	return m10bmc_reh_size(smgr, PR_PROG_MAGIC, PR_PROG_ADDR);
++}
++
++static int m10bmc_reh(struct fpga_sec_mgr *smgr, u32 hash_addr,
++		      u8 *hash, unsigned int size)
++{
++	struct m10bmc_sec *sec = smgr->priv;
++	unsigned int stride = regmap_get_reg_stride(sec->m10bmc->regmap);
++	int ret;
++
++	ret = regmap_bulk_read(sec->m10bmc->regmap, hash_addr,
++			       hash, size / stride);
++	if (ret)
++		dev_err(sec->m10bmc->dev,
++			"failed to read root entry hash: %x cnt %x: %d\n",
++			hash_addr, size / stride, ret);
++
++	return ret;
++}
++
++static int m10bmc_bmc_reh(struct fpga_sec_mgr *smgr, u8 *hash,
++			  unsigned int size)
++{
++	return m10bmc_reh(smgr, BMC_REH_ADDR, hash, size);
++}
++
++static int m10bmc_sr_reh(struct fpga_sec_mgr *smgr, u8 *hash,
++			 unsigned int size)
++{
++	return m10bmc_reh(smgr, SR_REH_ADDR, hash, size);
++}
++
++static int m10bmc_pr_reh(struct fpga_sec_mgr *smgr, u8 *hash,
++			 unsigned int size)
++{
++	return m10bmc_reh(smgr, PR_REH_ADDR, hash, size);
++}
++
++static const struct fpga_sec_mgr_ops m10bmc_sops = {
++	.bmc_root_entry_hash = m10bmc_bmc_reh,
++	.sr_root_entry_hash = m10bmc_sr_reh,
++	.pr_root_entry_hash = m10bmc_pr_reh,
++	.bmc_reh_size = m10bmc_bmc_reh_size,
++	.sr_reh_size = m10bmc_sr_reh_size,
++	.pr_reh_size = m10bmc_pr_reh_size,
++};
++
++static int m10bmc_secure_probe(struct platform_device *pdev)
++{
++	struct fpga_sec_mgr *smgr;
++	struct m10bmc_sec *sec;
++	int ret;
++
++	sec = devm_kzalloc(&pdev->dev, sizeof(*sec), GFP_KERNEL);
++	if (!sec)
++		return -ENOMEM;
++
++	sec->dev = &pdev->dev;
++	sec->m10bmc = dev_get_drvdata(pdev->dev.parent);
++	dev_set_drvdata(&pdev->dev, sec);
++
++	smgr = devm_fpga_sec_mgr_create(sec->dev, "Max10 BMC Secure Update",
++					&m10bmc_sops, sec);
++	if (!smgr) {
++		dev_err(sec->dev,
++			"Security manager failed to start: %d\n", ret);
++		return -ENOMEM;
++	}
++
++	return devm_fpga_sec_mgr_register(sec->dev, smgr);
++}
++
++static struct platform_driver intel_m10bmc_secure_driver = {
++	.probe = m10bmc_secure_probe,
++	.driver = {
++		.name = "n3000bmc-secure",
++	},
++};
++module_platform_driver(intel_m10bmc_secure_driver);
++
++MODULE_ALIAS("platform:n3000bmc-secure");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_DESCRIPTION("Intel MAX10 BMC Secure Update");
++MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0029-fpga-m10bmc-sec-expose-max10-flash-update-counts.patch new/debian/patches/fpga-ofs/0029-fpga-m10bmc-sec-expose-max10-flash-update-counts.patch
--- org/debian/patches/fpga-ofs/0029-fpga-m10bmc-sec-expose-max10-flash-update-counts.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0029-fpga-m10bmc-sec-expose-max10-flash-update-counts.patch	2021-07-20 06:17:11.380844935 +0200
@@ -0,0 +1,70 @@
+From c1467b03eb8459ff5bf1373d4ea3a59290f93d6b Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:47 -0700
+Subject: [PATCH 029/149] fpga: m10bmc-sec: expose max10 flash update counts
+
+Extend the MAX10 BMC Secure Update driver to provide a
+handler to expose the flash update count for the FPGA user
+image in sysfs.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 33 +++++++++++++++++++++++++++++
+ 1 file changed, 33 insertions(+)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index b04b2c383847..1cffeca558bf 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -11,6 +11,7 @@
+ #include <linux/mfd/intel-m10-bmc.h>
+ #include <linux/module.h>
+ #include <linux/platform_device.h>
++#include <linux/slab.h>
+ #include <linux/vmalloc.h>
+ 
+ struct m10bmc_sec {
+@@ -105,7 +106,39 @@ static int m10bmc_pr_reh(struct fpga_sec_mgr *smgr, u8 *hash,
+ 	return m10bmc_reh(smgr, PR_REH_ADDR, hash, size);
+ }
+ 
++#define FLASH_COUNT_SIZE 4096	/* count stored in inverted bit vector */
++
++static int m10bmc_user_flash_count(struct fpga_sec_mgr *smgr)
++{
++	struct m10bmc_sec *sec = smgr->priv;
++	unsigned int stride = regmap_get_reg_stride(sec->m10bmc->regmap);
++	unsigned int num_bits = FLASH_COUNT_SIZE * 8;
++	u8 *flash_buf;
++	int ret;
++
++	flash_buf = kmalloc(FLASH_COUNT_SIZE, GFP_KERNEL);
++	if (!flash_buf)
++		return -ENOMEM;
++
++	ret = regmap_bulk_read(sec->m10bmc->regmap, USER_FLASH_COUNT,
++			       flash_buf, FLASH_COUNT_SIZE / stride);
++	if (ret) {
++		dev_err(sec->dev,
++			"failed to read flash count: %x cnt %x: %d\n",
++			USER_FLASH_COUNT, FLASH_COUNT_SIZE / stride, ret);
++		goto exit_free;
++	}
++
++	ret = num_bits - bitmap_weight((unsigned long *)flash_buf, num_bits);
++
++exit_free:
++	kfree(flash_buf);
++
++	return ret;
++}
++
+ static const struct fpga_sec_mgr_ops m10bmc_sops = {
++	.user_flash_count = m10bmc_user_flash_count,
+ 	.bmc_root_entry_hash = m10bmc_bmc_reh,
+ 	.sr_root_entry_hash = m10bmc_sr_reh,
+ 	.pr_root_entry_hash = m10bmc_pr_reh,
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0030-fpga-m10bmc-sec-expose-max10-canceled-keys-in-sysfs.patch new/debian/patches/fpga-ofs/0030-fpga-m10bmc-sec-expose-max10-canceled-keys-in-sysfs.patch
--- org/debian/patches/fpga-ofs/0030-fpga-m10bmc-sec-expose-max10-canceled-keys-in-sysfs.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0030-fpga-m10bmc-sec-expose-max10-canceled-keys-in-sysfs.patch	2021-07-20 06:17:11.380844935 +0200
@@ -0,0 +1,120 @@
+From b0ce946c5bd8970f85cdfd2f427eb4a29baba3ae Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:48 -0700
+Subject: [PATCH 030/149] fpga: m10bmc-sec: expose max10 canceled keys in sysfs
+
+Extend the MAX10 BMC Secure Update driver to provide a
+handler to expose the canceled code signing key (CSK) bit
+vectors in sysfs. These use the standard bitmap list format
+(e.g. 1,2-6,9).
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 82 +++++++++++++++++++++++++++++
+ 1 file changed, 82 insertions(+)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 1cffeca558bf..bbbb0b3ac73e 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -137,14 +137,96 @@ static int m10bmc_user_flash_count(struct fpga_sec_mgr *smgr)
+ 	return ret;
+ }
+ 
++#define CSK_BIT_LEN			128U
++#define CSK_32ARRAY_SIZE(_nbits)	DIV_ROUND_UP(_nbits, 32)
++
++static int m10bmc_csk_cancel_nbits(struct fpga_sec_mgr *smgr)
++{
++	return (int)CSK_BIT_LEN;
++}
++
++static int m10bmc_csk_vector(struct fpga_sec_mgr *smgr, u32 addr,
++			     unsigned long *csk_map, unsigned int nbits)
++{
++	unsigned int i, size, arr_size = CSK_32ARRAY_SIZE(nbits);
++	struct m10bmc_sec *sec = smgr->priv;
++	unsigned int stride;
++	__le32 *csk_le32;
++	u32 *csk32;
++	int ret;
++
++	stride = regmap_get_reg_stride(sec->m10bmc->regmap);
++	size = arr_size * sizeof(u32);
++
++	csk32 = vmalloc(size);
++	if (!csk32)
++		return -ENOMEM;
++
++	csk_le32 = vmalloc(size);
++	if (!csk_le32) {
++		vfree(csk32);
++		return -ENOMEM;
++	}
++
++	ret = regmap_bulk_read(sec->m10bmc->regmap, addr, csk_le32, size / stride);
++	if (ret) {
++		dev_err(sec->dev, "failed to read CSK vector: %x cnt %x: %d\n",
++			addr, size / stride, ret);
++		goto vfree_exit;
++	}
++
++	for (i = 0; i < arr_size; i++)
++		csk32[i] = le32_to_cpu(((csk_le32[i])));
++
++	bitmap_from_arr32(csk_map, csk32, nbits);
++	bitmap_complement(csk_map, csk_map, nbits);
++
++vfree_exit:
++	vfree(csk_le32);
++	vfree(csk32);
++	return ret;
++}
++
++#define CSK_VEC_OFFSET 0x34
++
++static int m10bmc_bmc_canceled_csks(struct fpga_sec_mgr *smgr,
++				    unsigned long *csk_map,
++				    unsigned int nbits)
++{
++	return m10bmc_csk_vector(smgr, BMC_PROG_ADDR + CSK_VEC_OFFSET,
++				 csk_map, nbits);
++}
++
++static int m10bmc_sr_canceled_csks(struct fpga_sec_mgr *smgr,
++				   unsigned long *csk_map,
++				   unsigned int nbits)
++{
++	return m10bmc_csk_vector(smgr, SR_PROG_ADDR + CSK_VEC_OFFSET,
++				 csk_map, nbits);
++}
++
++static int m10bmc_pr_canceled_csks(struct fpga_sec_mgr *smgr,
++				   unsigned long *csk_map,
++				   unsigned int nbits)
++{
++	return m10bmc_csk_vector(smgr, PR_PROG_ADDR + CSK_VEC_OFFSET,
++				 csk_map, nbits);
++}
++
+ static const struct fpga_sec_mgr_ops m10bmc_sops = {
+ 	.user_flash_count = m10bmc_user_flash_count,
+ 	.bmc_root_entry_hash = m10bmc_bmc_reh,
+ 	.sr_root_entry_hash = m10bmc_sr_reh,
+ 	.pr_root_entry_hash = m10bmc_pr_reh,
++	.bmc_canceled_csks = m10bmc_bmc_canceled_csks,
++	.sr_canceled_csks = m10bmc_sr_canceled_csks,
++	.pr_canceled_csks = m10bmc_pr_canceled_csks,
+ 	.bmc_reh_size = m10bmc_bmc_reh_size,
+ 	.sr_reh_size = m10bmc_sr_reh_size,
+ 	.pr_reh_size = m10bmc_pr_reh_size,
++	.bmc_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
++	.sr_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
++	.pr_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
+ };
+ 
+ static int m10bmc_secure_probe(struct platform_device *pdev)
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0031-fpga-m10bmc-sec-add-max10-secure-update-functions.patch new/debian/patches/fpga-ofs/0031-fpga-m10bmc-sec-add-max10-secure-update-functions.patch
--- org/debian/patches/fpga-ofs/0031-fpga-m10bmc-sec-add-max10-secure-update-functions.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0031-fpga-m10bmc-sec-add-max10-secure-update-functions.patch	2021-07-20 06:17:11.380844935 +0200
@@ -0,0 +1,337 @@
+From 427cf54e9f30af243e2f3e72e53ac6b556ac843e Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:49 -0700
+Subject: [PATCH 031/149] fpga: m10bmc-sec: add max10 secure update functions
+
+Extend the MAX10 BMC Secure Update driver to include
+the functions that enable secure updates of BMC images,
+FPGA images, etc.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 302 ++++++++++++++++++++++++++++
+ 1 file changed, 302 insertions(+)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index bbbb0b3ac73e..4a59056d98a1 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -213,6 +213,304 @@ static int m10bmc_pr_canceled_csks(struct fpga_sec_mgr *smgr,
+ 				 csk_map, nbits);
+ }
+ 
++static void log_error_regs(struct m10bmc_sec *sec, u32 doorbell)
++{
++	u32 auth_result;
++
++	dev_err(sec->dev, "RSU error status: 0x%08x\n", doorbell);
++
++	if (!m10bmc_sys_read(sec->m10bmc, M10BMC_AUTH_RESULT, &auth_result))
++		dev_err(sec->dev, "RSU auth result: 0x%08x\n", auth_result);
++}
++
++static enum fpga_sec_err rsu_check_idle(struct m10bmc_sec *sec)
++{
++	u32 doorbell;
++	int ret;
++
++	ret = m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, &doorbell);
++	if (ret)
++		return FPGA_SEC_ERR_RW_ERROR;
++
++	if (rsu_prog(doorbell) != RSU_PROG_IDLE &&
++	    rsu_prog(doorbell) != RSU_PROG_RSU_DONE) {
++		log_error_regs(sec, doorbell);
++		return FPGA_SEC_ERR_BUSY;
++	}
++
++	return FPGA_SEC_ERR_NONE;
++}
++
++static inline bool rsu_start_done(u32 doorbell)
++{
++	u32 status, progress;
++
++	if (doorbell & DRBL_RSU_REQUEST)
++		return false;
++
++	status = rsu_stat(doorbell);
++	if (status == RSU_STAT_ERASE_FAIL || status == RSU_STAT_WEAROUT)
++		return true;
++
++	progress = rsu_prog(doorbell);
++	if (progress != RSU_PROG_IDLE && progress != RSU_PROG_RSU_DONE)
++		return true;
++
++	return false;
++}
++
++static enum fpga_sec_err rsu_update_init(struct m10bmc_sec *sec)
++{
++	u32 doorbell, status;
++	int ret;
++
++	ret = regmap_update_bits(sec->m10bmc->regmap,
++				 M10BMC_SYS_BASE + M10BMC_DOORBELL,
++				 DRBL_RSU_REQUEST | DRBL_HOST_STATUS,
++				 DRBL_RSU_REQUEST |
++				 FIELD_PREP(DRBL_HOST_STATUS,
++					    HOST_STATUS_IDLE));
++	if (ret)
++		return FPGA_SEC_ERR_RW_ERROR;
++
++	ret = regmap_read_poll_timeout(sec->m10bmc->regmap,
++				       M10BMC_SYS_BASE + M10BMC_DOORBELL,
++				       doorbell,
++				       rsu_start_done(doorbell),
++				       NIOS_HANDSHAKE_INTERVAL_US,
++				       NIOS_HANDSHAKE_TIMEOUT_US);
++
++	if (ret == -ETIMEDOUT) {
++		log_error_regs(sec, doorbell);
++		return FPGA_SEC_ERR_TIMEOUT;
++	} else if (ret) {
++		return FPGA_SEC_ERR_RW_ERROR;
++	}
++
++	status = rsu_stat(doorbell);
++	if (status == RSU_STAT_WEAROUT) {
++		dev_warn(sec->dev, "Excessive flash update count detected\n");
++		return FPGA_SEC_ERR_WEAROUT;
++	} else if (status == RSU_STAT_ERASE_FAIL) {
++		log_error_regs(sec, doorbell);
++		return FPGA_SEC_ERR_HW_ERROR;
++	}
++
++	return FPGA_SEC_ERR_NONE;
++}
++
++static enum fpga_sec_err rsu_prog_ready(struct m10bmc_sec *sec)
++{
++	unsigned long poll_timeout;
++	u32 doorbell, progress;
++	int ret;
++
++	ret = m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, &doorbell);
++	if (ret)
++		return FPGA_SEC_ERR_RW_ERROR;
++
++	poll_timeout = jiffies + msecs_to_jiffies(RSU_PREP_TIMEOUT_MS);
++	while (rsu_prog(doorbell) == RSU_PROG_PREPARE) {
++		msleep(RSU_PREP_INTERVAL_MS);
++		if (time_after(jiffies, poll_timeout))
++			break;
++
++		ret = m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, &doorbell);
++		if (ret)
++			return FPGA_SEC_ERR_RW_ERROR;
++	}
++
++	progress = rsu_prog(doorbell);
++	if (progress == RSU_PROG_PREPARE) {
++		log_error_regs(sec, doorbell);
++		return FPGA_SEC_ERR_TIMEOUT;
++	} else if (progress != RSU_PROG_READY) {
++		log_error_regs(sec, doorbell);
++		return FPGA_SEC_ERR_HW_ERROR;
++	}
++
++	return FPGA_SEC_ERR_NONE;
++}
++
++static enum fpga_sec_err rsu_send_data(struct m10bmc_sec *sec)
++{
++	u32 doorbell;
++	int ret;
++
++	ret = regmap_update_bits(sec->m10bmc->regmap,
++				 M10BMC_SYS_BASE + M10BMC_DOORBELL,
++				 DRBL_HOST_STATUS,
++				 FIELD_PREP(DRBL_HOST_STATUS,
++					    HOST_STATUS_WRITE_DONE));
++	if (ret)
++		return FPGA_SEC_ERR_RW_ERROR;
++
++	ret = regmap_read_poll_timeout(sec->m10bmc->regmap,
++				       M10BMC_SYS_BASE + M10BMC_DOORBELL,
++				       doorbell,
++				       rsu_prog(doorbell) != RSU_PROG_READY,
++				       NIOS_HANDSHAKE_INTERVAL_US,
++				       NIOS_HANDSHAKE_TIMEOUT_US);
++
++	if (ret == -ETIMEDOUT) {
++		log_error_regs(sec, doorbell);
++		return FPGA_SEC_ERR_TIMEOUT;
++	} else if (ret) {
++		return FPGA_SEC_ERR_RW_ERROR;
++	}
++
++	switch (rsu_stat(doorbell)) {
++	case RSU_STAT_NORMAL:
++	case RSU_STAT_NIOS_OK:
++	case RSU_STAT_USER_OK:
++	case RSU_STAT_FACTORY_OK:
++		break;
++	default:
++		log_error_regs(sec, doorbell);
++		return FPGA_SEC_ERR_HW_ERROR;
++	}
++
++	return FPGA_SEC_ERR_NONE;
++}
++
++static int rsu_check_complete(struct m10bmc_sec *sec, u32 *doorbell)
++{
++	if (m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, doorbell))
++		return -EIO;
++
++	switch (rsu_stat(*doorbell)) {
++	case RSU_STAT_NORMAL:
++	case RSU_STAT_NIOS_OK:
++	case RSU_STAT_USER_OK:
++	case RSU_STAT_FACTORY_OK:
++	case RSU_STAT_WEAROUT:
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	switch (rsu_prog(*doorbell)) {
++	case RSU_PROG_IDLE:
++	case RSU_PROG_RSU_DONE:
++		return 0;
++	case RSU_PROG_AUTHENTICATING:
++	case RSU_PROG_COPYING:
++	case RSU_PROG_UPDATE_CANCEL:
++	case RSU_PROG_PROGRAM_KEY_HASH:
++		return -EAGAIN;
++	default:
++		return -EINVAL;
++	}
++}
++
++static enum fpga_sec_err m10bmc_sec_prepare(struct fpga_sec_mgr *smgr)
++{
++	struct m10bmc_sec *sec = smgr->priv;
++	enum fpga_sec_err ret;
++
++	if (smgr->remaining_size > M10BMC_STAGING_SIZE)
++		return FPGA_SEC_ERR_INVALID_SIZE;
++
++	ret = rsu_check_idle(sec);
++	if (ret != FPGA_SEC_ERR_NONE)
++		return ret;
++
++	ret = rsu_update_init(sec);
++	if (ret != FPGA_SEC_ERR_NONE)
++		return ret;
++
++	return rsu_prog_ready(sec);
++}
++
++static enum fpga_sec_err
++m10bmc_sec_write_blk(struct fpga_sec_mgr *smgr, u32 offset, u32 size)
++{
++	struct m10bmc_sec *sec = smgr->priv;
++	unsigned int stride = regmap_get_reg_stride(sec->m10bmc->regmap);
++	u32 doorbell;
++	int ret;
++
++	ret = m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, &doorbell);
++	if (ret) {
++		return FPGA_SEC_ERR_RW_ERROR;
++	} else if (rsu_prog(doorbell) != RSU_PROG_READY) {
++		log_error_regs(sec, doorbell);
++		return FPGA_SEC_ERR_HW_ERROR;
++	}
++
++	ret = regmap_bulk_write(sec->m10bmc->regmap,
++				M10BMC_STAGING_BASE + offset,
++				(void *)smgr->data + offset, size / stride);
++
++	return ret ? FPGA_SEC_ERR_RW_ERROR : FPGA_SEC_ERR_NONE;
++}
++
++/*
++ * m10bmc_sec_poll_complete() is called after handing things off to
++ * the BMC firmware. Depending on the type of update, it could be
++ * 30+ minutes before the BMC firmware completes the update. The
++ * smgr->driver_unload check allows the driver to be unloaded,
++ * but the BMC firmware will continue the update and no further
++ * secure updates can be started for this device until the update
++ * is complete.
++ */
++static enum fpga_sec_err m10bmc_sec_poll_complete(struct fpga_sec_mgr *smgr)
++{
++	struct m10bmc_sec *sec = smgr->priv;
++	unsigned long poll_timeout;
++	enum fpga_sec_err result;
++	u32 doorbell;
++	int ret;
++
++	result = rsu_send_data(sec);
++	if (result != FPGA_SEC_ERR_NONE)
++		return result;
++
++	ret = rsu_check_complete(sec, &doorbell);
++	poll_timeout = jiffies + msecs_to_jiffies(RSU_COMPLETE_TIMEOUT_MS);
++
++	while (ret == -EAGAIN && !time_after(jiffies, poll_timeout)) {
++		msleep(RSU_COMPLETE_INTERVAL_MS);
++		ret = rsu_check_complete(sec, &doorbell);
++		if (smgr->driver_unload)
++			return FPGA_SEC_ERR_CANCELED;
++	}
++
++	if (ret == -EAGAIN) {
++		log_error_regs(sec, doorbell);
++		return FPGA_SEC_ERR_TIMEOUT;
++	} else if (ret == -EIO) {
++		return FPGA_SEC_ERR_RW_ERROR;
++	} else if (ret) {
++		log_error_regs(sec, doorbell);
++		return FPGA_SEC_ERR_HW_ERROR;
++	}
++
++	return FPGA_SEC_ERR_NONE;
++}
++
++static enum fpga_sec_err m10bmc_sec_cancel(struct fpga_sec_mgr *smgr)
++{
++	struct m10bmc_sec *sec = smgr->priv;
++	u32 doorbell;
++	int ret;
++
++	ret = m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, &doorbell);
++	if (ret)
++		return FPGA_SEC_ERR_RW_ERROR;
++
++	if (rsu_prog(doorbell) != RSU_PROG_READY)
++		return FPGA_SEC_ERR_BUSY;
++
++	ret = regmap_update_bits(sec->m10bmc->regmap,
++				 M10BMC_SYS_BASE + M10BMC_DOORBELL,
++				 DRBL_HOST_STATUS,
++				 FIELD_PREP(DRBL_HOST_STATUS,
++					    HOST_STATUS_ABORT_RSU));
++
++	return ret ? FPGA_SEC_ERR_RW_ERROR : FPGA_SEC_ERR_NONE;
++}
++
+ static const struct fpga_sec_mgr_ops m10bmc_sops = {
+ 	.user_flash_count = m10bmc_user_flash_count,
+ 	.bmc_root_entry_hash = m10bmc_bmc_reh,
+@@ -227,6 +525,10 @@ static const struct fpga_sec_mgr_ops m10bmc_sops = {
+ 	.bmc_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
+ 	.sr_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
+ 	.pr_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
++	.prepare = m10bmc_sec_prepare,
++	.write_blk = m10bmc_sec_write_blk,
++	.poll_complete = m10bmc_sec_poll_complete,
++	.cancel = m10bmc_sec_cancel,
+ };
+ 
+ static int m10bmc_secure_probe(struct platform_device *pdev)
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0032-fpga-m10bmc-sec-add-max10-get_hw_errinfo-callback-fu.patch new/debian/patches/fpga-ofs/0032-fpga-m10bmc-sec-add-max10-get_hw_errinfo-callback-fu.patch
--- org/debian/patches/fpga-ofs/0032-fpga-m10bmc-sec-add-max10-get_hw_errinfo-callback-fu.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0032-fpga-m10bmc-sec-add-max10-get_hw_errinfo-callback-fu.patch	2021-07-20 06:17:11.380844935 +0200
@@ -0,0 +1,63 @@
+From 9f5209a01538074ea8749cfd883f8b3c79115d9f Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:50 -0700
+Subject: [PATCH 032/149] fpga: m10bmc-sec: add max10 get_hw_errinfo callback
+ func
+
+Extend the MAX10 BMC Secure Update driver to include
+a function that returns 64 bits of additional HW specific
+data for errors that require additional information.
+This callback function enables the hw_errinfo sysfs
+node in the Intel Security Manager class driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 25 +++++++++++++++++++++++++
+ 1 file changed, 25 insertions(+)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 4a59056d98a1..df88a3346b45 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -511,6 +511,30 @@ static enum fpga_sec_err m10bmc_sec_cancel(struct fpga_sec_mgr *smgr)
+ 	return ret ? FPGA_SEC_ERR_RW_ERROR : FPGA_SEC_ERR_NONE;
+ }
+ 
++#define HW_ERRINFO_POISON	GENMASK(31, 0)
++static u64 m10bmc_sec_hw_errinfo(struct fpga_sec_mgr *smgr)
++{
++	struct m10bmc_sec *sec = smgr->priv;
++	u32 doorbell, auth_result;
++
++	switch (smgr->err_code) {
++	case FPGA_SEC_ERR_HW_ERROR:
++	case FPGA_SEC_ERR_TIMEOUT:
++	case FPGA_SEC_ERR_BUSY:
++	case FPGA_SEC_ERR_WEAROUT:
++		if (m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, &doorbell))
++			doorbell = HW_ERRINFO_POISON;
++
++		if (m10bmc_sys_read(sec->m10bmc, M10BMC_AUTH_RESULT,
++				    &auth_result))
++			auth_result = HW_ERRINFO_POISON;
++
++		return (u64)doorbell << 32 | (u64)auth_result;
++	default:
++		return 0;
++	}
++}
++
+ static const struct fpga_sec_mgr_ops m10bmc_sops = {
+ 	.user_flash_count = m10bmc_user_flash_count,
+ 	.bmc_root_entry_hash = m10bmc_bmc_reh,
+@@ -529,6 +553,7 @@ static const struct fpga_sec_mgr_ops m10bmc_sops = {
+ 	.write_blk = m10bmc_sec_write_blk,
+ 	.poll_complete = m10bmc_sec_poll_complete,
+ 	.cancel = m10bmc_sec_cancel,
++	.get_hw_errinfo = m10bmc_sec_hw_errinfo,
+ };
+ 
+ static int m10bmc_secure_probe(struct platform_device *pdev)
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0033-mfd-intel-m10-bmc-manage-access-to-max10-fw-handshak.patch new/debian/patches/fpga-ofs/0033-mfd-intel-m10-bmc-manage-access-to-max10-fw-handshak.patch
--- org/debian/patches/fpga-ofs/0033-mfd-intel-m10-bmc-manage-access-to-max10-fw-handshak.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0033-mfd-intel-m10-bmc-manage-access-to-max10-fw-handshak.patch	2021-07-20 06:17:11.384844924 +0200
@@ -0,0 +1,208 @@
+From 4be539003780315ba58c43a36e4f9f446af5e5b4 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Wed, 28 Oct 2020 15:50:51 -0700
+Subject: [PATCH 033/149] mfd: intel-m10-bmc: manage access to max10 fw
+ handshake registers
+
+Manage access to NIOS FW handshakes by using a rw semaphore
+to prevent accesses to handshake registers during a secure
+update.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+---
+ drivers/mfd/intel-m10-bmc.c       | 86 +++++++++++++++++++++++++++++++
+ include/linux/mfd/intel-m10-bmc.h | 35 ++++++++++---
+ 2 files changed, 114 insertions(+), 7 deletions(-)
+
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index adbfb17713b1..7f5d6b686c64 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -38,6 +38,91 @@ m10bmc_init_cells_platdata(struct intel_m10bmc_platdata *pdata,
+ 	}
+ }
+ 
++static const struct regmap_range n3000_fw_handshake_regs[] = {
++	regmap_reg_range(M10BMC_TELEM_START, M10BMC_TELEM_END),
++};
++
++int m10bmc_fw_state_enter(struct intel_m10bmc *m10bmc,
++			  enum m10bmc_fw_state new_state)
++{
++	int ret = 0;
++
++	if (new_state == M10BMC_FW_STATE_NORMAL)
++		return -EINVAL;
++
++	down_write(&m10bmc->bmcfw_lock);
++
++	if (m10bmc->bmcfw_state == M10BMC_FW_STATE_NORMAL)
++		m10bmc->bmcfw_state = new_state;
++	else if (m10bmc->bmcfw_state != new_state)
++		ret = -EBUSY;
++
++	up_write(&m10bmc->bmcfw_lock);
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(m10bmc_fw_state_enter);
++
++void m10bmc_fw_state_exit(struct intel_m10bmc *m10bmc)
++{
++	down_write(&m10bmc->bmcfw_lock);
++
++	m10bmc->bmcfw_state = M10BMC_FW_STATE_NORMAL;
++
++	up_write(&m10bmc->bmcfw_lock);
++}
++EXPORT_SYMBOL_GPL(m10bmc_fw_state_exit);
++
++static bool is_handshake_sys_reg(unsigned int offset)
++{
++	return regmap_reg_in_ranges(offset, n3000_fw_handshake_regs,
++				    ARRAY_SIZE(n3000_fw_handshake_regs));
++}
++
++int m10bmc_sys_read(struct intel_m10bmc *m10bmc, unsigned int offset,
++		    unsigned int *val)
++{
++	int ret;
++
++	if (!is_handshake_sys_reg(offset))
++		return m10bmc_raw_read(m10bmc, M10BMC_SYS_BASE + (offset), val);
++
++	down_read(&m10bmc->bmcfw_lock);
++
++	if (m10bmc->bmcfw_state == M10BMC_FW_STATE_SEC_UPDATE)
++		ret = -EBUSY;
++	else
++		ret = m10bmc_raw_read(m10bmc, M10BMC_SYS_BASE + (offset), val);
++
++	up_read(&m10bmc->bmcfw_lock);
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(m10bmc_sys_read);
++
++int m10bmc_sys_update_bits(struct intel_m10bmc *m10bmc, unsigned int offset,
++			   unsigned int msk, unsigned int val)
++{
++	int ret;
++
++	if (!is_handshake_sys_reg(offset))
++		return regmap_update_bits(m10bmc->regmap,
++					  M10BMC_SYS_BASE + (offset), msk, val);
++
++	down_read(&m10bmc->bmcfw_lock);
++
++	if (m10bmc->bmcfw_state == M10BMC_FW_STATE_SEC_UPDATE)
++		ret = -EBUSY;
++	else
++		ret = regmap_update_bits(m10bmc->regmap,
++					 M10BMC_SYS_BASE + (offset), msk, val);
++
++	up_read(&m10bmc->bmcfw_lock);
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(m10bmc_sys_update_bits);
++
+ static struct regmap_config intel_m10bmc_regmap_config = {
+ 	.reg_bits = 32,
+ 	.val_bits = 32,
+@@ -123,6 +208,7 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ 	if (!ddata)
+ 		return -ENOMEM;
+ 
++	init_rwsem(&ddata->bmcfw_lock);
+ 	ddata->dev = dev;
+ 
+ 	ddata->regmap =
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 64a82949f5cc..33d4b66281cb 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -8,6 +8,7 @@
+ #define __MFD_INTEL_M10_BMC_H
+ 
+ #include <linux/regmap.h>
++#include <linux/rwsem.h>
+ 
+ #define M10BMC_LEGACY_SYS_BASE		0x300400
+ #define M10BMC_SYS_BASE			0x300800
+@@ -31,6 +32,10 @@
+ #define SERDES_VERSION			GENMASK(15, 0)
+ #define SBUS_VERSION			GENMASK(31, 16)
+ 
++/* Telemetry registers */
++#define M10BMC_TELEM_START		0x100
++#define M10BMC_TELEM_END		0x33c
++
+ /* Secure update doorbell register, in system register region */
+ #define M10BMC_DOORBELL			0x400
+ 
+@@ -126,14 +131,22 @@ struct intel_m10bmc_platdata {
+ 	struct intel_m10bmc_retimer_pdata *retimer;
+ };
+ 
++enum m10bmc_fw_state {
++	M10BMC_FW_STATE_NORMAL,
++	M10BMC_FW_STATE_SEC_UPDATE,
++};
++
+ /**
+  * struct intel_m10bmc - Intel MAX 10 BMC parent driver data structure
+  * @dev: this device
+  * @regmap: the regmap used to access registers by m10bmc itself
++ * @bmcfw_state: BMC firmware running state.
+  */
+ struct intel_m10bmc {
+ 	struct device *dev;
+ 	struct regmap *regmap;
++	struct rw_semaphore bmcfw_lock;
++	enum m10bmc_fw_state bmcfw_state;
+ };
+ 
+ /*
+@@ -141,6 +154,7 @@ struct intel_m10bmc {
+  *
+  * m10bmc_raw_read - read m10bmc register per addr
+  * m10bmc_sys_read - read m10bmc system register per offset
++ * m10bmc_sys_update_bits - update m10bmc system register per offset
+  */
+ static inline int
+ m10bmc_raw_read(struct intel_m10bmc *m10bmc, unsigned int addr,
+@@ -156,15 +170,22 @@ m10bmc_raw_read(struct intel_m10bmc *m10bmc, unsigned int addr,
+ 	return ret;
+ }
+ 
++int m10bmc_sys_read(struct intel_m10bmc *m10bmc, unsigned int offset,
++		    unsigned int *val);
++
++int m10bmc_sys_update_bits(struct intel_m10bmc *m10bmc, unsigned int offset,
++			   unsigned int msk, unsigned int val);
++
+ /*
+- * The base of the system registers could be configured by HW developers, and
+- * in HW SPEC, the base is not added to the addresses of the system registers.
++ * Track the state of the firmware, as it is not available for
++ * register handshakes during secure updates.
+  *
+- * This macro helps to simplify the accessing of the system registers. And if
+- * the base is reconfigured in HW, SW developers could simply change the
+- * M10BMC_SYS_BASE accordingly.
++ * m10bmc_fw_state_enter - firmware is unavailable for handshakes
++ * m10bmc_fw_state_exit  - firmware is available for handshakes
+  */
+-#define m10bmc_sys_read(m10bmc, offset, val) \
+-	m10bmc_raw_read(m10bmc, M10BMC_SYS_BASE + (offset), val)
++int m10bmc_fw_state_enter(struct intel_m10bmc *m10bmc,
++			  enum m10bmc_fw_state new_state);
++
++void m10bmc_fw_state_exit(struct intel_m10bmc *m10bmc);
+ 
+ #endif /* __MFD_INTEL_M10_BMC_H */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0034-fpga-m10bmc-sec-disable-max10-fw-handshakes-during-u.patch new/debian/patches/fpga-ofs/0034-fpga-m10bmc-sec-disable-max10-fw-handshakes-during-u.patch
--- org/debian/patches/fpga-ofs/0034-fpga-m10bmc-sec-disable-max10-fw-handshakes-during-u.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0034-fpga-m10bmc-sec-disable-max10-fw-handshakes-during-u.patch	2021-07-20 06:17:11.384844924 +0200
@@ -0,0 +1,141 @@
+From 983ee466ae13de95a54fa286447525a7e952568b Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:52 -0700
+Subject: [PATCH 034/149] fpga: m10bmc-sec: disable max10 fw handshakes during
+ update
+
+Disable accesses to NIOS FW handshake registers during a secure
+update. During updates, the NIOS soft processor is fully occupied
+and is unable to respond to handshakes.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 63 +++++++++++++++++------------
+ 1 file changed, 38 insertions(+), 25 deletions(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index df88a3346b45..3a5d9f2c2878 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -264,12 +264,11 @@ static enum fpga_sec_err rsu_update_init(struct m10bmc_sec *sec)
+ 	u32 doorbell, status;
+ 	int ret;
+ 
+-	ret = regmap_update_bits(sec->m10bmc->regmap,
+-				 M10BMC_SYS_BASE + M10BMC_DOORBELL,
+-				 DRBL_RSU_REQUEST | DRBL_HOST_STATUS,
+-				 DRBL_RSU_REQUEST |
+-				 FIELD_PREP(DRBL_HOST_STATUS,
+-					    HOST_STATUS_IDLE));
++	ret = m10bmc_sys_update_bits(sec->m10bmc, M10BMC_DOORBELL,
++				     DRBL_RSU_REQUEST | DRBL_HOST_STATUS,
++				     DRBL_RSU_REQUEST |
++				     FIELD_PREP(DRBL_HOST_STATUS,
++						HOST_STATUS_IDLE));
+ 	if (ret)
+ 		return FPGA_SEC_ERR_RW_ERROR;
+ 
+@@ -337,11 +336,10 @@ static enum fpga_sec_err rsu_send_data(struct m10bmc_sec *sec)
+ 	u32 doorbell;
+ 	int ret;
+ 
+-	ret = regmap_update_bits(sec->m10bmc->regmap,
+-				 M10BMC_SYS_BASE + M10BMC_DOORBELL,
+-				 DRBL_HOST_STATUS,
+-				 FIELD_PREP(DRBL_HOST_STATUS,
+-					    HOST_STATUS_WRITE_DONE));
++	ret = m10bmc_sys_update_bits(sec->m10bmc, M10BMC_DOORBELL,
++				     DRBL_HOST_STATUS,
++				     FIELD_PREP(DRBL_HOST_STATUS,
++						HOST_STATUS_WRITE_DONE));
+ 	if (ret)
+ 		return FPGA_SEC_ERR_RW_ERROR;
+ 
+@@ -415,11 +413,19 @@ static enum fpga_sec_err m10bmc_sec_prepare(struct fpga_sec_mgr *smgr)
+ 	if (ret != FPGA_SEC_ERR_NONE)
+ 		return ret;
+ 
++	ret = m10bmc_fw_state_enter(sec->m10bmc, M10BMC_FW_STATE_SEC_UPDATE);
++	if (ret)
++		return FPGA_SEC_ERR_BUSY;
++
+ 	ret = rsu_update_init(sec);
+ 	if (ret != FPGA_SEC_ERR_NONE)
+-		return ret;
++		goto fw_state_exit;
+ 
+-	return rsu_prog_ready(sec);
++	ret = rsu_prog_ready(sec);
++
++fw_state_exit:
++	m10bmc_fw_state_exit(sec->m10bmc);
++	return ret;
+ }
+ 
+ static enum fpga_sec_err
+@@ -462,9 +468,13 @@ static enum fpga_sec_err m10bmc_sec_poll_complete(struct fpga_sec_mgr *smgr)
+ 	u32 doorbell;
+ 	int ret;
+ 
++	ret = m10bmc_fw_state_enter(sec->m10bmc, M10BMC_FW_STATE_SEC_UPDATE);
++	if (ret)
++		return FPGA_SEC_ERR_BUSY;
++
+ 	result = rsu_send_data(sec);
+ 	if (result != FPGA_SEC_ERR_NONE)
+-		return result;
++		goto fw_state_exit;
+ 
+ 	ret = rsu_check_complete(sec, &doorbell);
+ 	poll_timeout = jiffies + msecs_to_jiffies(RSU_COMPLETE_TIMEOUT_MS);
+@@ -472,21 +482,25 @@ static enum fpga_sec_err m10bmc_sec_poll_complete(struct fpga_sec_mgr *smgr)
+ 	while (ret == -EAGAIN && !time_after(jiffies, poll_timeout)) {
+ 		msleep(RSU_COMPLETE_INTERVAL_MS);
+ 		ret = rsu_check_complete(sec, &doorbell);
+-		if (smgr->driver_unload)
+-			return FPGA_SEC_ERR_CANCELED;
++		if (smgr->driver_unload) {
++			result = FPGA_SEC_ERR_CANCELED;
++			goto fw_state_exit;
++		}
+ 	}
+ 
+ 	if (ret == -EAGAIN) {
+ 		log_error_regs(sec, doorbell);
+-		return FPGA_SEC_ERR_TIMEOUT;
++		result = FPGA_SEC_ERR_TIMEOUT;
+ 	} else if (ret == -EIO) {
+-		return FPGA_SEC_ERR_RW_ERROR;
++		result = FPGA_SEC_ERR_RW_ERROR;
+ 	} else if (ret) {
+ 		log_error_regs(sec, doorbell);
+-		return FPGA_SEC_ERR_HW_ERROR;
++		result = FPGA_SEC_ERR_HW_ERROR;
+ 	}
+ 
+-	return FPGA_SEC_ERR_NONE;
++fw_state_exit:
++	m10bmc_fw_state_exit(sec->m10bmc);
++	return result;
+ }
+ 
+ static enum fpga_sec_err m10bmc_sec_cancel(struct fpga_sec_mgr *smgr)
+@@ -502,11 +516,10 @@ static enum fpga_sec_err m10bmc_sec_cancel(struct fpga_sec_mgr *smgr)
+ 	if (rsu_prog(doorbell) != RSU_PROG_READY)
+ 		return FPGA_SEC_ERR_BUSY;
+ 
+-	ret = regmap_update_bits(sec->m10bmc->regmap,
+-				 M10BMC_SYS_BASE + M10BMC_DOORBELL,
+-				 DRBL_HOST_STATUS,
+-				 FIELD_PREP(DRBL_HOST_STATUS,
+-					    HOST_STATUS_ABORT_RSU));
++	ret = m10bmc_sys_update_bits(sec->m10bmc, M10BMC_DOORBELL,
++				     DRBL_HOST_STATUS,
++				     FIELD_PREP(DRBL_HOST_STATUS,
++						HOST_STATUS_ABORT_RSU));
+ 
+ 	return ret ? FPGA_SEC_ERR_RW_ERROR : FPGA_SEC_ERR_NONE;
+ }
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0035-fpga-sec-mgr-add-image_load-sysfs-support.patch new/debian/patches/fpga-ofs/0035-fpga-sec-mgr-add-image_load-sysfs-support.patch
--- org/debian/patches/fpga-ofs/0035-fpga-sec-mgr-add-image_load-sysfs-support.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0035-fpga-sec-mgr-add-image_load-sysfs-support.patch	2021-07-20 06:17:11.384844924 +0200
@@ -0,0 +1,183 @@
+From 9d5f55de5fcb469c941f18c89f99cfc9c6249414 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:53 -0700
+Subject: [PATCH 035/149] fpga: sec-mgr: add image_load sysfs support
+
+Add a bmc_image_load sysfs file to the update directory.
+This file can be written to trigger a reload of the BMC
+image.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+---
+ .../ABI/testing/sysfs-class-fpga-sec-mgr      | 21 +++++++
+ drivers/fpga/fpga-sec-mgr.c                   | 55 +++++++++++++++++++
+ include/linux/fpga/fpga-sec-mgr.h             | 15 +++++
+ 3 files changed, 91 insertions(+)
+
+diff --git a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+index 5a2dad0d0941..a153a274cd51 100644
+--- a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
++++ b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+@@ -141,3 +141,24 @@ Description:	Read-only. Returns a 64 bit error value providing
+ 		If this file is read while a secure update is in
+ 		progress, then the read will fail with EBUSY.
+ 		Format: "0x%llx".
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/available_images
++Date:		Sep 2020
++KernelVersion:  5.10
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read-only. This file returns a space separated list of
++		key words that may be written into the image_load file
++		described below. These keywords decribe an FPGA, BMC,
++		or firmware image in FLASH or EEPROM storage that may
++		be loaded.
++
++What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/image_load
++Date:		Sep 2020
++KernelVersion:  5.10
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Write-only. A key word may be written to this file to
++		trigger a reload of an FPGA, BMC, or firmware image from
++		FLASH or EEPROM. Refer to the available_images file for a
++		list of supported key words for the underlying device.
++		Writing an unsupported string to this file will result in
++		EINVAL being returned.
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index 7ea60147b248..72b61dc173db 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -465,6 +465,43 @@ static ssize_t cancel_store(struct device *dev, struct device_attribute *attr,
+ }
+ static DEVICE_ATTR_WO(cancel);
+ 
++static ssize_t available_images_show(struct device *dev,
++				     struct device_attribute *attr, char *buf)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
++	const struct image_load *hndlr;
++	ssize_t count = 0;
++
++	for (hndlr = smgr->sops->image_load; hndlr->name; hndlr++) {
++		count += scnprintf(buf + count, PAGE_SIZE - count,
++				   "%s ", hndlr->name);
++	}
++
++	buf[count - 1] = '\n';
++
++	return count;
++}
++static DEVICE_ATTR_RO(available_images);
++
++static ssize_t image_load_store(struct device *dev,
++				struct device_attribute *attr,
++				const char *buf, size_t count)
++{
++	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
++	const struct image_load *hndlr;
++	int ret = -EINVAL;
++
++	for (hndlr = smgr->sops->image_load; hndlr->name; hndlr++) {
++		if (sysfs_streq(buf, hndlr->name)) {
++			ret = hndlr->load_image(smgr);
++			break;
++		}
++	}
++
++	return ret ? : count;
++}
++static DEVICE_ATTR_WO(image_load);
++
+ static umode_t
+ sec_mgr_update_visible(struct kobject *kobj, struct attribute *attr, int n)
+ {
+@@ -473,6 +510,11 @@ sec_mgr_update_visible(struct kobject *kobj, struct attribute *attr, int n)
+ 	if (attr == &dev_attr_hw_errinfo.attr && !smgr->sops->get_hw_errinfo)
+ 		return 0;
+ 
++	if ((!smgr->sops->image_load || !smgr->sops->image_load->name) &&
++	    (attr == &dev_attr_available_images.attr ||
++	     attr == &dev_attr_image_load.attr))
++		return 0;
++
+ 	return attr->mode;
+ }
+ 
+@@ -483,6 +525,8 @@ static struct attribute *sec_mgr_update_attrs[] = {
+ 	&dev_attr_error.attr,
+ 	&dev_attr_remaining_size.attr,
+ 	&dev_attr_hw_errinfo.attr,
++	&dev_attr_available_images.attr,
++	&dev_attr_image_load.attr,
+ 	NULL,
+ };
+ 
+@@ -569,6 +613,7 @@ struct fpga_sec_mgr *
+ fpga_sec_mgr_create(struct device *dev, const char *name,
+ 		    const struct fpga_sec_mgr_ops *sops, void *priv)
+ {
++	const struct image_load *hndlr;
+ 	struct fpga_sec_mgr *smgr;
+ 	int id, ret;
+ 
+@@ -587,6 +632,16 @@ fpga_sec_mgr_create(struct device *dev, const char *name,
+ 		return NULL;
+ 	}
+ 
++	if (sops->image_load) {
++		for (hndlr = sops->image_load; hndlr->name; hndlr++) {
++			if (!hndlr->load_image) {
++				dev_err(dev, "No image_load trigger for %s\n",
++					hndlr->name);
++				return ERR_PTR(-EINVAL);
++			}
++		}
++	}
++
+ 	if (!name || !strlen(name)) {
+ 		dev_err(dev, "Attempt to register with no name!\n");
+ 		return NULL;
+diff --git a/include/linux/fpga/fpga-sec-mgr.h b/include/linux/fpga/fpga-sec-mgr.h
+index 697cf28b6a99..4a979b17ab27 100644
+--- a/include/linux/fpga/fpga-sec-mgr.h
++++ b/include/linux/fpga/fpga-sec-mgr.h
+@@ -27,6 +27,16 @@ enum fpga_sec_err {
+ 	FPGA_SEC_ERR_MAX
+ };
+ 
++/**
++ * struct image_load - device specific image-load triggers
++ * @name:	    Required: keyword used to enable the trigger
++ * @load_image:	    Required: pointer to the trigger callback function
++ */
++struct image_load {
++	const char *name;
++	int (*load_image)(struct fpga_sec_mgr *smgr);
++};
++
+ /**
+  * struct fpga_sec_mgr_ops - device specific operations
+  * @user_flash_count:	    Optional: Return sysfs string output for FPGA
+@@ -63,6 +73,10 @@ enum fpga_sec_err {
+  * @get_hw_errinfo:	    Optional: Return u64 hw specific error info.
+  *			    The software err_code may used to determine
+  *			    whether the hw error info is applicable.
++ * @image_load:		    pointer to array of image_load structures,
++ *			    { } member terminated. These structures describe
++ *			    image load triggers for BMC, FPGA, or firmware
++ *			    images.
+  */
+ struct fpga_sec_mgr_ops {
+ 	int (*user_flash_count)(struct fpga_sec_mgr *smgr);
+@@ -91,6 +105,7 @@ struct fpga_sec_mgr_ops {
+ 	void (*cleanup)(struct fpga_sec_mgr *smgr);
+ 	enum fpga_sec_err (*cancel)(struct fpga_sec_mgr *smgr);
+ 	u64 (*get_hw_errinfo)(struct fpga_sec_mgr *smgr);
++	struct image_load *image_load;	/* terminated with { } member */
+ };
+ 
+ /* Update progress codes */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0036-fpga-m10bmc-sec-m10bmc_sec_bmc_image_load-callback.patch new/debian/patches/fpga-ofs/0036-fpga-m10bmc-sec-m10bmc_sec_bmc_image_load-callback.patch
--- org/debian/patches/fpga-ofs/0036-fpga-m10bmc-sec-m10bmc_sec_bmc_image_load-callback.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0036-fpga-m10bmc-sec-m10bmc_sec_bmc_image_load-callback.patch	2021-07-20 06:17:11.384844924 +0200
@@ -0,0 +1,148 @@
+From cc8d07ff89c653a60405a7efb828128006197a4b Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:54 -0700
+Subject: [PATCH 036/149] fpga: m10bmc-sec: m10bmc_sec_bmc_image_load callback
+
+Create m10bmc_sec_bmc_image_load() callback function to
+trigger a load of a new BMC image.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 104 ++++++++++++++++++++++------
+ 1 file changed, 84 insertions(+), 20 deletions(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 3a5d9f2c2878..48bc462c10ca 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -548,29 +548,89 @@ static u64 m10bmc_sec_hw_errinfo(struct fpga_sec_mgr *smgr)
+ 	}
+ }
+ 
+-static const struct fpga_sec_mgr_ops m10bmc_sops = {
+-	.user_flash_count = m10bmc_user_flash_count,
+-	.bmc_root_entry_hash = m10bmc_bmc_reh,
+-	.sr_root_entry_hash = m10bmc_sr_reh,
+-	.pr_root_entry_hash = m10bmc_pr_reh,
+-	.bmc_canceled_csks = m10bmc_bmc_canceled_csks,
+-	.sr_canceled_csks = m10bmc_sr_canceled_csks,
+-	.pr_canceled_csks = m10bmc_pr_canceled_csks,
+-	.bmc_reh_size = m10bmc_bmc_reh_size,
+-	.sr_reh_size = m10bmc_sr_reh_size,
+-	.pr_reh_size = m10bmc_pr_reh_size,
+-	.bmc_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
+-	.sr_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
+-	.pr_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
+-	.prepare = m10bmc_sec_prepare,
+-	.write_blk = m10bmc_sec_write_blk,
+-	.poll_complete = m10bmc_sec_poll_complete,
+-	.cancel = m10bmc_sec_cancel,
+-	.get_hw_errinfo = m10bmc_sec_hw_errinfo,
++static int m10bmc_sec_bmc_image_load(struct fpga_sec_mgr *smgr,
++				     unsigned int val)
++{
++	struct m10bmc_sec *sec = smgr->priv;
++	u32 doorbell;
++	int ret;
++
++	if (val > 1) {
++		dev_err(sec->dev, "%s invalid reload val = %d\n",
++			__func__, val);
++		return -EINVAL;
++	}
++
++	ret = m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, &doorbell);
++	if (ret)
++		return ret;
++
++	if (doorbell & DRBL_REBOOT_DISABLED)
++		return -EBUSY;
++
++	return m10bmc_sys_update_bits(sec->m10bmc, M10BMC_DOORBELL,
++				     DRBL_CONFIG_SEL | DRBL_REBOOT_REQ,
++				     FIELD_PREP(DRBL_CONFIG_SEL, val) |
++				     DRBL_REBOOT_REQ);
++}
++
++static int m10bmc_sec_bmc_image_load_0(struct fpga_sec_mgr *smgr)
++{
++	return m10bmc_sec_bmc_image_load(smgr, 0);
++}
++
++static int m10bmc_sec_bmc_image_load_1(struct fpga_sec_mgr *smgr)
++{
++	return m10bmc_sec_bmc_image_load(smgr, 1);
++}
++
++static struct image_load n3000_image_load_hndlrs[] = {
++	{
++		.name = "bmc_user",
++		.load_image = m10bmc_sec_bmc_image_load_0,
++	},
++	{
++		.name = "bmc_factory",
++		.load_image = m10bmc_sec_bmc_image_load_1,
++	},
++	{}
+ };
+ 
++static struct fpga_sec_mgr_ops *
++m10bmc_sops_create(struct device *dev)
++{
++	struct fpga_sec_mgr_ops *sops;
++
++	sops = devm_kzalloc(dev, sizeof(*sops), GFP_KERNEL);
++	if (!sops)
++		return NULL;
++
++	sops->user_flash_count = m10bmc_user_flash_count;
++	sops->bmc_root_entry_hash = m10bmc_bmc_reh;
++	sops->sr_root_entry_hash = m10bmc_sr_reh;
++	sops->pr_root_entry_hash = m10bmc_pr_reh;
++	sops->bmc_canceled_csks = m10bmc_bmc_canceled_csks;
++	sops->sr_canceled_csks = m10bmc_sr_canceled_csks;
++	sops->pr_canceled_csks = m10bmc_pr_canceled_csks;
++	sops->bmc_reh_size = m10bmc_bmc_reh_size;
++	sops->sr_reh_size = m10bmc_sr_reh_size;
++	sops->pr_reh_size = m10bmc_pr_reh_size;
++	sops->bmc_canceled_csk_nbits = m10bmc_csk_cancel_nbits;
++	sops->sr_canceled_csk_nbits = m10bmc_csk_cancel_nbits;
++	sops->pr_canceled_csk_nbits = m10bmc_csk_cancel_nbits;
++	sops->prepare = m10bmc_sec_prepare;
++	sops->write_blk = m10bmc_sec_write_blk;
++	sops->poll_complete = m10bmc_sec_poll_complete;
++	sops->cancel = m10bmc_sec_cancel;
++	sops->get_hw_errinfo = m10bmc_sec_hw_errinfo;
++	sops->image_load = n3000_image_load_hndlrs;
++
++	return sops;
++}
++
+ static int m10bmc_secure_probe(struct platform_device *pdev)
+ {
++	struct fpga_sec_mgr_ops *sops;
+ 	struct fpga_sec_mgr *smgr;
+ 	struct m10bmc_sec *sec;
+ 	int ret;
+@@ -579,12 +639,16 @@ static int m10bmc_secure_probe(struct platform_device *pdev)
+ 	if (!sec)
+ 		return -ENOMEM;
+ 
++	sops = m10bmc_sops_create(&pdev->dev);
++	if (!sops)
++		return -ENOMEM;
++
+ 	sec->dev = &pdev->dev;
+ 	sec->m10bmc = dev_get_drvdata(pdev->dev.parent);
+ 	dev_set_drvdata(&pdev->dev, sec);
+ 
+ 	smgr = devm_fpga_sec_mgr_create(sec->dev, "Max10 BMC Secure Update",
+-					&m10bmc_sops, sec);
++					sops, sec);
+ 	if (!smgr) {
+ 		dev_err(sec->dev,
+ 			"Security manager failed to start: %d\n", ret);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0037-fpga-m10bmc-sec-m10bmc_sec_retimer_load-callback.patch new/debian/patches/fpga-ofs/0037-fpga-m10bmc-sec-m10bmc_sec_retimer_load-callback.patch
--- org/debian/patches/fpga-ofs/0037-fpga-m10bmc-sec-m10bmc_sec_retimer_load-callback.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0037-fpga-m10bmc-sec-m10bmc_sec_retimer_load-callback.patch	2021-07-20 06:17:11.384844924 +0200
@@ -0,0 +1,243 @@
+From 209ee1d9742b541a180837c6244f6310c413d4f4 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 28 Oct 2020 15:50:55 -0700
+Subject: [PATCH 037/149] fpga: m10bmc-sec: m10bmc_sec_retimer_load callback
+
+Create m10bmc_sec_retimer_load() callback function
+to provide a trigger for new retimer firmware.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 159 ++++++++++++++++++++++++++++
+ include/linux/mfd/intel-m10-bmc.h   |  31 ++++++
+ 2 files changed, 190 insertions(+)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 48bc462c10ca..a35437d4db42 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -584,6 +584,161 @@ static int m10bmc_sec_bmc_image_load_1(struct fpga_sec_mgr *smgr)
+ 	return m10bmc_sec_bmc_image_load(smgr, 1);
+ }
+ 
++static int retimer_check_idle(struct m10bmc_sec *sec)
++{
++	u32 doorbell;
++	int ret;
++
++	ret = m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, &doorbell);
++	if (ret)
++		return -EIO;
++
++	if (rsu_prog(doorbell) != RSU_PROG_IDLE &&
++	    rsu_prog(doorbell) != RSU_PROG_RSU_DONE &&
++	    rsu_prog(doorbell) != RSU_PROG_PKVL_PROM_DONE) {
++		log_error_regs(sec, doorbell);
++		return -EBUSY;
++	}
++
++	return 0;
++}
++
++static int trigger_retimer_eeprom_load(struct m10bmc_sec *sec)
++{
++	struct intel_m10bmc *m10bmc = sec->m10bmc;
++	unsigned int val;
++	int ret;
++
++	ret = m10bmc_sys_update_bits(m10bmc, M10BMC_DOORBELL,
++				     DRBL_PKVL_EEPROM_LOAD_SEC,
++				     DRBL_PKVL_EEPROM_LOAD_SEC);
++	if (ret)
++		return ret;
++
++	/*
++	 * If the current NIOS FW supports this retimer update feature, then
++	 * it will clear the same PKVL_EEPROM_LOAD bit in 2 seconds. Otherwise
++	 * the driver needs to clear the PKVL_EEPROM_LOAD bit manually and
++	 * return an error code.
++	 */
++	ret = regmap_read_poll_timeout(m10bmc->regmap,
++				       M10BMC_SYS_BASE + M10BMC_DOORBELL,
++				       val,
++				       (!(val & DRBL_PKVL_EEPROM_LOAD_SEC)),
++				       PKVL_EEPROM_LOAD_INTERVAL_US,
++				       PKVL_EEPROM_LOAD_TIMEOUT_US);
++	if (ret == -ETIMEDOUT) {
++		dev_err(sec->dev, "%s PKVL_EEPROM_LOAD clear timedout\n",
++			__func__);
++		m10bmc_sys_update_bits(m10bmc, M10BMC_DOORBELL,
++				       DRBL_PKVL_EEPROM_LOAD_SEC, 0);
++		ret = -ENODEV;
++	} else if (ret) {
++		dev_err(sec->dev, "%s poll EEPROM_LOAD error %d\n",
++			__func__, ret);
++	}
++
++	return ret;
++}
++
++static int poll_retimer_eeprom_load_done(struct m10bmc_sec *sec)
++{
++	struct intel_m10bmc *m10bmc = sec->m10bmc;
++	unsigned int doorbell;
++	int ret;
++
++	/*
++	 * RSU_STAT_PKVL_REJECT indicates that the current image is
++	 * already programmed. RSU_PROG_PKVL_PROM_DONE that the firmware
++	 * update process has finished, but does not necessarily indicate
++	 * a successful update.
++	 */
++	ret = regmap_read_poll_timeout(m10bmc->regmap,
++				       M10BMC_SYS_BASE + M10BMC_DOORBELL,
++				       doorbell,
++				       ((rsu_prog(doorbell) ==
++					 RSU_PROG_PKVL_PROM_DONE) ||
++					(rsu_stat(doorbell) ==
++					 RSU_STAT_PKVL_REJECT)),
++				       PKVL_PRELOAD_INTERVAL_US,
++				       PKVL_PRELOAD_TIMEOUT_US);
++	if (ret) {
++		if (ret == -ETIMEDOUT)
++			dev_err(sec->dev,
++				"%s Doorbell check timedout: 0x%08x\n",
++				__func__, doorbell);
++		else
++			dev_err(sec->dev, "%s poll Doorbell error\n",
++				__func__);
++		return ret;
++	}
++
++	if (rsu_stat(doorbell) == RSU_STAT_PKVL_REJECT) {
++		dev_err(sec->dev, "%s duplicate image rejected\n", __func__);
++		return -ECANCELED;
++	}
++
++	return 0;
++}
++
++static int poll_retimer_preload_done(struct m10bmc_sec *sec)
++{
++	struct intel_m10bmc *m10bmc = sec->m10bmc;
++	unsigned int val;
++	int ret;
++
++	/*
++	 * Wait for the updated firmware to be loaded by the PKVL device
++	 * and confirm that the updated firmware is operational
++	 */
++	ret = regmap_read_poll_timeout(m10bmc->regmap,
++				       M10BMC_SYS_BASE + PKVL_POLLING_CTRL, val,
++				       ((val & PKVL_PRELOAD) == PKVL_PRELOAD),
++				       PKVL_PRELOAD_INTERVAL_US,
++				       PKVL_PRELOAD_TIMEOUT_US);
++	if (ret) {
++		dev_err(sec->dev, "%s poll PKVL_PRELOAD error %d\n",
++			__func__, ret);
++		return ret;
++	}
++
++	if ((val & PKVL_UPG_STATUS_MASK) != PKVL_UPG_STATUS_GOOD) {
++		dev_err(sec->dev, "%s error detected during upgrade\n",
++			__func__);
++		return -EIO;
++	}
++
++	return 0;
++}
++
++static int m10bmc_sec_retimer_eeprom_load(struct fpga_sec_mgr *smgr)
++{
++	struct m10bmc_sec *sec = smgr->priv;
++	int ret;
++
++	ret = m10bmc_fw_state_enter(sec->m10bmc, M10BMC_FW_STATE_SEC_UPDATE);
++	if (ret)
++		return -EBUSY;
++
++	ret = retimer_check_idle(sec);
++	if (ret)
++		goto fw_state_exit;
++
++	ret = trigger_retimer_eeprom_load(sec);
++	if (ret)
++		goto fw_state_exit;
++
++	ret = poll_retimer_eeprom_load_done(sec);
++	if (ret)
++		goto fw_state_exit;
++
++	ret = poll_retimer_preload_done(sec);
++
++fw_state_exit:
++	m10bmc_fw_state_exit(sec->m10bmc);
++	return ret;
++}
++
+ static struct image_load n3000_image_load_hndlrs[] = {
+ 	{
+ 		.name = "bmc_user",
+@@ -593,6 +748,10 @@ static struct image_load n3000_image_load_hndlrs[] = {
+ 		.name = "bmc_factory",
+ 		.load_image = m10bmc_sec_bmc_image_load_1,
+ 	},
++	{
++		.name = "retimer_fw",
++		.load_image = m10bmc_sec_retimer_eeprom_load,
++	},
+ 	{}
+ };
+ 
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 33d4b66281cb..827117416598 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -26,12 +26,43 @@
+ #define M10BMC_VER_LEGACY_INVALID	0xffffffff
+ 
+ /* PKVL related registers, in system register region */
++#define PKVL_POLLING_CTRL		0x80
++#define POLLING_MODE			GENMASK(15, 0)
++#define PKVL_A_PRELOAD			BIT(16)
++#define PKVL_A_PRELOAD_TIMEOUT		BIT(17)
++#define PKVL_A_DATA_TOO_BIG		BIT(18)
++#define PKVL_A_HDR_CHECKSUM		BIT(20)
++#define PKVL_B_PRELOAD			BIT(24)
++#define PKVL_B_PRELOAD_TIMEOUT		BIT(25)
++#define PKVL_B_DATA_TOO_BIG		BIT(26)
++#define PKVL_B_HDR_CHECKSUM		BIT(28)
++#define PKVL_EEPROM_UPG_STATUS		GENMASK(31, 16)
+ #define PKVL_LINK_STATUS		0x164
+ #define PKVL_A_VERSION			0x254
+ #define PKVL_B_VERSION			0x258
+ #define SERDES_VERSION			GENMASK(15, 0)
+ #define SBUS_VERSION			GENMASK(31, 16)
+ 
++#define PKVL_PRELOAD			(PKVL_A_PRELOAD | PKVL_B_PRELOAD)
++#define PKVL_PRELOAD_TIMEOUT		(PKVL_A_PRELOAD_TIMEOUT | \
++					 PKVL_B_PRELOAD_TIMEOUT)
++#define PKVL_DATA_TOO_BIG		(PKVL_A_DATA_TOO_BIG | \
++					 PKVL_B_DATA_TOO_BIG)
++#define PKVL_HDR_CHECKSUM		(PKVL_A_HDR_CHECKSUM | \
++					 PKVL_B_HDR_CHECKSUM)
++
++#define PKVL_UPG_STATUS_MASK		(PKVL_PRELOAD | PKVL_PRELOAD_TIMEOUT |\
++					 PKVL_DATA_TOO_BIG | PKVL_HDR_CHECKSUM)
++#define PKVL_UPG_STATUS_GOOD		(PKVL_PRELOAD | PKVL_HDR_CHECKSUM)
++
++/* interval 100ms and timeout 2s */
++#define PKVL_EEPROM_LOAD_INTERVAL_US	(100 * 1000)
++#define PKVL_EEPROM_LOAD_TIMEOUT_US	(2 * 1000 * 1000)
++
++/* interval 100ms and timeout 30s */
++#define PKVL_PRELOAD_INTERVAL_US	(100 * 1000)
++#define PKVL_PRELOAD_TIMEOUT_US		(30 * 1000 * 1000)
++
+ /* Telemetry registers */
+ #define M10BMC_TELEM_START		0x100
+ #define M10BMC_TELEM_END		0x33c
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0038-fpga-m10bmc-sec-removed-uninitialized-variable-ref.patch new/debian/patches/fpga-ofs/0038-fpga-m10bmc-sec-removed-uninitialized-variable-ref.patch
--- org/debian/patches/fpga-ofs/0038-fpga-m10bmc-sec-removed-uninitialized-variable-ref.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0038-fpga-m10bmc-sec-removed-uninitialized-variable-ref.patch	2021-07-20 06:17:11.388844913 +0200
@@ -0,0 +1,38 @@
+From a20f2aa447aee1852740f10edb4fd83f81379872 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 3 Nov 2020 10:40:34 -0800
+Subject: [PATCH 038/149] fpga: m10bmc-sec: removed uninitialized variable ref
+
+Remove an uninitialized variable reference identified
+through static analysis.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index a35437d4db42..29960b27dd03 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -792,7 +792,6 @@ static int m10bmc_secure_probe(struct platform_device *pdev)
+ 	struct fpga_sec_mgr_ops *sops;
+ 	struct fpga_sec_mgr *smgr;
+ 	struct m10bmc_sec *sec;
+-	int ret;
+ 
+ 	sec = devm_kzalloc(&pdev->dev, sizeof(*sec), GFP_KERNEL);
+ 	if (!sec)
+@@ -809,8 +808,7 @@ static int m10bmc_secure_probe(struct platform_device *pdev)
+ 	smgr = devm_fpga_sec_mgr_create(sec->dev, "Max10 BMC Secure Update",
+ 					sops, sec);
+ 	if (!smgr) {
+-		dev_err(sec->dev,
+-			"Security manager failed to start: %d\n", ret);
++		dev_err(sec->dev, "Security manager failed to start");
+ 		return -ENOMEM;
+ 	}
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0039-mfd-intel-m10-bmc-expose-mac-address-and-count.patch new/debian/patches/fpga-ofs/0039-mfd-intel-m10-bmc-expose-mac-address-and-count.patch
--- org/debian/patches/fpga-ofs/0039-mfd-intel-m10-bmc-expose-mac-address-and-count.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0039-mfd-intel-m10-bmc-expose-mac-address-and-count.patch	2021-07-20 06:17:11.388844913 +0200
@@ -0,0 +1,124 @@
+From 3f29355c1e3dd07fedeeec583c9adc729015a1b0 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 26 May 2020 12:02:58 -0700
+Subject: [PATCH 039/149] mfd: intel-m10-bmc: expose mac address and count
+
+Create two sysfs entries for exposing the MAC address
+and count from the MAX10 BMC register space.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+---
+ .../ABI/testing/sysfs-driver-intel-m10-bmc    | 20 +++++++++
+ drivers/mfd/intel-m10-bmc.c                   | 43 +++++++++++++++++++
+ include/linux/mfd/intel-m10-bmc.h             |  9 ++++
+ 3 files changed, 72 insertions(+)
+
+diff --git a/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc
+index 979a2d62513f..c4febaefe0a7 100644
+--- a/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc
++++ b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc
+@@ -13,3 +13,23 @@ Contact:	Xu Yilun <yilun.xu@intel.com>
+ Description:	Read only. Returns the firmware version of Intel MAX10
+ 		BMC chip.
+ 		Format: "0x%x".
++
++What:		/sys/bus/spi/devices/.../mac_address
++Date:		December 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns the base mac address assigned to
++		the board managed by the Intel MAX10 BMC. It is
++		stored in flash and is mirrored in the MAX10 BMC
++		register space.
++		Format: "%02x:%02x:%02x:%02x:%02x:%02x".
++
++What:		/sys/bus/spi/devices/.../mac_count
++Date:		December 2020
++KernelVersion:  5.11
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns the number of mac addresses
++		assigned to the board managed by the Intel MAX10
++		BMC. This value is stored in flash and is mirrored
++		in the MAX10 BMC register space.
++		Format: "%u".
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index 7f5d6b686c64..ccc3c2861cb2 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -160,9 +160,52 @@ static ssize_t bmcfw_version_show(struct device *dev,
+ }
+ static DEVICE_ATTR_RO(bmcfw_version);
+ 
++static ssize_t mac_address_show(struct device *dev,
++				struct device_attribute *attr, char *buf)
++{
++	struct intel_m10bmc *max10 = dev_get_drvdata(dev);
++	unsigned int macaddr1, macaddr2;
++	int ret;
++
++	ret = m10bmc_sys_read(max10, M10BMC_MACADDR1, &macaddr1);
++	if (ret)
++		return ret;
++
++	ret = m10bmc_sys_read(max10, M10BMC_MACADDR2, &macaddr2);
++	if (ret)
++		return ret;
++
++	return sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
++		       (u8)FIELD_GET(M10BMC_MAC_BYTE1, macaddr1),
++		       (u8)FIELD_GET(M10BMC_MAC_BYTE2, macaddr1),
++		       (u8)FIELD_GET(M10BMC_MAC_BYTE3, macaddr1),
++		       (u8)FIELD_GET(M10BMC_MAC_BYTE4, macaddr1),
++		       (u8)FIELD_GET(M10BMC_MAC_BYTE5, macaddr2),
++		       (u8)FIELD_GET(M10BMC_MAC_BYTE6, macaddr2));
++}
++static DEVICE_ATTR_RO(mac_address);
++
++static ssize_t mac_count_show(struct device *dev,
++			      struct device_attribute *attr, char *buf)
++{
++	struct intel_m10bmc *max10 = dev_get_drvdata(dev);
++	unsigned int macaddr2;
++	int ret;
++
++	ret = m10bmc_sys_read(max10, M10BMC_MACADDR2, &macaddr2);
++	if (ret)
++		return ret;
++
++	return sprintf(buf, "%u\n",
++		       (u8)FIELD_GET(M10BMC_MAC_COUNT, macaddr2));
++}
++static DEVICE_ATTR_RO(mac_count);
++
+ static struct attribute *m10bmc_attrs[] = {
+ 	&dev_attr_bmc_version.attr,
+ 	&dev_attr_bmcfw_version.attr,
++	&dev_attr_mac_address.attr,
++	&dev_attr_mac_count.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(m10bmc);
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 827117416598..36f1455dd1e1 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -19,6 +19,15 @@
+ 
+ /* Register offset of system registers */
+ #define NIOS2_FW_VERSION		0x0
++#define M10BMC_MACADDR1			0x10
++#define M10BMC_MAC_BYTE4		GENMASK(7, 0)
++#define M10BMC_MAC_BYTE3		GENMASK(15, 8)
++#define M10BMC_MAC_BYTE2		GENMASK(23, 16)
++#define M10BMC_MAC_BYTE1		GENMASK(31, 24)
++#define M10BMC_MACADDR2			0x14
++#define M10BMC_MAC_BYTE6		GENMASK(7, 0)
++#define M10BMC_MAC_BYTE5		GENMASK(15, 8)
++#define M10BMC_MAC_COUNT		GENMASK(23, 16)
+ #define M10BMC_TEST_REG			0x3c
+ #define M10BMC_BUILD_VER		0x68
+ #define M10BMC_VER_MAJOR_MSK		GENMASK(23, 16)
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0040-REVERTME-fpga-dfl-init-needs_suppliers-after-disabli.patch new/debian/patches/fpga-ofs/0040-REVERTME-fpga-dfl-init-needs_suppliers-after-disabli.patch
--- org/debian/patches/fpga-ofs/0040-REVERTME-fpga-dfl-init-needs_suppliers-after-disabli.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0040-REVERTME-fpga-dfl-init-needs_suppliers-after-disabli.patch	2021-07-20 06:17:11.388844913 +0200
@@ -0,0 +1,55 @@
+From 2e674d9274ac3f0723b1c0d0aa9f59cc9f7abc81 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 9 Jun 2020 11:37:18 -0700
+Subject: [PATCH 040/149] REVERTME: fpga: dfl: init needs_suppliers after
+ disabling sriov
+
+device_links_purge() is called by device_del(). It removes
+the device from several lists including consumer, suppliers,
+and needs_suppliers. In the case of needs_suppliers, it uses
+list_del(), which places poison values in the next and
+previous pointers.
+
+When using SRIOV, the fpga dfl driver uses
+platform_device_del() to detach a device, and
+platform_device_add() to reattach the device.  In this
+context device_add() fails because of the poisoned
+needs_suppliers pointers.  The other lists (consumers and
+suppliers) are in the initialized state and are fine.
+
+Comments in the mainline code for device_add() state: "Do not call
+this routine or device_register() more than once for any device
+structure." The current DFL driver violates this and needs to
+be reworked to create a new device structure when reattaching
+after SRIOV.
+
+This is a temporary, short term fix which reinitializes the
+needs_suppliers list prior to calling device_add() when
+reattaching the device.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index cf93cf4b0c75..e2935c46deee 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -1697,6 +1697,13 @@ int dfl_fpga_cdev_assign_port(struct dfl_fpga_cdev *cdev, int port_id)
+ 		goto put_dev_exit;
+ 	}
+ 
++	/*
++	 * HACK: See the commit message associated with the
++	 * INIT_LIST_HEAD() line below. The long term fix
++	 * is to create a new device structure instead of
++	 * reviving the existing device structure.
++	 */
++	INIT_LIST_HEAD(&(&port_pdev->dev)->links.needs_suppliers);
+ 	ret = platform_device_add(port_pdev);
+ 	if (ret)
+ 		goto put_dev_exit;
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0041-fpga-dfl-pci-add-DID-for-D5005-PAC-cards.patch new/debian/patches/fpga-ofs/0041-fpga-dfl-pci-add-DID-for-D5005-PAC-cards.patch
--- org/debian/patches/fpga-ofs/0041-fpga-dfl-pci-add-DID-for-D5005-PAC-cards.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0041-fpga-dfl-pci-add-DID-for-D5005-PAC-cards.patch	2021-07-20 06:17:11.388844913 +0200
@@ -0,0 +1,53 @@
+From 9f928282e6ee877e0abfb2ad356a66b6f3204192 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Mon, 9 Mar 2020 17:43:01 -0700
+Subject: [PATCH 041/149] fpga: dfl: pci: add DID for D5005 PAC cards
+
+This patch adds the approved PCI Express Device IDs for the
+PF and VF for the card for D5005 PAC cards.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl-pci.c | 18 +++++++++++-------
+ 1 file changed, 11 insertions(+), 7 deletions(-)
+
+diff --git a/drivers/fpga/dfl-pci.c b/drivers/fpga/dfl-pci.c
+index a2203d03c9e2..bc108ee8e9eb 100644
+--- a/drivers/fpga/dfl-pci.c
++++ b/drivers/fpga/dfl-pci.c
+@@ -61,14 +61,16 @@ static void cci_pci_free_irq(struct pci_dev *pcidev)
+ }
+ 
+ /* PCI Device ID */
+-#define PCIE_DEVICE_ID_PF_INT_5_X	0xBCBD
+-#define PCIE_DEVICE_ID_PF_INT_6_X	0xBCC0
+-#define PCIE_DEVICE_ID_PF_DSC_1_X	0x09C4
+-#define PCIE_DEVICE_ID_INTEL_PAC_N3000	0x0B30
++#define PCIE_DEVICE_ID_PF_INT_5_X		0xBCBD
++#define PCIE_DEVICE_ID_PF_INT_6_X		0xBCC0
++#define PCIE_DEVICE_ID_PF_DSC_1_X		0x09C4
++#define PCIE_DEVICE_ID_INTEL_PAC_N3000		0x0B30
++#define PCIE_DEVICE_ID_INTEL_PAC_D5005		0x0B2B
+ /* VF Device */
+-#define PCIE_DEVICE_ID_VF_INT_5_X	0xBCBF
+-#define PCIE_DEVICE_ID_VF_INT_6_X	0xBCC1
+-#define PCIE_DEVICE_ID_VF_DSC_1_X	0x09C5
++#define PCIE_DEVICE_ID_VF_INT_5_X		0xBCBF
++#define PCIE_DEVICE_ID_VF_INT_6_X		0xBCC1
++#define PCIE_DEVICE_ID_VF_DSC_1_X		0x09C5
++#define PCIE_DEVICE_ID_INTEL_PAC_D5005_VF	0x0B2C
+ 
+ static struct pci_device_id cci_pcie_id_tbl[] = {
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_PF_INT_5_X),},
+@@ -78,6 +80,8 @@ static struct pci_device_id cci_pcie_id_tbl[] = {
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_PF_DSC_1_X),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_VF_DSC_1_X),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_N3000),},
++	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_D5005),},
++	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_D5005_VF),},
+ 	{0,}
+ };
+ MODULE_DEVICE_TABLE(pci, cci_pcie_id_tbl);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0042-fpga-dfl-Add-DFL-bus-driver-for-Altera-SPI-Master.patch new/debian/patches/fpga-ofs/0042-fpga-dfl-Add-DFL-bus-driver-for-Altera-SPI-Master.patch
--- org/debian/patches/fpga-ofs/0042-fpga-dfl-Add-DFL-bus-driver-for-Altera-SPI-Master.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0042-fpga-dfl-Add-DFL-bus-driver-for-Altera-SPI-Master.patch	2021-07-20 06:17:11.388844913 +0200
@@ -0,0 +1,281 @@
+From 504088d3a6fea6608897f499ded5539a7c44358f Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Wed, 15 Apr 2020 16:58:30 -0700
+Subject: [PATCH 042/149] fpga: dfl: Add DFL bus driver for Altera SPI Master
+
+This patch adds DFL bus driver for the Altera SPI Master
+controller.  The SPI master is connected to an Intel SPI Slave to
+Avalon Master Bridge, inside an Intel MAX10 BMC Chip.
+
+Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+v2: cleaned up naming and typos
+---
+ drivers/fpga/Kconfig          |   9 ++
+ drivers/fpga/Makefile         |   1 +
+ drivers/fpga/dfl-spi-altera.c | 221 ++++++++++++++++++++++++++++++++++
+ 3 files changed, 231 insertions(+)
+ create mode 100644 drivers/fpga/dfl-spi-altera.c
+
+diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
+index 92b572fd1729..a6a1f5e0d587 100644
+--- a/drivers/fpga/Kconfig
++++ b/drivers/fpga/Kconfig
+@@ -213,6 +213,15 @@ config FPGA_DFL_UIO_PDEV
+ 	  support to userspace access to kernel interrupts and memory
+ 	  locations.
+ 
++config FPGA_DFL_SPI_ALTERA
++	tristate "FPGA DFL Altera SPI Master Driver"
++	depends on FPGA_DFL
++	select REGMAP
++	help
++	  This is a DFL bus driver for the Altera SPI master controller.
++          The SPI master is connected to a SPI slave to Avalon Master
++	  bridge in a Intel MAX BMC.
++
+ config FPGA_DFL_PCI
+ 	tristate "FPGA DFL PCIe Device Driver"
+ 	depends on PCI && FPGA_DFL
+diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
+index b1112d80c4f4..d30929ff9927 100644
+--- a/drivers/fpga/Makefile
++++ b/drivers/fpga/Makefile
+@@ -52,6 +52,7 @@ dfl-afu-objs += dfl-afu-error.o
+ 
+ obj-$(CONFIG_FPGA_DFL_NIOS_INTEL_PAC_N3000)	+= dfl-n3000-nios.o
+ obj-$(CONFIG_FPGA_DFL_UIO_PDEV)	+= dfl-uio-pdev.o
++obj-$(CONFIG_FPGA_DFL_SPI_ALTERA)	+= dfl-spi-altera.o
+ 
+ # Drivers for FPGAs which implement DFL
+ obj-$(CONFIG_FPGA_DFL_PCI)		+= dfl-pci.o
+diff --git a/drivers/fpga/dfl-spi-altera.c b/drivers/fpga/dfl-spi-altera.c
+new file mode 100644
+index 000000000000..b21c344d596f
+--- /dev/null
++++ b/drivers/fpga/dfl-spi-altera.c
+@@ -0,0 +1,221 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * DFL bus driver for Altera SPI Master
++ *
++ * Copyright (C) 2020 Intel Corporation, Inc.
++ *
++ * Authors:
++ *   Matthew Gerlach <matthew.gerlach@linux.intel.com>
++ */
++
++#include <linux/types.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/stddef.h>
++#include <linux/errno.h>
++#include <linux/platform_device.h>
++#include <linux/io.h>
++#include <linux/bitfield.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/regmap.h>
++#include <linux/spi/spi.h>
++#include <linux/spi/altera.h>
++#include <linux/dfl.h>
++
++struct dfl_altera_spi {
++	void __iomem *base;
++	struct regmap *regmap;
++	struct device *dev;
++	struct platform_device *altr_spi;
++};
++
++#define SPI_CORE_PARAMETER      0x8
++#define SHIFT_MODE              BIT_ULL(1)
++#define SHIFT_MODE_MSB          0
++#define SHIFT_MODE_LSB          1
++#define DATA_WIDTH              GENMASK_ULL(7, 2)
++#define NUM_CHIPSELECT          GENMASK_ULL(13, 8)
++#define CLK_POLARITY            BIT_ULL(14)
++#define CLK_PHASE               BIT_ULL(15)
++#define PERIPHERAL_ID           GENMASK_ULL(47, 32)
++#define SPI_CLK                 GENMASK_ULL(31, 22)
++#define SPI_INDIRECT_ACC_OFST   0x10
++
++#define INDIRECT_ADDR           (SPI_INDIRECT_ACC_OFST+0x0)
++#define INDIRECT_WR             BIT_ULL(8)
++#define INDIRECT_RD             BIT_ULL(9)
++#define INDIRECT_RD_DATA        (SPI_INDIRECT_ACC_OFST+0x8)
++#define INDIRECT_DATA_MASK      GENMASK_ULL(31, 0)
++#define INDIRECT_DEBUG          BIT_ULL(32)
++#define INDIRECT_WR_DATA        (SPI_INDIRECT_ACC_OFST+0x10)
++#define INDIRECT_TIMEOUT        10000
++
++static int indirect_bus_reg_read(void *context, unsigned int reg,
++				 unsigned int *val)
++{
++	struct dfl_altera_spi *aspi = context;
++	void __iomem *base = aspi->base;
++	int loops;
++	u64 v;
++
++	writeq((reg >> 2) | INDIRECT_RD, base + INDIRECT_ADDR);
++
++	loops = 0;
++	while ((readq(base + INDIRECT_ADDR) & INDIRECT_RD) &&
++	       (loops++ < INDIRECT_TIMEOUT))
++		cpu_relax();
++
++	if (loops >= INDIRECT_TIMEOUT) {
++		pr_err("%s timed out %d\n", __func__, loops);
++		return -ETIME;
++	}
++
++	v = readq(base + INDIRECT_RD_DATA);
++
++	*val = v & INDIRECT_DATA_MASK;
++
++	return 0;
++}
++
++static int indirect_bus_reg_write(void *context, unsigned int reg,
++				  unsigned int val)
++{
++	struct dfl_altera_spi *aspi = context;
++	void __iomem *base = aspi->base;
++	int loops;
++
++	writeq(val, base + INDIRECT_WR_DATA);
++	writeq((reg >> 2) | INDIRECT_WR, base + INDIRECT_ADDR);
++
++	loops = 0;
++	while ((readq(base + INDIRECT_ADDR) & INDIRECT_WR) &&
++	       (loops++ < INDIRECT_TIMEOUT))
++		cpu_relax();
++
++	if (loops >= INDIRECT_TIMEOUT) {
++		pr_err("%s timed out %d\n", __func__, loops);
++		return -ETIME;
++	}
++	return 0;
++}
++
++static const struct regmap_config indirect_regbus_cfg = {
++	.reg_bits = 32,
++	.reg_stride = 4,
++	.val_bits = 32,
++	.fast_io = true,
++
++	.reg_write = indirect_bus_reg_write,
++	.reg_read = indirect_bus_reg_read,
++};
++
++static struct spi_board_info m10_bmc_info = {
++	.modalias = "m10-d5005",
++	.max_speed_hz = 12500000,
++	.bus_num = 0,
++	.chip_select = 0,
++};
++
++static struct platform_device *create_cntrl(struct device *dev,
++					    void __iomem *base,
++					    struct spi_board_info *m10_info)
++{
++	struct altera_spi_platform_data pdata;
++	struct platform_device_info pdevinfo;
++	u64 v;
++
++	v = readq(base + SPI_CORE_PARAMETER);
++
++	memset(&pdata, 0, sizeof(pdata));
++	pdata.mode_bits = SPI_CS_HIGH;
++	if (FIELD_GET(CLK_POLARITY, v))
++		pdata.mode_bits |= SPI_CPOL;
++	if (FIELD_GET(CLK_PHASE, v))
++		pdata.mode_bits |= SPI_CPHA;
++
++	pdata.num_chipselect = FIELD_GET(NUM_CHIPSELECT, v);
++	pdata.bits_per_word_mask =
++		SPI_BPW_RANGE_MASK(1, FIELD_GET(DATA_WIDTH, v));
++
++	pdata.num_devices = 1;
++	pdata.devices = m10_info;
++
++	dev_dbg(dev, "%s cs %hu bpm 0x%x mode 0x%hx\n", __func__,
++		pdata.num_chipselect, pdata.bits_per_word_mask,
++		pdata.mode_bits);
++
++	memset(&pdevinfo, 0, sizeof(pdevinfo));
++
++	pdevinfo.name = "subdev_spi_altera";
++	pdevinfo.id = PLATFORM_DEVID_AUTO;
++	pdevinfo.parent = dev;
++	pdevinfo.data = &pdata;
++	pdevinfo.size_data = sizeof(pdata);
++
++	return platform_device_register_full(&pdevinfo);
++}
++static int dfl_spi_altera_probe(struct dfl_device *dfl_dev)
++{
++	struct device *dev = &dfl_dev->dev;
++	struct dfl_altera_spi *aspi;
++
++	aspi = devm_kzalloc(dev, sizeof(*aspi), GFP_KERNEL);
++
++	if (!aspi)
++		return -ENOMEM;
++
++	dev_set_drvdata(dev, aspi);
++
++	aspi->dev = dev;
++
++	aspi->base = devm_ioremap_resource(dev, &dfl_dev->mmio_res);
++
++	if (IS_ERR(aspi->base)) {
++		dev_err(dev, "%s get mem resource fail!\n", __func__);
++		return PTR_ERR(aspi->base);
++	}
++
++	aspi->regmap = devm_regmap_init(dev, NULL, aspi, &indirect_regbus_cfg);
++	if (IS_ERR(aspi->regmap))
++		return PTR_ERR(aspi->regmap);
++
++	aspi->altr_spi = create_cntrl(dev, aspi->base, &m10_bmc_info);
++
++	if (IS_ERR(aspi->altr_spi)) {
++		dev_err(dev, "%s failed to create spi platform driver\n",
++			__func__);
++		return PTR_ERR(aspi->base);
++	}
++
++	return 0;
++}
++
++static void dfl_spi_altera_remove(struct dfl_device *dfl_dev)
++{
++	struct dfl_altera_spi *aspi = dev_get_drvdata(&dfl_dev->dev);
++
++	platform_device_unregister(aspi->altr_spi);
++}
++
++#define FME_FEATURE_ID_MAX10_SPI        0xe
++
++static const struct dfl_device_id dfl_spi_altera_ids[] = {
++	{ FME_ID, FME_FEATURE_ID_MAX10_SPI },
++	{ }
++};
++
++static struct dfl_driver dfl_spi_altera_driver = {
++	.drv	= {
++		.name       = "dfl-spi-altera",
++	},
++	.id_table = dfl_spi_altera_ids,
++	.probe   = dfl_spi_altera_probe,
++	.remove  = dfl_spi_altera_remove,
++};
++
++module_dfl_driver(dfl_spi_altera_driver);
++
++MODULE_DEVICE_TABLE(dfl, dfl_spi_altera_ids);
++MODULE_DESCRIPTION("DFL spi altera driver");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0043-hwmon-intel-m10-bmc-hwmon-add-sensor-support-of-Inte.patch new/debian/patches/fpga-ofs/0043-hwmon-intel-m10-bmc-hwmon-add-sensor-support-of-Inte.patch
--- org/debian/patches/fpga-ofs/0043-hwmon-intel-m10-bmc-hwmon-add-sensor-support-of-Inte.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0043-hwmon-intel-m10-bmc-hwmon-add-sensor-support-of-Inte.patch	2021-07-20 06:17:11.392844901 +0200
@@ -0,0 +1,204 @@
+From b8738ee1440996b3c23f0f5602f3fa07d6658163 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Sat, 4 Apr 2020 14:32:10 -0700
+Subject: [PATCH 043/149] hwmon: intel-m10-bmc-hwmon: add sensor support of
+ Intel D5005 card
+
+Like the Intel N3000 card, the Intel D5005 has a MAX10 based
+BMC.  This commit adds support for the D5005 sensors that are
+monitored by the MAX10 BMC.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Signed-off-by: Russ Weight <russell.h.weight@linux.intel.com>
+---
+v2: clean up constants to be more consistent with n3000
+---
+ drivers/hwmon/intel-m10-bmc-hwmon.c | 122 ++++++++++++++++++++++++++++
+ drivers/mfd/intel-m10-bmc.c         |  10 +++
+ 2 files changed, 132 insertions(+)
+
+diff --git a/drivers/hwmon/intel-m10-bmc-hwmon.c b/drivers/hwmon/intel-m10-bmc-hwmon.c
+index 17d5e6b91c8a..bd7ed2ed3a1e 100644
+--- a/drivers/hwmon/intel-m10-bmc-hwmon.c
++++ b/drivers/hwmon/intel-m10-bmc-hwmon.c
+@@ -99,6 +99,50 @@ static const struct hwmon_channel_info *n3000bmc_hinfo[] = {
+ 	NULL
+ };
+ 
++static const struct m10bmc_sdata d5005bmc_temp_tbl[] = {
++	{ 0x100, 0x104, 0x108, 0x10c, 0x0, 500, "Board Inlet Air Temperature" },
++	{ 0x110, 0x114, 0x118, 0x0, 0x0, 500, "FPGA Core Temperature" },
++	{ 0x11c, 0x120, 0x124, 0x128, 0x0, 500, "Board Exhaust Air Temperature" },
++	{ 0x12c, 0x130, 0x134, 0x0, 0x0, 500, "FPGA Transceiver Temperature" },
++	{ 0x138, 0x13c, 0x140, 0x144, 0x0, 500, "RDIMM0 Temperature" },
++	{ 0x148, 0x14c, 0x150, 0x154, 0x0, 500, "RDIMM1 Temperature" },
++	{ 0x158, 0x15c, 0x160, 0x164, 0x0, 500, "RDIMM2 Temperature" },
++	{ 0x168, 0x16c, 0x170, 0x174, 0x0, 500, "RDIMM3 Temperature" },
++	{ 0x178, 0x17c, 0x180, 0x0, 0x0, 500, "QSFP0 Temperature" },
++	{ 0x188, 0x18c, 0x190, 0x0, 0x0, 500, "QSFP1 Temperature" },
++	{ 0x1a0, 0x1a4, 0x1a8, 0x0, 0x0, 500, "3.3v Temperature" },
++	{ 0x1bc, 0x1c0, 0x1c4, 0x0, 0x0, 500, "VCCERAM Temperature" },
++	{ 0x1d8, 0x1dc, 0x1e0, 0x0, 0x0, 500, "VCCR Temperature" },
++	{ 0x1f4, 0x1f8, 0x1fc, 0x0, 0x0, 500, "VCCT Temperature" },
++	{ 0x210, 0x214, 0x218, 0x0, 0x0, 500, "1.8v Temperature" },
++	{ 0x22c, 0x230, 0x234, 0x0, 0x0, 500, "12v Backplane Temperature" },
++	{ 0x248, 0x24c, 0x250, 0x0, 0x0, 500, "12v AUX Temperature" },
++};
++
++static const struct m10bmc_sdata d5005bmc_in_tbl[] = {
++	{ 0x184, 0x0, 0x0, 0x0, 0x0, 1, "QSFP0 Supply Voltage" },
++	{ 0x194, 0x0, 0x0, 0x0, 0x0, 1, "QSFP1 Supply Voltage" },
++	{ 0x198, 0x0, 0x0, 0x0, 0x0, 1, "FPGA Core Voltage" },
++	{ 0x1ac, 0x1b0, 0x1b4, 0x0, 0x0, 1, "3.3v Voltage" },
++	{ 0x1c8, 0x1cc, 0x1d0, 0x0, 0x0, 1, "VCCERAM Voltage" },
++	{ 0x1e4, 0x1e8, 0x1ec, 0x0, 0x0, 1, "VCCR Voltage" },
++	{ 0x200, 0x204, 0x208, 0x0, 0x0, 1, "VCCT Voltage" },
++	{ 0x21c, 0x220, 0x224, 0x0, 0x0, 1, "1.8v Voltage" },
++	{ 0x238, 0x0, 0x0, 0x0, 0x23c, 1, "12v Backplane Voltage" },
++	{ 0x254, 0x0, 0x0, 0x0, 0x258, 1, "12v AUX Voltage" },
++};
++
++static const struct m10bmc_sdata d5005bmc_curr_tbl[] = {
++	{ 0x19c, 0x0, 0x0, 0x0, 0x0, 1, "FPGA Core Current" },
++	{ 0x1b8, 0x0, 0x0, 0x0, 0x0, 1, "3.3v Current" },
++	{ 0x1d4, 0x0, 0x0, 0x0, 0x0, 1, "VCCERAM Current" },
++	{ 0x1f0, 0x0, 0x0, 0x0, 0x0, 1, "VCCR Current" },
++	{ 0x20c, 0x0, 0x0, 0x0, 0x0, 1, "VCCT Current" },
++	{ 0x228, 0x0, 0x0, 0x0, 0x0, 1, "1.8v Current" },
++	{ 0x240, 0x244, 0x0, 0x0, 0x0, 1, "12v Backplane Current" },
++	{ 0x25c, 0x260, 0x0, 0x0, 0x0, 1, "12v AUX Current" },
++};
++
+ static const struct m10bmc_hwmon_board_data n3000bmc_hwmon_bdata = {
+ 	.tables = {
+ 		[hwmon_temp] = n3000bmc_temp_tbl,
+@@ -110,6 +154,80 @@ static const struct m10bmc_hwmon_board_data n3000bmc_hwmon_bdata = {
+ 	.hinfo = n3000bmc_hinfo,
+ };
+ 
++static const struct hwmon_channel_info *d5005bmc_hinfo[] = {
++	HWMON_CHANNEL_INFO(temp,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST |
++			   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST |
++			   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST |
++			   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST |
++			   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST |
++			   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_MAX_HYST |
++			   HWMON_T_CRIT | HWMON_T_CRIT_HYST | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT |
++			   HWMON_T_LABEL),
++	HWMON_CHANNEL_INFO(in,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_CRIT |
++			   HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_CRIT |
++			   HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_CRIT |
++			   HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_CRIT |
++			   HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_MAX | HWMON_I_CRIT |
++			   HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_LABEL),
++	HWMON_CHANNEL_INFO(curr,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_MAX | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_MAX | HWMON_C_LABEL),
++	NULL
++};
++
++static const struct m10bmc_hwmon_board_data d5005bmc_hwmon_bdata = {
++	.tables = {
++		[hwmon_temp] = d5005bmc_temp_tbl,
++		[hwmon_in] = d5005bmc_in_tbl,
++		[hwmon_curr] = d5005bmc_curr_tbl,
++	},
++
++	.hinfo = d5005bmc_hinfo,
++};
++
+ static umode_t
+ m10bmc_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,
+ 			u32 attr, int channel)
+@@ -316,6 +434,10 @@ static const struct platform_device_id intel_m10bmc_hwmon_ids[] = {
+ 		.name = "n3000bmc-hwmon",
+ 		.driver_data = (unsigned long)&n3000bmc_hwmon_bdata,
+ 	},
++	{
++		.name = "d5005bmc-hwmon",
++		.driver_data = (unsigned long)&d5005bmc_hwmon_bdata,
++	},
+ 	{ }
+ };
+ 
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index ccc3c2861cb2..cbfe2b96d63d 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -15,6 +15,11 @@
+ 
+ enum m10bmc_type {
+ 	M10_N3000,
++	M10_D5005
++};
++
++static struct mfd_cell m10bmc_bmc_subdevs[] = {
++	{ .name = "d5005bmc-hwmon" },
+ };
+ 
+ static struct mfd_cell m10bmc_pacn3000_subdevs[] = {
+@@ -275,6 +280,10 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ 		cells = m10bmc_pacn3000_subdevs;
+ 		n_cell = ARRAY_SIZE(m10bmc_pacn3000_subdevs);
+ 		break;
++	case M10_D5005:
++		cells = m10bmc_bmc_subdevs;
++		n_cell = ARRAY_SIZE(m10bmc_bmc_subdevs);
++		break;
+ 	default:
+ 		return -ENODEV;
+ 	}
+@@ -291,6 +300,7 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ 
+ static const struct spi_device_id m10bmc_spi_id[] = {
+ 	{ "m10-n3000", M10_N3000 },
++	{ "m10-d5005", M10_D5005 },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(spi, m10bmc_spi_id);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0044-net-phy-intel-driver-for-stratix10-phy.patch new/debian/patches/fpga-ofs/0044-net-phy-intel-driver-for-stratix10-phy.patch
--- org/debian/patches/fpga-ofs/0044-net-phy-intel-driver-for-stratix10-phy.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0044-net-phy-intel-driver-for-stratix10-phy.patch	2021-07-20 06:17:11.400844879 +0200
@@ -0,0 +1,669 @@
+From 6d220b869f86d9477588206e44d7483fff2d1d80 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 23 Apr 2020 12:34:26 -0700
+Subject: [PATCH 044/149] net: phy: intel: driver for stratix10 phy
+
+Create a driver for the QSFP interfaces that are part of
+the Intel Stratix 10 FPGA. This driver exposes four
+parameters per channel via sysfs, allowing these
+parameters to be viewed and changed:
+
+tx-pre-tap:  Pre-emphasis 1st post-tap magnitude (0 - 24) & polarity (+/-)
+tx-post-tap: Pre-emphasis 1st pre-tap magnitude (0 - 15) & polarity (+/-)
+tx-vod:      Sets TX output swing level (17 - 31)
+tx-comp:     Sets TX Compensation (0 = OFF, 1 = ON)
+
+These parameters are exposed in per-channel sysfs groups:
+
+    chan0/tx-pre-tap
+    chan0/tx-post-tap
+    chan0/tx-vod
+    chan0/tx-comp
+    chan1/tx-pre-tap
+    ...
+    chan3/tx-pre-tap
+    chan3/tx-post-tap
+    chan3/tx-vod
+    chan3/tx-comp
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ MAINTAINERS                       |   7 +
+ drivers/net/phy/Kconfig           |   9 +
+ drivers/net/phy/Makefile          |   1 +
+ drivers/net/phy/intel-s10-phy.c   | 550 ++++++++++++++++++++++++++++++
+ include/linux/phy/intel-s10-phy.h |  21 ++
+ 5 files changed, 588 insertions(+)
+ create mode 100644 drivers/net/phy/intel-s10-phy.c
+ create mode 100644 include/linux/phy/intel-s10-phy.h
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 545b79be393d..937b6aa2c717 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -9073,6 +9073,13 @@ F:	drivers/firmware/stratix10-svc.c
+ F:	include/linux/firmware/intel/stratix10-smc.h
+ F:	include/linux/firmware/intel/stratix10-svc-client.h
+ 
++INTEL STRATIX10 PHY DRIVER
++M:	Russ Weight <russell.h.weight@intel.com>
++L:	linux-fpga@vger.kernel.org
++S:	Maintained
++F:	drivers/net/phy/intel-s10-phy.c
++F:	include/linux/phy/intel-s10-phy.h
++
+ INTEL TELEMETRY DRIVER
+ M:	Rajneesh Bhardwaj <rajneesh.bhardwaj@linux.intel.com>
+ M:	"David E. Box" <david.e.box@linux.intel.com>
+diff --git a/drivers/net/phy/Kconfig b/drivers/net/phy/Kconfig
+index 698bea312adc..30be46d7b9c5 100644
+--- a/drivers/net/phy/Kconfig
++++ b/drivers/net/phy/Kconfig
+@@ -319,3 +319,12 @@ endif # PHYLIB
+ config MICREL_KS8995MA
+ 	tristate "Micrel KS8995MA 5-ports 10/100 managed Ethernet switch"
+ 	depends on SPI
++
++config INTEL_S10_PHY
++	tristate "Intel HSSI configurable ethernet phy driver"
++	depends on FPGA_DFL
++	select FPGA_DFl_HSSI
++	help
++	  This is the Intel HSSI configurable ethernet phy driver. It
++	  provides the ability to view and change some of the transceiver
++	  tuner parameters for a QSFP interface.
+diff --git a/drivers/net/phy/Makefile b/drivers/net/phy/Makefile
+index a13e402074cf..b9262498838d 100644
+--- a/drivers/net/phy/Makefile
++++ b/drivers/net/phy/Makefile
+@@ -80,3 +80,4 @@ obj-$(CONFIG_STE10XP)		+= ste10Xp.o
+ obj-$(CONFIG_TERANETICS_PHY)	+= teranetics.o
+ obj-$(CONFIG_VITESSE_PHY)	+= vitesse.o
+ obj-$(CONFIG_XILINX_GMII2RGMII) += xilinx_gmii2rgmii.o
++obj-$(CONFIG_INTEL_S10_PHY)	+= intel-s10-phy.o
+diff --git a/drivers/net/phy/intel-s10-phy.c b/drivers/net/phy/intel-s10-phy.c
+new file mode 100644
+index 000000000000..5c3f714507ab
+--- /dev/null
++++ b/drivers/net/phy/intel-s10-phy.c
+@@ -0,0 +1,550 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Driver for Stratix 10 HSSI Phy
++ *
++ * Copyright 2019-2020 Intel Corporation, Inc.
++ */
++
++#include <linux/bitfield.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/iopoll.h>
++#include <linux/module.h>
++#include <linux/phy/intel-s10-phy.h>
++#include <linux/platform_device.h>
++
++/* HSSI QSFP Control & Status Registers */
++#define HSSI_QSFP_RCFG_CMD(phy)		((phy)->phy_offset + 0x0)
++#define   QSFP_RCFG_CMD			GENMASK_ULL(1, 0)
++#define     QSFP_RCFG_CMD_CLR		0
++#define     QSFP_RCFG_CMD_RD		1
++#define     QSFP_RCFG_CMD_WRT		2
++#define   QSFP_RCFG_CMD_SEL_XCVR	GENMASK_ULL(5, 4)   /* XCVR 0 - 3 */
++#define   QSFP_RCFG_XCVR_ADDR		GENMASK_ULL(26, 16)
++#define   QSFP_RCFG_XCVR_ACK		BIT_ULL(32)
++
++#define HSSI_QSFP_RCFG_DATA(phy)	((phy)->phy_offset + 0x8)
++#define   XCVR_RCFG_RDATA		GENMASK_ULL(31, 0)  /* RO: rd data */
++#define   XCVR_RCFG_WDATA		GENMASK_ULL(63, 32) /* RW: wrt data */
++
++#define HSSI_QSFP_CTRL(phy)		((phy)->phy_offset + 0x10)
++#define   DATA_RATE_SEL_1G		BIT_ULL(0)	/* 1 = Selected */
++#define   DATA_RATE_SEL_10G		BIT_ULL(1)
++#define   DATA_RATE_SEL_25G		BIT_ULL(2)
++#define   DATA_RATE_SEL_40G		BIT_ULL(3)
++#define   DATA_RATE_SEL_50G		BIT_ULL(4)
++#define   DATA_RATE_SEL_100G		BIT_ULL(5)
++#define   DATA_RATE_SEL_200G		BIT_ULL(6)
++#define   DATA_RATE_SEL_400G		BIT_ULL(7)
++#define   GLOBAL_RESET			BIT_ULL(8)	/* 1 = Active */
++#define   RECONFIG_RESET		BIT_ULL(9)
++#define   CHAN0_RESET			BIT_ULL(10)
++#define   CHAN1_RESET			BIT_ULL(11)
++#define   CHAN2_RESET			BIT_ULL(12)
++#define   CHAN3_RESET			BIT_ULL(13)
++#define   SELECT_ATX_PLL		BIT_ULL(14)	/* 0 = 10G, 1 = 25G */
++#define   SELECT_TX_CORE_CLK		BIT_ULL(15)	/* 0 = PHY, 1 = IOPLL */
++#define   SELECT_RX_CORE_CLK		BIT_ULL(16)	/* 0 = PHY, 1 = IOPLL */
++
++#define HSSI_QSFP_STAT(phy)		((phy)->phy_offset + 0x18)
++#define   HSSI_QSFP_STAT_CHAN0		GENMASK_ULL(15, 0)
++#define   HSSI_QSFP_STAT_CHAN1		GENMASK_ULL(31, 16)
++#define   HSSI_QSFP_STAT_CHAN2		GENMASK_ULL(47, 32)
++#define   HSSI_QSFP_STAT_CHAN3		GENMASK_ULL(63, 48)
++#define     TX_ANALOG_RST_STAT		BIT_ULL(0)
++#define     TX_DIG_RST_STAT		BIT_ULL(1)
++#define     RX_ANALOG_RST_STAT		BIT_ULL(2)
++#define     RX_DIG_RST_STAT		BIT_ULL(3)
++#define     TX_DIG_RST_TIMEOUT		BIT_ULL(4)
++#define     RX_DIG_RST_TIMEOUT		BIT_ULL(5)
++#define     TX_FIFO_READY		BIT_ULL(6)
++#define     RX_FIFO_READY		BIT_ULL(7)
++#define     TX_XFER_READY		BIT_ULL(8)
++#define     RX_XFER_READY		BIT_ULL(9)
++#define     TX_CAL_BUSY			BIT_ULL(10)
++#define     RX_CAL_BUSY			BIT_ULL(11)
++#define     RX_LOCKED_TO_DATA		BIT_ULL(12)
++#define     RX_LOCKED_TO_REF		BIT_ULL(13)
++#define     TX_READY			BIT_ULL(14)
++#define     RX_READY			BIT_ULL(15)
++
++#define HSSI_WRITE_POLL_INVL_US		10	/* Write poll interval */
++#define HSSI_WRITE_POLL_TIMEOUT_US	100000	/* Write poll timeout */
++
++/* Analog preemphasis tuning parameters */
++#define PRE_TAP_ADDR			0x107
++#define PRE_TAP_MAGNITUDE_MASK		GENMASK(4, 0)
++#define PRE_TAP_MAX			15
++#define PRE_TAP_POLARITY		BIT(5)	/* 1 = negative polarity */
++
++#define POST_TAP_ADDR			0x105
++#define POST_TAP_MAGNITUDE_MASK		GENMASK(4, 0)
++#define POST_TAP_MAX			24
++#define POST_TAP_POLARITY		BIT(6)	/* 1 = negative polarity */
++
++#define VOD_COMP_ADDR			0x109
++#define VOD_MASK			GENMASK(4, 0)
++#define VOD_MIN				17
++#define VOD_MAX				31
++
++#define COMPENSATION_FLAG		BIT(5)	/* 1 = ON; 0 = OFF */
++
++struct hssi_phy {
++	void __iomem *csr_base;
++	u32 phy_offset;
++	struct device *dev;
++	struct mutex lock;	/* serialize access to phy registers */
++};
++
++static int hssi_await_ack(struct hssi_phy *phy)
++{
++	int ret;
++	u64 v;
++
++	/* Poll for the expected state of acknowlege bit */
++	ret = readq_poll_timeout(phy->csr_base + HSSI_QSFP_RCFG_CMD(phy), v,
++				 v & QSFP_RCFG_XCVR_ACK,
++				 HSSI_WRITE_POLL_INVL_US,
++				 HSSI_WRITE_POLL_TIMEOUT_US);
++	if (ret) {
++		dev_err(phy->dev, "timeout, phy ack not received\n");
++		return ret;
++	}
++
++	/* Clear ACK state */
++	v = readq(phy->csr_base + HSSI_QSFP_RCFG_CMD(phy));
++	v &= ~QSFP_RCFG_CMD;
++	v |= FIELD_PREP(QSFP_RCFG_CMD, QSFP_RCFG_CMD_CLR);
++	writeq(v, phy->csr_base + HSSI_QSFP_RCFG_CMD(phy));
++
++	return 0;
++}
++
++static int hssi_xcvr_read(struct hssi_phy *phy, u8 chan_num,
++			  u16 addr, u32 *data)
++{
++	int ret;
++	u64 v;
++
++	/* Read the desired address */
++	v = FIELD_PREP(QSFP_RCFG_CMD, QSFP_RCFG_CMD_RD);
++	v |= FIELD_PREP(QSFP_RCFG_CMD_SEL_XCVR, chan_num);
++	v |= FIELD_PREP(QSFP_RCFG_XCVR_ADDR, addr);
++	writeq(v, phy->csr_base + HSSI_QSFP_RCFG_CMD(phy));
++
++	/* Poll for read complete */
++	ret = hssi_await_ack(phy);
++	if (ret)
++		return ret;
++
++	/* Return data */
++	v = readq(phy->csr_base + HSSI_QSFP_RCFG_DATA(phy));
++	*data = FIELD_GET(XCVR_RCFG_RDATA, v);
++
++	return 0;
++}
++
++static int hssi_xcvr_write(struct hssi_phy *phy, u8 chan_num,
++			   u16 addr, u32 data)
++{
++	u64 v;
++
++	/* Set up the write data */
++	v = FIELD_PREP(XCVR_RCFG_WDATA, data);
++	writeq(v, phy->csr_base + HSSI_QSFP_RCFG_DATA(phy));
++
++	/* Trigger the write */
++	v = FIELD_PREP(QSFP_RCFG_CMD, QSFP_RCFG_CMD_WRT);
++	v |= FIELD_PREP(QSFP_RCFG_CMD_SEL_XCVR, chan_num);
++	v |= FIELD_PREP(QSFP_RCFG_XCVR_ADDR, addr);
++	writeq(v, phy->csr_base + HSSI_QSFP_RCFG_CMD(phy));
++
++	/* Poll for write complete */
++	return hssi_await_ack(phy);
++}
++
++static int hssi_xcvr_rmw(struct hssi_phy *phy, u8 chan_num,
++			 u16 addr, u32 mask, u32 data)
++{
++	u32 value;
++	int ret;
++
++	ret = hssi_xcvr_read(phy, chan_num, addr, &value);
++	if (ret)
++		return ret;
++
++	value &= ~mask;
++	value |= (data & mask);
++
++	return hssi_xcvr_write(phy, chan_num, addr, value);
++}
++
++static ssize_t tx_pre_tap_store(struct device *dev,
++				struct device_attribute *attr,
++				const char *buf, size_t count)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	struct dev_ext_attribute *eattr;
++	u8 magnitude, polarity = 0;
++	const char *p = buf;
++	unsigned long chan;
++	int ret;
++
++	if ((buf[0] == '+') || (buf[0] == '-')) {
++		if (buf[0] == '-')
++			polarity = PRE_TAP_POLARITY;
++		p++;
++	}
++
++	ret = kstrtou8(p, 0, &magnitude);
++	if (ret)
++		return ret;
++
++	if (magnitude > PRE_TAP_MAX) {
++		dev_err(phy->dev, "Max pre-tap is %d\n", PRE_TAP_MAX);
++		return -EINVAL;
++	}
++
++	eattr = container_of(attr, struct dev_ext_attribute, attr);
++	chan = (unsigned long)eattr->var;
++
++	mutex_lock(&phy->lock);
++	ret = hssi_xcvr_rmw(phy, (u8)chan, PRE_TAP_ADDR,
++			    PRE_TAP_POLARITY | PRE_TAP_MAGNITUDE_MASK,
++			    polarity | magnitude);
++	mutex_unlock(&phy->lock);
++
++	return ret ? : count;
++}
++
++static ssize_t tx_pre_tap_show(struct device *dev,
++			       struct device_attribute *attr, char *buf)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	struct dev_ext_attribute *eattr;
++	char polarity = '\0';
++	unsigned long chan;
++	u8 magnitude;
++	u32 pre_tap;
++	int ret;
++
++	eattr = container_of(attr, struct dev_ext_attribute, attr);
++	chan = (unsigned long)eattr->var;
++
++	mutex_lock(&phy->lock);
++	ret = hssi_xcvr_read(phy, (u8)chan, PRE_TAP_ADDR, &pre_tap);
++	mutex_unlock(&phy->lock);
++
++	if (ret)
++		return ret;
++
++	magnitude = pre_tap & PRE_TAP_MAGNITUDE_MASK;
++	if (magnitude)
++		polarity = pre_tap & PRE_TAP_POLARITY ? '-' : '+';
++
++	return scnprintf(buf, PAGE_SIZE, "%c%u\n", polarity, magnitude);
++}
++
++static ssize_t tx_post_tap_store(struct device *dev,
++				 struct device_attribute *attr,
++				 const char *buf, size_t count)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	struct dev_ext_attribute *eattr;
++	u8 magnitude, polarity = 0;
++	const char *p = buf;
++	unsigned long chan;
++	int ret;
++
++	if ((buf[0] == '+') || (buf[0] == '-')) {
++		if (buf[0] == '-')
++			polarity = POST_TAP_POLARITY;
++		p++;
++	}
++
++	ret = kstrtou8(p, 0, &magnitude);
++	if (ret)
++		return ret;
++
++	if (magnitude > POST_TAP_MAX) {
++		dev_err(phy->dev, "Max post-tap is %d\n", POST_TAP_MAX);
++		return -EINVAL;
++	}
++
++	eattr = container_of(attr, struct dev_ext_attribute, attr);
++	chan = (unsigned long)eattr->var;
++
++	mutex_lock(&phy->lock);
++	ret = hssi_xcvr_rmw(phy, (u8)chan, POST_TAP_ADDR,
++			    POST_TAP_POLARITY | POST_TAP_MAGNITUDE_MASK,
++			    polarity | magnitude);
++	mutex_unlock(&phy->lock);
++
++	return ret ? : count;
++}
++
++static ssize_t tx_post_tap_show(struct device *dev,
++				struct device_attribute *attr, char *buf)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	struct dev_ext_attribute *eattr;
++	char polarity = '\0';
++	unsigned long chan;
++	u8 magnitude;
++	u32 post_tap;
++	int ret;
++
++	eattr = container_of(attr, struct dev_ext_attribute, attr);
++	chan = (unsigned long)eattr->var;
++
++	mutex_lock(&phy->lock);
++	ret = hssi_xcvr_read(phy, (u8)chan, POST_TAP_ADDR, &post_tap);
++	mutex_unlock(&phy->lock);
++
++	if (ret)
++		return ret;
++
++	magnitude = post_tap & POST_TAP_MAGNITUDE_MASK;
++	if (magnitude)
++		polarity = post_tap & POST_TAP_POLARITY ? '-' : '+';
++
++	return scnprintf(buf, PAGE_SIZE, "%c%u\n", polarity, magnitude);
++}
++
++static ssize_t tx_vod_store(struct device *dev,
++			    struct device_attribute *attr,
++			    const char *buf, size_t count)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	struct dev_ext_attribute *eattr;
++	unsigned long chan;
++	int ret;
++	u8 vod;
++
++	ret = kstrtou8(buf, 0, &vod);
++	if (ret)
++		return ret;
++
++	if (vod > VOD_MAX || vod < VOD_MIN) {
++		dev_err(phy->dev, "Valid VOD range is %d to %d\n",
++			VOD_MIN, VOD_MAX);
++		return -EINVAL;
++	}
++
++	eattr = container_of(attr, struct dev_ext_attribute, attr);
++	chan = (unsigned long)eattr->var;
++
++	mutex_lock(&phy->lock);
++	ret = hssi_xcvr_rmw(phy, (u8)chan, VOD_COMP_ADDR, VOD_MASK, vod);
++	mutex_unlock(&phy->lock);
++
++	return ret ? : count;
++}
++
++static ssize_t tx_vod_show(struct device *dev,
++			   struct device_attribute *attr, char *buf)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	struct dev_ext_attribute *eattr;
++	unsigned long chan;
++	int ret;
++	u32 vod;
++
++	eattr = container_of(attr, struct dev_ext_attribute, attr);
++	chan = (unsigned long)eattr->var;
++
++	mutex_lock(&phy->lock);
++	ret = hssi_xcvr_read(phy, (u8)chan, VOD_COMP_ADDR, &vod);
++	mutex_unlock(&phy->lock);
++
++	return ret ? : scnprintf(buf, PAGE_SIZE, "%lu\n", vod & VOD_MASK);
++}
++
++static ssize_t tx_comp_store(struct device *dev,
++			     struct device_attribute *attr,
++			     const char *buf, size_t count)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	struct dev_ext_attribute *eattr;
++	unsigned long chan;
++	u8 compensation;
++	int ret;
++
++	ret = kstrtou8(buf, 0, &compensation);
++	if (ret)
++		return ret;
++
++	if (compensation > 1) {
++		dev_err(phy->dev, "Compensation must be 1 or 0");
++		return -EINVAL;
++	}
++
++	eattr = container_of(attr, struct dev_ext_attribute, attr);
++	chan = (unsigned long)eattr->var;
++
++	mutex_lock(&phy->lock);
++	ret = hssi_xcvr_rmw(phy, (u8)chan, VOD_COMP_ADDR, COMPENSATION_FLAG,
++			    compensation ? COMPENSATION_FLAG : 0);
++	mutex_unlock(&phy->lock);
++
++	return ret ? : count;
++}
++
++static ssize_t tx_comp_show(struct device *dev,
++			    struct device_attribute *attr, char *buf)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	struct dev_ext_attribute *eattr;
++	unsigned long chan;
++	u32 compensation;
++	int ret;
++
++	eattr = container_of(attr, struct dev_ext_attribute, attr);
++	chan = (unsigned long)eattr->var;
++
++	mutex_lock(&phy->lock);
++	ret = hssi_xcvr_read(phy, (u8)chan, VOD_COMP_ADDR, &compensation);
++	mutex_unlock(&phy->lock);
++
++	return ret ? : scnprintf(buf, PAGE_SIZE, "%u\n",
++			 compensation & COMPENSATION_FLAG ? 1 : 0);
++}
++
++#define PHY_TUNE_ATTR(_name, _chan)				\
++static struct dev_ext_attribute phy_tune_##_name##_chan = {	\
++	.attr = __ATTR_RW(_name),				\
++	.var = (void *)_chan,					\
++}
++
++#define PHY_TUNE_ATTRS(_chan)					\
++PHY_TUNE_ATTR(tx_comp, _chan);					\
++PHY_TUNE_ATTR(tx_post_tap, _chan);				\
++PHY_TUNE_ATTR(tx_pre_tap, _chan);				\
++PHY_TUNE_ATTR(tx_vod, _chan);					\
++static struct attribute *chan##_chan##_attrs[] = {		\
++	&phy_tune_tx_pre_tap##_chan.attr.attr,		\
++	&phy_tune_tx_post_tap##_chan.attr.attr,		\
++	&phy_tune_tx_vod##_chan.attr.attr,		\
++	&phy_tune_tx_comp##_chan.attr.attr,		\
++	NULL,							\
++};								\
++static struct attribute_group chan##_chan##_attr_group = {	\
++	.name = __stringify(chan##_chan),			\
++	.attrs = chan##_chan##_attrs,				\
++}
++
++PHY_TUNE_ATTRS(0);
++PHY_TUNE_ATTRS(1);
++PHY_TUNE_ATTRS(2);
++PHY_TUNE_ATTRS(3);
++
++static ssize_t ctrl_store(struct device *dev, struct device_attribute *attr,
++			  const char *buf, size_t count)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	int ret;
++	u64 v;
++
++	ret = kstrtou64(buf, 0, &v);
++	if (ret)
++		return ret;
++
++	mutex_lock(&phy->lock);
++	writeq(v, phy->csr_base + HSSI_QSFP_CTRL(phy));
++	mutex_unlock(&phy->lock);
++
++	return count;
++}
++
++static ssize_t ctrl_show(struct device *dev, struct device_attribute *attr,
++			 char *buf)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	u64 v;
++
++	mutex_lock(&phy->lock);
++	v = readq(phy->csr_base + HSSI_QSFP_CTRL(phy));
++	mutex_unlock(&phy->lock);
++
++	return scnprintf(buf, PAGE_SIZE, "0x%016llx\n", v);
++}
++static DEVICE_ATTR_RW(ctrl);
++
++static ssize_t stat_show(struct device *dev, struct device_attribute *attr,
++			 char *buf)
++{
++	struct hssi_phy *phy = dev_get_drvdata(dev);
++	u64 v;
++
++	mutex_lock(&phy->lock);
++	v = readq(phy->csr_base + HSSI_QSFP_STAT(phy));
++	mutex_unlock(&phy->lock);
++
++	return scnprintf(buf, PAGE_SIZE, "0x%016llx\n", v);
++}
++static DEVICE_ATTR_RO(stat);
++
++static struct attribute *qsfp_attrs[] = {
++	&dev_attr_ctrl.attr,
++	&dev_attr_stat.attr,
++	NULL,
++};
++
++static struct attribute_group qsfp_attr_group = {
++	.attrs = qsfp_attrs,
++};
++
++static const struct attribute_group *qsfp_attr_groups[] = {
++	&qsfp_attr_group,
++	&chan0_attr_group,
++	&chan1_attr_group,
++	&chan2_attr_group,
++	&chan3_attr_group,
++	NULL,
++};
++
++static int intel_s10_phy_probe(struct platform_device *pdev)
++{
++	struct intel_s10_platform_data *pdata;
++	struct device *dev = &pdev->dev;
++	struct hssi_phy *phy;
++
++	pdata = dev_get_platdata(dev);
++	if (!pdata)
++		return -ENODEV;
++
++	phy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);
++	if (!phy)
++		return -ENOMEM;
++
++	phy->csr_base = pdata->csr_base;
++	phy->phy_offset = pdata->phy_offset;
++	phy->dev = dev;
++	mutex_init(&phy->lock);
++	dev_set_drvdata(dev, phy);
++
++	return 0;
++}
++
++static int intel_s10_phy_remove(struct platform_device *pdev)
++{
++	struct hssi_phy *phy = dev_get_drvdata(&pdev->dev);
++
++	mutex_destroy(&phy->lock);
++	return 0;
++}
++
++static struct platform_driver intel_s10_phy_driver = {
++	.driver = {
++		.name = INTEL_S10_PHY_DRV_NAME,
++		.dev_groups = qsfp_attr_groups,
++	},
++	.probe = intel_s10_phy_probe,
++	.remove = intel_s10_phy_remove,
++};
++
++module_platform_driver(intel_s10_phy_driver);
++
++MODULE_DESCRIPTION("Intel HSSI Ethernet Phy");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:" INTEL_S10_PHY_DRV_NAME);
+diff --git a/include/linux/phy/intel-s10-phy.h b/include/linux/phy/intel-s10-phy.h
+new file mode 100644
+index 000000000000..a68a5e1d2ba6
+--- /dev/null
++++ b/include/linux/phy/intel-s10-phy.h
+@@ -0,0 +1,21 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Header File for Intel Stratix 10 Phy Driver.
++ *
++ * Copyright 2019-2020 Intel Corporation, Inc.
++ */
++#ifndef __INTEL_S10_PHY_H
++#define __INTEL_S10_PHY_H
++
++#define INTEL_S10_PHY_DRV_NAME	"intel-s10-phy"
++
++/**
++ * struct intel_s10_platform_data - Platform data of the Intel S10 Phy Driver
++ * @csr_base:	Base address of Control & Status registers
++ */
++struct intel_s10_platform_data {
++	void __iomem *csr_base;
++	u32 phy_offset;
++};
++
++#endif /* __INTEL_S10_PHY_H */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0045-fpga-dfl-hssi-driver.patch new/debian/patches/fpga-ofs/0045-fpga-dfl-hssi-driver.patch
--- org/debian/patches/fpga-ofs/0045-fpga-dfl-hssi-driver.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0045-fpga-dfl-hssi-driver.patch	2021-07-20 06:17:11.404844867 +0200
@@ -0,0 +1,240 @@
+From 6d6881805980ab2bdb735655fe8081ba6b003546 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 21 Apr 2020 17:10:20 -0700
+Subject: [PATCH 045/149] fpga: dfl: hssi driver
+
+This driver provides the ability to view and change tuning
+parameters for the ethernet transceivers for the HSSI
+private feature on dfl devices. It is designed as a
+dfl device (it is on the dfl bus) and creates an
+intel-s10-phy platform device for each QSFP.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/Kconfig    |   8 ++
+ drivers/fpga/Makefile   |   1 +
+ drivers/fpga/dfl-hssi.c | 184 ++++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 193 insertions(+)
+ create mode 100644 drivers/fpga/dfl-hssi.c
+
+diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
+index a6a1f5e0d587..6602d01cd9aa 100644
+--- a/drivers/fpga/Kconfig
++++ b/drivers/fpga/Kconfig
+@@ -237,6 +237,14 @@ config FPGA_DFL_PCI
+ 
+ 	  To compile this as a module, choose M here.
+ 
++config FPGA_DFl_HSSI
++	tristate "FPGA DFL HSSI Driver"
++	depends on FPGA_DFL
++	help
++	  This is the HSSI Ethernet driver for the Intel Stratix 10 FPGA.
++	  This driver provides the ability to view and change some of the
++	  transceiver tuning parameters.
++
+ config FPGA_MGR_ZYNQMP_FPGA
+ 	tristate "Xilinx ZynqMP FPGA"
+ 	depends on ZYNQMP_FIRMWARE || (!ZYNQMP_FIRMWARE && COMPILE_TEST)
+diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
+index d30929ff9927..0e907199f531 100644
+--- a/drivers/fpga/Makefile
++++ b/drivers/fpga/Makefile
+@@ -56,3 +56,4 @@ obj-$(CONFIG_FPGA_DFL_SPI_ALTERA)	+= dfl-spi-altera.o
+ 
+ # Drivers for FPGAs which implement DFL
+ obj-$(CONFIG_FPGA_DFL_PCI)		+= dfl-pci.o
++obj-$(CONFIG_FPGA_DFl_HSSI)		+= dfl-hssi.o
+diff --git a/drivers/fpga/dfl-hssi.c b/drivers/fpga/dfl-hssi.c
+new file mode 100644
+index 000000000000..a23e1e32818b
+--- /dev/null
++++ b/drivers/fpga/dfl-hssi.c
+@@ -0,0 +1,184 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Driver for DFL HSSI Configurable Ethernet private feature
++ *
++ * Copyright 2019-2020 Intel Corporation, Inc.
++ */
++
++#include <linux/dfl.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/phy/intel-s10-phy.h>
++#include <linux/slab.h>
++#include "dfl.h"
++
++/* HSSI Private Feature: Capability - Read-Only */
++#define HSSI_CAPABILITY		0x8
++#define   DATA_RATE_AVAIL_1G	BIT_ULL(0)
++#define   DATA_RATE_AVAIL_10G	BIT_ULL(1)
++#define   DATA_RATE_AVAIL_25G	BIT_ULL(2)
++#define   DATA_RATE_AVAIL_40G	BIT_ULL(3)
++#define   DATA_RATE_AVAIL_50G	BIT_ULL(4)
++#define   DATA_RATE_AVAIL_100G	BIT_ULL(5)
++#define   DATA_RATE_AVAIL_200G	BIT_ULL(6)
++#define   DATA_RATE_AVAIL_400G	BIT_ULL(7)
++#define   CONTAINS_PCS_1G	BIT_ULL(8)
++#define   CONTAINS_PCS_10G	BIT_ULL(9)
++#define   CONTAINS_PCS_25G	BIT_ULL(10)
++#define   CONTAINS_PCS_40G	BIT_ULL(11)
++#define   CONTAINS_PCS_50G	BIT_ULL(12)
++#define   CONTAINS_PCS_100G	BIT_ULL(13)
++#define   CONTAINS_PCS_200G	BIT_ULL(14)
++#define   CONTAINS_PCS_400G	BIT_ULL(15)
++#define   CONTAINS_FEC_1G	BIT_ULL(16)
++#define   CONTAINS_FEC_10G	BIT_ULL(17)
++#define   CONTAINS_FEC_25G	BIT_ULL(18)
++#define   CONTAINS_FEC_40G	BIT_ULL(19)
++#define   CONTAINS_FEC_50G	BIT_ULL(20)
++#define   CONTAINS_FEC_100G	BIT_ULL(21)
++#define   CONTAINS_FEC_200G	BIT_ULL(22)
++#define   CONTAINS_FEC_400G	BIT_ULL(23)
++#define   DATA_RATE_SWITCH	BIT_ULL(24)
++#define   LINK_TRAINING		BIT_ULL(25)
++#define   AUTO_NEGOTIATION	BIT_ULL(26)
++#define   CONTAINS_MAC		BIT_ULL(27)
++#define   NUM_QSFP_INTERFACES	GENMASK_ULL(39, 32)
++
++/* QSFP register space */
++#define HSSI_QSFP_BASE		0x10
++#define HSSI_QSFP_SIZE		0x20
++
++struct dfl_hssi {
++	void __iomem *csr_base;
++	struct device *dev;
++	unsigned int qsfp_cnt;
++	struct platform_device *intel_s10_phy[];
++};
++
++static int hssi_create_qsfp(struct dfl_hssi *hssi, struct dfl_device *dfl_dev,
++			    int index)
++{
++	struct intel_s10_platform_data pdata = { 0 };
++	struct platform_device_info pdevinfo = { 0 };
++	struct platform_device *pdev;
++
++	pdata.csr_base = hssi->csr_base;
++	pdata.phy_offset = HSSI_QSFP_BASE + index * HSSI_QSFP_SIZE;
++
++	pdevinfo.name = INTEL_S10_PHY_DRV_NAME;
++	pdevinfo.id = PLATFORM_DEVID_AUTO;
++	pdevinfo.parent = hssi->dev;
++	pdevinfo.data = &pdata;
++	pdevinfo.size_data = sizeof(pdata);
++
++	pdev = platform_device_register_full(&pdevinfo);
++	if (IS_ERR(pdev))
++		return PTR_ERR(pdev);
++
++	hssi->qsfp_cnt++;
++	hssi->intel_s10_phy[index] = pdev;
++
++	return 0;
++}
++
++static void hssi_destroy_qsfp(struct dfl_hssi *hssi, int index)
++{
++	platform_device_unregister(hssi->intel_s10_phy[index]);
++}
++
++static ssize_t capability_show(struct device *dev,
++			       struct device_attribute *attr, char *buf)
++{
++	struct dfl_hssi *hssi = dev_get_drvdata(dev);
++	u64 v = readq(hssi->csr_base + HSSI_CAPABILITY);
++
++	return sprintf(buf, "0x%016llx\n", v);
++}
++static DEVICE_ATTR_RO(capability);
++
++static struct attribute *hssi_attrs[] = {
++	&dev_attr_capability.attr,
++	NULL,
++};
++ATTRIBUTE_GROUPS(hssi);
++
++static int dfl_hssi_probe(struct dfl_device *dfl_dev)
++{
++	struct device *dev = &dfl_dev->dev;
++	struct dfl_hssi *hssi;
++	int ret, qsfp_cnt, i;
++	void __iomem *csr_base;
++	u64 v;
++
++	csr_base = devm_ioremap_resource(&dfl_dev->dev, &dfl_dev->mmio_res);
++	if (IS_ERR(csr_base)) {
++		dev_err(dev, "get mem resource fail!\n");
++		return PTR_ERR(csr_base);
++	}
++
++	if (!dfl_feature_revision(csr_base)) {
++		dev_info(dev, "hssi feature revision 0 not supported\n");
++		return -ENOTSUPP;
++	}
++
++	v = readq(csr_base + HSSI_CAPABILITY);
++	qsfp_cnt = FIELD_GET(NUM_QSFP_INTERFACES, v);
++
++	hssi = devm_kzalloc(dev, sizeof(*hssi) + qsfp_cnt * sizeof(void *),
++			    GFP_KERNEL);
++	if (!hssi)
++		return -ENOMEM;
++
++	dev_set_drvdata(&dfl_dev->dev, hssi);
++
++	hssi->csr_base = csr_base;
++	hssi->dev = dev;
++
++	for (i = 0; i < qsfp_cnt; i++) {
++		ret = hssi_create_qsfp(hssi, dfl_dev, i);
++		if (ret)
++			goto error_exit;
++	}
++
++	return 0;
++
++error_exit:
++	for (i = 0; i < hssi->qsfp_cnt; i++)
++		hssi_destroy_qsfp(hssi, i);
++
++	return ret;
++}
++
++static void dfl_hssi_remove(struct dfl_device *dfl_dev)
++{
++	struct dfl_hssi *hssi = dev_get_drvdata(&dfl_dev->dev);
++	int i;
++
++	for (i = 0; i < hssi->qsfp_cnt; i++)
++		hssi_destroy_qsfp(hssi, i);
++}
++
++#define FME_FEATURE_ID_HSSI_ETH	0xa
++
++static const struct dfl_device_id dfl_hssi_ids[] = {
++	{ FME_ID, FME_FEATURE_ID_HSSI_ETH },
++	{ }
++};
++
++static struct dfl_driver dfl_hssi_driver = {
++	.drv = {
++		.name = "intel-s10-hssi",
++		.dev_groups = hssi_groups,
++	},
++	.id_table = dfl_hssi_ids,
++	.probe = dfl_hssi_probe,
++	.remove = dfl_hssi_remove,
++};
++
++module_dfl_driver(dfl_hssi_driver);
++
++MODULE_DEVICE_TABLE(dfl, dfl_hssi_ids);
++MODULE_DESCRIPTION("DFL HSSI driver");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0046-mfd-intel-m10-bmc-add-bmc-secure-device-for-d5005.patch new/debian/patches/fpga-ofs/0046-mfd-intel-m10-bmc-add-bmc-secure-device-for-d5005.patch
--- org/debian/patches/fpga-ofs/0046-mfd-intel-m10-bmc-add-bmc-secure-device-for-d5005.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0046-mfd-intel-m10-bmc-add-bmc-secure-device-for-d5005.patch	2021-07-20 06:17:11.404844867 +0200
@@ -0,0 +1,150 @@
+From 2670b52af3284ff4d7230c40911ffd9f1ec8f4f7 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 5 May 2020 14:30:08 -0700
+Subject: [PATCH 046/149] mfd: intel-m10-bmc: add bmc secure device for d5005
+
+Add the required security manager support functions to
+enable secure updates of BCM images, BMC firmware,
+static-region images, etc.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 42 +++++++++++++++++++++++++----
+ drivers/mfd/intel-m10-bmc.c         |  6 +----
+ include/linux/mfd/intel-m10-bmc.h   |  6 +++++
+ 3 files changed, 44 insertions(+), 10 deletions(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 29960b27dd03..0d8eefbce97d 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -9,6 +9,7 @@
+ #include <linux/device.h>
+ #include <linux/fpga/fpga-sec-mgr.h>
+ #include <linux/mfd/intel-m10-bmc.h>
++#include <linux/mod_devicetable.h>
+ #include <linux/module.h>
+ #include <linux/platform_device.h>
+ #include <linux/slab.h>
+@@ -755,8 +756,20 @@ static struct image_load n3000_image_load_hndlrs[] = {
+ 	{}
+ };
+ 
++static struct image_load d5005_image_load_hndlrs[] = {
++	{
++		.name = "bmc_factory",
++		.load_image = m10bmc_sec_bmc_image_load_0,
++	},
++	{
++		.name = "bmc_user",
++		.load_image = m10bmc_sec_bmc_image_load_1,
++	},
++	{}
++};
++
+ static struct fpga_sec_mgr_ops *
+-m10bmc_sops_create(struct device *dev)
++m10bmc_sops_create(struct device *dev, enum m10bmc_type type)
+ {
+ 	struct fpga_sec_mgr_ops *sops;
+ 
+@@ -782,13 +795,19 @@ m10bmc_sops_create(struct device *dev)
+ 	sops->poll_complete = m10bmc_sec_poll_complete;
+ 	sops->cancel = m10bmc_sec_cancel;
+ 	sops->get_hw_errinfo = m10bmc_sec_hw_errinfo;
+-	sops->image_load = n3000_image_load_hndlrs;
++
++	if (type == M10_N3000)
++		sops->image_load = n3000_image_load_hndlrs;
++	else
++		sops->image_load = d5005_image_load_hndlrs;
+ 
+ 	return sops;
+ }
+ 
+ static int m10bmc_secure_probe(struct platform_device *pdev)
+ {
++	const struct platform_device_id *id = platform_get_device_id(pdev);
++	enum m10bmc_type type = (enum m10bmc_type)id->driver_data;
+ 	struct fpga_sec_mgr_ops *sops;
+ 	struct fpga_sec_mgr *smgr;
+ 	struct m10bmc_sec *sec;
+@@ -797,7 +816,7 @@ static int m10bmc_secure_probe(struct platform_device *pdev)
+ 	if (!sec)
+ 		return -ENOMEM;
+ 
+-	sops = m10bmc_sops_create(&pdev->dev);
++	sops = m10bmc_sops_create(&pdev->dev, type);
+ 	if (!sops)
+ 		return -ENOMEM;
+ 
+@@ -815,15 +834,28 @@ static int m10bmc_secure_probe(struct platform_device *pdev)
+ 	return devm_fpga_sec_mgr_register(sec->dev, smgr);
+ }
+ 
++static const struct platform_device_id intel_m10bmc_secure_ids[] = {
++	{
++		.name = "n3000bmc-secure",
++		.driver_data = (unsigned long)M10_N3000,
++	},
++	{
++		.name = "d5005bmc-secure",
++		.driver_data = (unsigned long)M10_D5005,
++	},
++	{ }
++};
++
+ static struct platform_driver intel_m10bmc_secure_driver = {
+ 	.probe = m10bmc_secure_probe,
+ 	.driver = {
+-		.name = "n3000bmc-secure",
++		.name = "intel-m10bmc-secure",
+ 	},
++	.id_table = intel_m10bmc_secure_ids,
+ };
+ module_platform_driver(intel_m10bmc_secure_driver);
+ 
+-MODULE_ALIAS("platform:n3000bmc-secure");
++MODULE_DEVICE_TABLE(platform, intel_m10bmc_secure_ids);
+ MODULE_AUTHOR("Intel Corporation");
+ MODULE_DESCRIPTION("Intel MAX10 BMC Secure Update");
+ MODULE_LICENSE("GPL v2");
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index cbfe2b96d63d..25539109c9e5 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -13,13 +13,9 @@
+ #include <linux/regmap.h>
+ #include <linux/spi/spi.h>
+ 
+-enum m10bmc_type {
+-	M10_N3000,
+-	M10_D5005
+-};
+-
+ static struct mfd_cell m10bmc_bmc_subdevs[] = {
+ 	{ .name = "d5005bmc-hwmon" },
++	{ .name = "d5005bmc-secure" }
+ };
+ 
+ static struct mfd_cell m10bmc_pacn3000_subdevs[] = {
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 36f1455dd1e1..1eeeb523422b 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -10,6 +10,12 @@
+ #include <linux/regmap.h>
+ #include <linux/rwsem.h>
+ 
++/* Supported MAX10 BMC types */
++enum m10bmc_type {
++	M10_N3000,
++	M10_D5005
++};
++
+ #define M10BMC_LEGACY_SYS_BASE		0x300400
+ #define M10BMC_SYS_BASE			0x300800
+ #define M10BMC_MEM_END			0x200000fc
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0047-fpga-dfl-iopll-user-clock-driver-for-pr-region.patch new/debian/patches/fpga-ofs/0047-fpga-dfl-iopll-user-clock-driver-for-pr-region.patch
--- org/debian/patches/fpga-ofs/0047-fpga-dfl-iopll-user-clock-driver-for-pr-region.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0047-fpga-dfl-iopll-user-clock-driver-for-pr-region.patch	2021-07-20 06:17:11.404844867 +0200
@@ -0,0 +1,680 @@
+From b58fa05a76a7f8d220420e327d050c74ed06014f Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 7 Aug 2020 18:26:29 -0700
+Subject: [PATCH 047/149] fpga: dfl: iopll user clock driver for pr region
+
+Provide a dfl driver for the configurable IOPLL user
+clock source. This driver can configure the clock speeds
+that are used for RTL logic that is programmed into the
+Partial Reconfiguration (PR) region of an FPGA. The user
+clock frequencies can be configured through the sysfs nodes
+that are provided by the driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ .../sysfs-bus-dfl-devices-intel-s10-iopll     |  29 +
+ drivers/fpga/Kconfig                          |  10 +
+ drivers/fpga/Makefile                         |   1 +
+ drivers/fpga/dfl-intel-s10-iopll.c            | 550 ++++++++++++++++++
+ include/uapi/linux/intel-dfl-iopll.h          |  28 +
+ 5 files changed, 618 insertions(+)
+ create mode 100644 Documentation/ABI/testing/sysfs-bus-dfl-devices-intel-s10-iopll
+ create mode 100644 drivers/fpga/dfl-intel-s10-iopll.c
+ create mode 100644 include/uapi/linux/intel-dfl-iopll.h
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-dfl-devices-intel-s10-iopll b/Documentation/ABI/testing/sysfs-bus-dfl-devices-intel-s10-iopll
+new file mode 100644
+index 000000000000..77a1400a771c
+--- /dev/null
++++ b/Documentation/ABI/testing/sysfs-bus-dfl-devices-intel-s10-iopll
+@@ -0,0 +1,29 @@
++What:		/sys/bus/dfl/devices/dfl-port.X.X/userclk/frequency
++Date:		Aug 2020
++KernelVersion:	5.9
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read/Write. When read, the frequencies of both the low
++		and high frequency clocks. These are displayed as two
++		decimal values in units of KHz. The low frequency is
++		listed first. The high clock frequency is generally 2x
++		the low frequency, except that as the low clock exceeds
++		300MHz, the high clock remains at 600MHz. When written,
++		this file receives binary data containing the
++		configuration parameters required to obtain the desired
++		clock frequencies.
++		Read format: %u %u
++
++What:		/sys/bus/dfl/devices/dfl-port.X.X/userclk/ref_frequency
++Date:		Aug 2020
++KernelVersion:	5.9
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Displays the user clock reference frequency in KHZ.
++		Format: %llu
++
++What:		/sys/bus/dfl/devices/dfl-port.0.6/userclk/revision
++Date:		June 2020
++KernelVersion:	5.9
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Displays the revision number for the user clock
++		implementation.
++		Format: %llu
+diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
+index 6602d01cd9aa..691c6ae2f5d0 100644
+--- a/drivers/fpga/Kconfig
++++ b/drivers/fpga/Kconfig
+@@ -274,4 +274,14 @@ config IFPGA_M10_BMC_SECURE
+ 	  (BMC) and provides support for secure updates for the BMC image,
+ 	  the FPGA image, the Root Entry Hashes, etc.
+ 
++config FPGA_DFL_INTEL_S10_IOPLL
++	tristate "FPGA DFL Intel S10 IOPLL User Clock"
++        help
++	  The FPGA DFL driver for the Intel S10 IOPLL device provides
++	  a configurable clock that can be used to drive RTL logic in
++	  the Partial Reconfiguration (PR) region of an FPGA. The clock
++	  speed can be configured dynamically from user space. Select
++	  this option to support a configurable user clock in FPGA
++	  PR regions.
++
+ endif # FPGA
+diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
+index 0e907199f531..849a39b6dd74 100644
+--- a/drivers/fpga/Makefile
++++ b/drivers/fpga/Makefile
+@@ -57,3 +57,4 @@ obj-$(CONFIG_FPGA_DFL_SPI_ALTERA)	+= dfl-spi-altera.o
+ # Drivers for FPGAs which implement DFL
+ obj-$(CONFIG_FPGA_DFL_PCI)		+= dfl-pci.o
+ obj-$(CONFIG_FPGA_DFl_HSSI)		+= dfl-hssi.o
++obj-$(CONFIG_FPGA_DFL_INTEL_S10_IOPLL)	+= dfl-intel-s10-iopll.o
+diff --git a/drivers/fpga/dfl-intel-s10-iopll.c b/drivers/fpga/dfl-intel-s10-iopll.c
+new file mode 100644
+index 000000000000..ce648a2b2de2
+--- /dev/null
++++ b/drivers/fpga/dfl-intel-s10-iopll.c
+@@ -0,0 +1,550 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Driver for DFL IOPLL User Clock private feature
++ *
++ * Copyright 2019-2020 Intel Corporation, Inc.
++ */
++
++#include <linux/dfl.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/iopoll.h>
++#include <uapi/linux/intel-dfl-iopll.h>
++#include <linux/module.h>
++
++#include "dfl.h"
++
++struct dfl_iopll {
++	void __iomem *csr_base;
++	struct device *dev;
++	struct mutex iopll_mutex;	/* Serialize access to iopll */
++};
++
++/*
++ * IOPLL CSR register definitions
++ */
++#define IOPLL_FREQ_CMD0		0x8
++/* Field definitions for both IOPLL_FREQ_CMD0 and IOPLL_FREQ_STS0 */
++#define   IOPLL_DATA		GENMASK_ULL(31, 0)
++#define   IOPLL_ADDR		GENMASK_ULL(41, 32)
++#define   IOPLL_WRITE		BIT_ULL(44)
++#define   IOPLL_SEQ		GENMASK_ULL(49, 48)
++#define   IOPLL_AVMM_RESET_N	BIT_ULL(52)
++#define   IOPLL_MGMT_RESET	BIT_ULL(56)
++#define   IOPLL_RESET		BIT_ULL(57)
++
++#define IOPLL_FREQ_CMD1		0x10
++/* Field definitions for both IOPLL_FREQ_CMD1 and IOPLL_FREQ_STS1 */
++#define   IOPLL_CLK_MEASURE	BIT_ULL(32)	/* Measure clk: 0=1x, 1=2x */
++
++#define IOPLL_FREQ_STS0		0x18
++#define   IOPLL_LOCKED		BIT_ULL(60)
++#define   IOPLL_AVMM_ERROR	BIT_ULL(63)
++
++#define IOPLL_FREQ_STS1		0x20
++#define   IOPLL_FREQUENCY	GENMASK_ULL(16, 0)	/* 10 kHz units */
++#define   IOPLL_REF_FREQ	GENMASK_ULL(50, 33)	/* Reference Freq */
++#define   IOPLL_VERSION		GENMASK_ULL(63, 60)	/* User clock version */
++
++/*
++ * Control and status registers for the IOPLL
++ * https://www.altera.com/en_US/pdfs/literature/hb/stratix-10/ug-s10-clkpll.pdf
++ * Section 7.2
++ */
++
++#define CFG_PLL_LOW			GENMASK_ULL(7, 0)
++#define CFG_PLL_HIGH			GENMASK_ULL(15, 8)
++#define CFG_PLL_BYPASS_EN		BIT_ULL(16)
++#define CFG_PLL_EVEN_DUTY_EN		BIT_ULL(17)
++
++#define PLL_EVEN_DUTY_EN_SHIFT	7
++
++#define PLL_N_HIGH_ADDR			0x100
++#define PLL_N_BYPASS_EN_ADDR		0x101 /* Same as PLL_CP1_ADDR */
++#define PLL_N_EVEN_DUTY_EN_ADDR		0x101 /* Same as PLL_CP1_ADDR */
++#define PLL_N_LOW_ADDR			0x102
++
++#define PLL_M_HIGH_ADDR			0x104
++#define PLL_M_BYPASS_EN_ADDR		0x105
++#define PLL_M_EVEN_DUTY_EN_ADDR		0x106
++#define PLL_M_LOW_ADDR			0x107
++
++#define PLL_C0_HIGH_ADDR		0x11b
++#define PLL_C0_BYPASS_EN_ADDR		0x11c
++#define PLL_C0_EVEN_DUTY_EN_ADDR	0x11d
++#define PLL_C0_LOW_ADDR			0x11e
++
++#define PLL_C1_HIGH_ADDR		0x11f
++#define PLL_C1_BYPASS_EN_ADDR		0x120
++#define PLL_C1_EVEN_DUTY_EN_ADDR	0x121
++#define PLL_C1_LOW_ADDR			0x122
++
++#define CFG_PLL_CP1			GENMASK_ULL(2, 0)
++#define PLL_CP1_ADDR			0x101 /* Same as PLL_N_BYPASS_EN_ADDR */
++#define PLL_CP1_SHIFT			4
++
++#define CFG_PLL_LF			GENMASK_ULL(13, 6)
++#define PLL_LF_ADDR			0x10a
++#define PLL_LF_SHIFT			3
++
++#define CFG_PLL_CP2			GENMASK_ULL(5, 3)
++#define PLL_CP2_ADDR			0x10d
++#define PLL_CP2_SHIFT			5
++
++#define CFG_PLL_RC			GENMASK_ULL(1, 0)
++#define PLL_RC_SHIFT			1
++
++#define PLL_REQUEST_CAL_ADDR		0x149
++#define PLL_REQUEST_CALIBRATION		BIT(6)
++
++#define PLL_ENABLE_CAL_ADDR		0x14a
++#define PLL_ENABLE_CALIBRATION		0x03
++
++#define IOPLL_MEASURE_LOW		0
++#define IOPLL_MEASURE_HIGH		1
++#define IOPLL_MEASURE_DELAY_MS		4
++#define IOPLL_RESET_DELAY_MS		1
++#define IOPLL_CAL_DELAY_MS		1
++
++#define	FREQ_IN_KHZ(freq)		((freq) * 10)
++
++#define IOPLL_WRITE_POLL_INVL_US	10	/* Write poll interval */
++#define IOPLL_WRITE_POLL_TIMEOUT_US	1000000	/* Write poll timeout */
++
++static int iopll_reset(struct dfl_iopll *iopll)
++{
++	u64 v;
++
++	dev_dbg(iopll->dev, "Reset IOPLL\n");
++
++	/* Assert all resets. IOPLL_AVMM_RESET_N is asserted implicitly */
++	v = IOPLL_MGMT_RESET | IOPLL_RESET;
++	writeq(v, iopll->csr_base + IOPLL_FREQ_CMD0);
++
++	msleep(IOPLL_RESET_DELAY_MS);
++
++	/* De-assert the iopll reset only */
++	v = IOPLL_MGMT_RESET;
++	writeq(v, iopll->csr_base + IOPLL_FREQ_CMD0);
++
++	msleep(IOPLL_RESET_DELAY_MS);
++
++	/* De-assert the remaining resets */
++	v = IOPLL_AVMM_RESET_N;
++	writeq(v, iopll->csr_base + IOPLL_FREQ_CMD0);
++
++	msleep(IOPLL_RESET_DELAY_MS);
++
++	v = readq(iopll->csr_base + IOPLL_FREQ_STS0);
++	if (!(v & IOPLL_LOCKED)) {
++		dev_err(iopll->dev, "IOPLL NOT locked after reset\n");
++		return -EBUSY;
++	}
++
++	return 0;
++}
++
++static int iopll_read_freq(struct dfl_iopll *iopll, u8 clock_sel, u32 *freq)
++{
++	u64 v;
++
++	dev_dbg(iopll->dev, "Read Frequency: %d\n", clock_sel);
++
++	v = readq(iopll->csr_base + IOPLL_FREQ_STS0);
++	if (!(v & IOPLL_LOCKED)) {
++		dev_err(iopll->dev, "IOPLL is NOT locked!\n");
++		return -EBUSY;
++	}
++
++	v = FIELD_PREP(IOPLL_CLK_MEASURE, clock_sel);
++	writeq(v, iopll->csr_base + IOPLL_FREQ_CMD1);
++
++	msleep(IOPLL_MEASURE_DELAY_MS);
++
++	v = readq(iopll->csr_base + IOPLL_FREQ_STS1);
++
++	*freq = FIELD_GET(IOPLL_FREQUENCY, v);
++	return 0;
++}
++
++static int iopll_write(struct dfl_iopll *iopll, u16 address, u32 data, u8 seq)
++{
++	int ret;
++	u64 v;
++
++	seq &= 0x3;
++
++	v = FIELD_PREP(IOPLL_DATA, data);
++	v |= FIELD_PREP(IOPLL_ADDR, address);
++	v |= IOPLL_WRITE;
++	v |= FIELD_PREP(IOPLL_SEQ, seq);
++	v |= IOPLL_AVMM_RESET_N;
++	writeq(v, iopll->csr_base + IOPLL_FREQ_CMD0);
++
++	ret = readq_poll_timeout(iopll->csr_base + IOPLL_FREQ_STS0, v,
++				 FIELD_GET(IOPLL_SEQ, v) == seq,
++				 IOPLL_WRITE_POLL_INVL_US,
++				 IOPLL_WRITE_POLL_TIMEOUT_US);
++	if (ret)
++		dev_err(iopll->dev, "Timeout on IOPLL write\n");
++
++	return ret;
++}
++
++static int iopll_read(struct dfl_iopll *iopll, u16 address, u32 *data, u8 seq)
++{
++	int ret;
++	u64 v;
++
++	seq &= 0x3;
++
++	v = FIELD_PREP(IOPLL_ADDR, address);
++	v |= FIELD_PREP(IOPLL_SEQ, seq);
++	v |= IOPLL_AVMM_RESET_N;
++	writeq(v, iopll->csr_base + IOPLL_FREQ_CMD0);
++
++	ret = readq_poll_timeout(iopll->csr_base + IOPLL_FREQ_STS0, v,
++				 FIELD_GET(IOPLL_SEQ, v) == seq,
++				 IOPLL_WRITE_POLL_INVL_US,
++				 IOPLL_WRITE_POLL_TIMEOUT_US);
++	if (ret)
++		dev_err(iopll->dev, "Timeout on IOPLL read\n");
++	else
++		*data = FIELD_GET(IOPLL_DATA, v);
++
++	return ret;
++}
++
++static int iopll_update_bits(struct dfl_iopll *iopll, u16 address, u32 mask,
++			     u32 bits, u8 *seq)
++{
++	u32 data;
++	int ret;
++
++	ret = iopll_read(iopll, address, &data, (*seq)++);
++	if (ret)
++		return ret;
++
++	data &= ~mask;
++	data |= (bits & mask);
++
++	return iopll_write(iopll, PLL_REQUEST_CAL_ADDR,
++			   data | PLL_REQUEST_CALIBRATION, (*seq)++);
++}
++
++static int iopll_m_write(struct dfl_iopll *iopll, u32 cfg_pll_m, u8 *seq)
++{
++	u32 high, low, bypass_en, even_duty_en;
++	int ret;
++
++	high = FIELD_GET(CFG_PLL_HIGH, cfg_pll_m);
++	ret = iopll_write(iopll, PLL_M_HIGH_ADDR, high, (*seq)++);
++	if (ret)
++		return ret;
++
++	low = FIELD_GET(CFG_PLL_LOW, cfg_pll_m);
++	ret = iopll_write(iopll, PLL_M_LOW_ADDR, low, (*seq)++);
++	if (ret)
++		return ret;
++
++	bypass_en = FIELD_GET(CFG_PLL_BYPASS_EN, cfg_pll_m);
++	ret = iopll_write(iopll, PLL_M_BYPASS_EN_ADDR, bypass_en, (*seq)++);
++	if (ret)
++		return ret;
++
++	even_duty_en = FIELD_GET(CFG_PLL_EVEN_DUTY_EN, cfg_pll_m) <<
++		PLL_EVEN_DUTY_EN_SHIFT;
++	return iopll_write(iopll, PLL_M_EVEN_DUTY_EN_ADDR,
++			   even_duty_en, (*seq)++);
++}
++
++static int iopll_n_write(struct dfl_iopll *iopll, u32 cfg_pll_n,
++			 u32 cfg_pll_cp, u8 *seq)
++{
++	u32 high, low, bypass_en, even_duty_en, cp1;
++	int ret;
++
++	high = FIELD_GET(CFG_PLL_HIGH, cfg_pll_n);
++	ret = iopll_write(iopll, PLL_N_HIGH_ADDR, high, (*seq)++);
++	if (ret)
++		return ret;
++
++	low = FIELD_GET(CFG_PLL_LOW, cfg_pll_n);
++	ret = iopll_write(iopll, PLL_N_LOW_ADDR, low, (*seq)++);
++	if (ret)
++		return ret;
++
++	even_duty_en = FIELD_GET(CFG_PLL_EVEN_DUTY_EN, cfg_pll_n) <<
++		PLL_EVEN_DUTY_EN_SHIFT;
++	cp1 = FIELD_GET(CFG_PLL_CP1, cfg_pll_cp) << PLL_CP1_SHIFT;
++	bypass_en = FIELD_GET(CFG_PLL_BYPASS_EN, cfg_pll_n);
++	return iopll_write(iopll, PLL_N_BYPASS_EN_ADDR,
++			   even_duty_en | cp1 | bypass_en, (*seq)++);
++}
++
++static int iopll_c0_write(struct dfl_iopll *iopll, u32 cfg_pll_c0, u8 *seq)
++{
++	u32 high, low, bypass_en, even_duty_en;
++	int ret;
++
++	high = FIELD_GET(CFG_PLL_HIGH, cfg_pll_c0);
++	ret = iopll_write(iopll, PLL_C0_HIGH_ADDR, high, (*seq)++);
++	if (ret)
++		return ret;
++
++	low = FIELD_GET(CFG_PLL_LOW, cfg_pll_c0);
++	ret = iopll_write(iopll, PLL_C0_LOW_ADDR, low, (*seq)++);
++	if (ret)
++		return ret;
++
++	bypass_en = FIELD_GET(CFG_PLL_BYPASS_EN, cfg_pll_c0);
++	ret = iopll_write(iopll, PLL_C0_BYPASS_EN_ADDR, bypass_en, (*seq)++);
++	if (ret)
++		return ret;
++
++	even_duty_en = FIELD_GET(CFG_PLL_EVEN_DUTY_EN, cfg_pll_c0) <<
++		PLL_EVEN_DUTY_EN_SHIFT;
++	return iopll_write(iopll, PLL_C0_EVEN_DUTY_EN_ADDR,
++			  even_duty_en, (*seq)++);
++}
++
++static int iopll_c1_write(struct dfl_iopll *iopll, u32 cfg_pll_c1, u8 *seq)
++{
++	u32 high, low, bypass_en, even_duty_en;
++	int ret;
++
++	high = FIELD_GET(CFG_PLL_HIGH, cfg_pll_c1);
++	ret = iopll_write(iopll, PLL_C1_HIGH_ADDR, high, (*seq)++);
++	if (ret)
++		return ret;
++
++	low = FIELD_GET(CFG_PLL_LOW, cfg_pll_c1);
++	ret = iopll_write(iopll, PLL_C1_LOW_ADDR, low, (*seq)++);
++	if (ret)
++		return ret;
++
++	bypass_en = FIELD_GET(CFG_PLL_BYPASS_EN, cfg_pll_c1);
++	ret = iopll_write(iopll, PLL_C1_BYPASS_EN_ADDR, bypass_en, (*seq)++);
++	if (ret)
++		return ret;
++
++	even_duty_en = FIELD_GET(CFG_PLL_EVEN_DUTY_EN, cfg_pll_c1) <<
++		PLL_EVEN_DUTY_EN_SHIFT;
++	return iopll_write(iopll, PLL_C1_EVEN_DUTY_EN_ADDR,
++			   even_duty_en, (*seq)++);
++}
++
++static int iopll_set_freq(struct dfl_iopll *iopll,
++			  struct pll_config *c, u8 *seq)
++{
++	u32 cp2, lf, rc;
++	int ret;
++
++	dev_dbg(iopll->dev, "Set Frequency\n");
++
++	ret = iopll_m_write(iopll, c->pll_m, seq);
++	if (ret)
++		return ret;
++
++	ret = iopll_n_write(iopll, c->pll_n, c->pll_cp, seq);
++	if (ret)
++		return ret;
++
++	ret = iopll_c0_write(iopll, c->pll_c0, seq);
++	if (ret)
++		return ret;
++
++	ret = iopll_c1_write(iopll, c->pll_c1, seq);
++	if (ret)
++		return ret;
++
++	cp2 = FIELD_GET(CFG_PLL_CP2, c->pll_cp) << PLL_CP2_SHIFT;
++	ret = iopll_write(iopll, PLL_CP2_ADDR, cp2, (*seq)++);
++	if (ret)
++		return ret;
++
++	lf = FIELD_GET(CFG_PLL_LF, c->pll_lf) << PLL_LF_SHIFT;
++	rc = FIELD_GET(CFG_PLL_RC, c->pll_rc) << PLL_RC_SHIFT;
++	return iopll_write(iopll, PLL_LF_ADDR, lf | rc, (*seq)++);
++}
++
++static int iopll_calibrate(struct dfl_iopll *iopll, u8 *seq)
++{
++	int ret;
++
++	dev_dbg(iopll->dev, "Request Calibration\n");
++
++	/* Request IOPLL Calibration */
++	ret = iopll_update_bits(iopll, PLL_REQUEST_CAL_ADDR,
++				PLL_REQUEST_CALIBRATION,
++				PLL_REQUEST_CALIBRATION, seq);
++	if (ret)
++		return ret;
++
++	/* Enable calibration interface */
++	ret = iopll_write(iopll, PLL_ENABLE_CAL_ADDR, PLL_ENABLE_CALIBRATION,
++			  (*seq)++);
++	msleep(IOPLL_CAL_DELAY_MS);
++	return ret;
++}
++
++static ssize_t frequency_show(struct device *dev,
++			      struct device_attribute *attr, char *buf)
++{
++	struct dfl_iopll *iopll = dev_get_drvdata(dev);
++	u32 low_freq, high_freq;
++	int ret;
++
++	dev_dbg(dev, "Userclk Frequency Show.\n");
++	mutex_lock(&iopll->iopll_mutex);
++
++	ret = iopll_read_freq(iopll, IOPLL_MEASURE_HIGH, &high_freq);
++	if (ret)
++		goto done;
++
++	ret = iopll_read_freq(iopll, IOPLL_MEASURE_LOW, &low_freq);
++
++done:
++	mutex_unlock(&iopll->iopll_mutex);
++	return ret ? : sprintf(buf, "%u %u\n", FREQ_IN_KHZ(low_freq),
++			       FREQ_IN_KHZ(high_freq));
++}
++
++static ssize_t frequency_store(struct device *dev,
++			       struct device_attribute *attr,
++			       const char *buf, size_t count)
++{
++	struct pll_config *iopll_config = (struct pll_config *)buf;
++	struct dfl_iopll *iopll = dev_get_drvdata(dev);
++	u8 seq = 1;
++	int ret;
++
++	dev_dbg(dev, "Userclk Frequency Store.\n");
++	if (count != sizeof(struct pll_config))
++		return -EINVAL;
++
++	if ((iopll_config->pll_freq_khz > IOPLL_MAX_FREQ * 1000) ||
++	    (iopll_config->pll_freq_khz < IOPLL_MIN_FREQ * 1000))
++		return -EINVAL;
++
++	mutex_lock(&iopll->iopll_mutex);
++
++	ret = iopll_set_freq(iopll, iopll_config, &seq);
++	if (ret)
++		goto done;
++
++	ret = iopll_reset(iopll);
++	if (ret)
++		goto done;
++
++	ret = iopll_calibrate(iopll, &seq);
++
++done:
++	mutex_unlock(&iopll->iopll_mutex);
++	return ret ? : count;
++}
++static DEVICE_ATTR_RW(frequency);
++
++static ssize_t revision_show(struct device *dev,
++			     struct device_attribute *attr, char *buf)
++{
++	struct dfl_iopll *iopll = dev_get_drvdata(dev);
++	u64 v;
++
++	dev_dbg(dev, "Userclk Version Show.\n");
++
++	mutex_lock(&iopll->iopll_mutex);
++	v = readq(iopll->csr_base + IOPLL_FREQ_STS1);
++	mutex_unlock(&iopll->iopll_mutex);
++
++	return sprintf(buf, "%llu\n", FIELD_GET(IOPLL_VERSION, v));
++}
++static DEVICE_ATTR_RO(revision);
++
++static ssize_t ref_frequency_show(struct device *dev,
++				  struct device_attribute *attr, char *buf)
++{
++	struct dfl_iopll *iopll = dev_get_drvdata(dev);
++	u64 v;
++
++	dev_dbg(dev, "Userclk Reference Frequency Show.\n");
++
++	mutex_lock(&iopll->iopll_mutex);
++	v = readq(iopll->csr_base + IOPLL_FREQ_STS1);
++	mutex_unlock(&iopll->iopll_mutex);
++
++	return sprintf(buf, "%llu\n",
++		       FREQ_IN_KHZ(FIELD_GET(IOPLL_REF_FREQ, v)));
++}
++static DEVICE_ATTR_RO(ref_frequency);
++
++static  struct attribute *iopll_attrs[] = {
++	&dev_attr_frequency.attr,
++	&dev_attr_revision.attr,
++	&dev_attr_ref_frequency.attr,
++	NULL,
++};
++
++static const struct attribute_group iopll_attr_group = {
++	.name	= "userclk",
++	.attrs	= iopll_attrs,
++};
++
++static const struct attribute_group *iopll_attr_groups[] = {
++	&iopll_attr_group,
++	NULL
++};
++
++static int dfl_intel_s10_iopll_probe(struct dfl_device *dfl_dev)
++{
++	struct device *dev = &dfl_dev->dev;
++	struct dfl_iopll *iopll;
++	void __iomem *csr_base;
++
++	csr_base = devm_ioremap_resource(dev, &dfl_dev->mmio_res);
++	if (IS_ERR(csr_base)) {
++		dev_err(dev, "Failed to get mem resource!\n");
++		return PTR_ERR(csr_base);
++	}
++
++	iopll = devm_kzalloc(dev, sizeof(*iopll), GFP_KERNEL);
++	if (!iopll)
++		return -ENOMEM;
++
++	iopll->csr_base = csr_base;
++	iopll->dev = dev;
++	mutex_init(&iopll->iopll_mutex);
++	dev_set_drvdata(dev, iopll);
++
++	return 0;
++}
++
++static void dfl_intel_s10_iopll_remove(struct dfl_device *dfl_dev)
++{
++	struct dfl_iopll *iopll = dev_get_drvdata(&dfl_dev->dev);
++
++	mutex_destroy(&iopll->iopll_mutex);
++}
++
++#define PORT_FEATURE_ID_IOPLL 0x14
++
++static const struct dfl_device_id dfl_intel_s10_iopll_ids[] = {
++	{ PORT_ID, PORT_FEATURE_ID_IOPLL },
++	{ }
++};
++
++static struct dfl_driver dfl_intel_s10_iopll_driver = {
++	.drv = {
++		.name = "intel-dfl-iopll",
++		.dev_groups = iopll_attr_groups,
++	},
++	.id_table = dfl_intel_s10_iopll_ids,
++	.probe = dfl_intel_s10_iopll_probe,
++	.remove = dfl_intel_s10_iopll_remove,
++};
++
++module_dfl_driver(dfl_intel_s10_iopll_driver);
++
++MODULE_DEVICE_TABLE(dfl, dfl_intel_s10_iopll_ids);
++MODULE_DESCRIPTION("DFL Intel S10 IOPLL driver");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+diff --git a/include/uapi/linux/intel-dfl-iopll.h b/include/uapi/linux/intel-dfl-iopll.h
+new file mode 100644
+index 000000000000..a521710881e9
+--- /dev/null
++++ b/include/uapi/linux/intel-dfl-iopll.h
+@@ -0,0 +1,28 @@
++/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
++/*
++ * Header File for the IOPLL driver for the Intel PAC
++ *
++ * Copyright 2018-2020 Intel Corporation, Inc.
++ */
++
++#ifndef _UAPI_INTEL_DFL_IOPLL_H
++#define _UAPI_INTEL_DFL_IOPLL_H
++
++/*
++ * IOPLL Configuration support.
++ */
++#define  IOPLL_MAX_FREQ         600
++#define  IOPLL_MIN_FREQ         1
++
++struct pll_config {
++	unsigned int pll_freq_khz;
++	unsigned int pll_m;
++	unsigned int pll_n;
++	unsigned int pll_c1;
++	unsigned int pll_c0;
++	unsigned int pll_lf;
++	unsigned int pll_cp;
++	unsigned int pll_rc;
++};
++
++#endif /* _UAPI_INTEL_DFL_IOPLL_H */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0048-dfl-add-generic-indirect-regmap-support.patch new/debian/patches/fpga-ofs/0048-dfl-add-generic-indirect-regmap-support.patch
--- org/debian/patches/fpga-ofs/0048-dfl-add-generic-indirect-regmap-support.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0048-dfl-add-generic-indirect-regmap-support.patch	2021-07-20 06:17:11.408844856 +0200
@@ -0,0 +1,213 @@
+From 2bec747f7145a9c292e97912b6bf244f3592efe5 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Tue, 28 Jul 2020 16:48:01 -0700
+Subject: [PATCH 048/149] dfl: add generic indirect regmap support
+
+Add support for a generic indirect register access via a regmap
+interface.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ drivers/base/regmap/Kconfig                   |   3 +
+ drivers/base/regmap/Makefile                  |   1 +
+ .../base/regmap/regmap-indirect-register.c    | 144 ++++++++++++++++++
+ include/linux/regmap.h                        |  12 ++
+ 4 files changed, 160 insertions(+)
+ create mode 100644 drivers/base/regmap/regmap-indirect-register.c
+
+diff --git a/drivers/base/regmap/Kconfig b/drivers/base/regmap/Kconfig
+index bcb90d8c3960..9a15e4974480 100644
+--- a/drivers/base/regmap/Kconfig
++++ b/drivers/base/regmap/Kconfig
+@@ -57,3 +57,6 @@ config REGMAP_I3C
+ config REGMAP_SPI_AVMM
+ 	tristate
+ 	depends on SPI
++
++config REGMAP_INDIRECT_REGISTER
++	tristate
+diff --git a/drivers/base/regmap/Makefile b/drivers/base/regmap/Makefile
+index ac1b69ee4051..33a97b5e6d6c 100644
+--- a/drivers/base/regmap/Makefile
++++ b/drivers/base/regmap/Makefile
+@@ -18,3 +18,4 @@ obj-$(CONFIG_REGMAP_SOUNDWIRE) += regmap-sdw.o
+ obj-$(CONFIG_REGMAP_SCCB) += regmap-sccb.o
+ obj-$(CONFIG_REGMAP_I3C) += regmap-i3c.o
+ obj-$(CONFIG_REGMAP_SPI_AVMM) += regmap-spi-avmm.o
++obj-$(CONFIG_REGMAP_INDIRECT_REGISTER) += regmap-indirect-register.o
+diff --git a/drivers/base/regmap/regmap-indirect-register.c b/drivers/base/regmap/regmap-indirect-register.c
+new file mode 100644
+index 000000000000..efefc2455489
+--- /dev/null
++++ b/drivers/base/regmap/regmap-indirect-register.c
+@@ -0,0 +1,144 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Indirect Register Access.
++ *
++ * Copyright (C) 2020 Intel Corporation, Inc.
++ */
++#include <linux/debugfs.h>
++#include <linux/device.h>
++#include <linux/module.h>
++#include <linux/mutex.h>
++#include <linux/regmap.h>
++#include <linux/seq_file.h>
++#include <linux/slab.h>
++
++#define INDIRECT_CMD_OFF	0x0
++#define INDIRECT_CMD_RD	BIT(0)
++#define INDIRECT_CMD_WR	BIT(1)
++#define INDIRECT_CMD_ACK	BIT(2)
++
++#define INDIRECT_ADDR_OFF	0x4
++#define INDIRECT_RD_OFF	0x8
++#define INDIRECT_WR_OFF	0xc
++
++#define INDIRECT_INT_US	1
++#define INDIRECT_TIMEOUT_US	10000
++
++struct indirect_ctx {
++	void __iomem *base;
++	struct device *dev;
++};
++
++static int indirect_bus_clr_cmd(struct indirect_ctx *ctx)
++{
++	unsigned int cmd;
++	int ret;
++
++	writel(0, ctx->base + INDIRECT_CMD_OFF);
++
++	ret = readl_poll_timeout((ctx->base + INDIRECT_CMD_OFF), cmd,
++				 (!cmd), INDIRECT_INT_US, INDIRECT_TIMEOUT_US);
++
++	if (ret)
++		dev_err(ctx->dev, "%s timed out on clearing cmd 0x%xn", __func__, cmd);
++
++	return ret;
++}
++
++static int indirect_bus_reg_read(void *context, unsigned int reg,
++				     unsigned int *val)
++{
++	struct indirect_ctx *ctx = context;
++	unsigned int cmd;
++	int ret;
++
++	cmd = readl(ctx->base + INDIRECT_CMD_OFF);
++
++	if (cmd)
++		dev_warn(ctx->dev, "%s non-zero cmd 0x%x\n", __func__, cmd);
++
++	writel(reg, ctx->base + INDIRECT_ADDR_OFF);
++
++	writel(INDIRECT_CMD_RD, ctx->base + INDIRECT_CMD_OFF);
++
++	ret = readl_poll_timeout((ctx->base + INDIRECT_CMD_OFF), cmd,
++				 (cmd & INDIRECT_CMD_ACK), INDIRECT_INT_US,
++				 INDIRECT_TIMEOUT_US);
++
++	*val = readl(ctx->base + INDIRECT_RD_OFF);
++
++	if (ret)
++		dev_err(ctx->dev, "%s timed out on reg 0x%x cmd 0x%x\n", __func__, reg, cmd);
++
++	if (indirect_bus_clr_cmd(ctx))
++		ret = -ETIME;
++
++	return ret;
++}
++
++static int indirect_bus_reg_write(void *context, unsigned int reg,
++				      unsigned int val)
++{
++	struct indirect_ctx *ctx = context;
++	unsigned int cmd;
++	int ret;
++
++	cmd = readl(ctx->base + INDIRECT_CMD_OFF);
++
++	if (cmd)
++		dev_warn(ctx->dev, "%s non-zero cmd 0x%x\n", __func__, cmd);
++
++	writel(val, ctx->base + INDIRECT_WR_OFF);
++
++	writel(reg, ctx->base + INDIRECT_ADDR_OFF);
++
++	writel(INDIRECT_CMD_WR, ctx->base + INDIRECT_CMD_OFF);
++
++	ret = readl_poll_timeout((ctx->base + INDIRECT_CMD_OFF), cmd,
++				 (cmd & INDIRECT_CMD_ACK), INDIRECT_INT_US,
++				 INDIRECT_TIMEOUT_US);
++
++	if (ret)
++		dev_err(ctx->dev, "%s timed out on reg 0x%x cmd 0x%x\n", __func__, reg, cmd);
++
++	if (indirect_bus_clr_cmd(ctx))
++		ret = -ETIME;
++
++	return ret;
++}
++
++static const struct regmap_bus indirect_bus = {
++	.fast_io = true,
++	.reg_write = indirect_bus_reg_write,
++	.reg_read =  indirect_bus_reg_read,
++};
++
++/**
++ * devm_regmap_init_indirect_register - create a regmap for indirect register access
++ * @dev: device creating the regmap
++ * @base: __iomem point to base of memory with mailbox
++ * @cfg: regmap_config describing interface
++ *
++ * Return: 0 on success, negative error code otherwise.
++ */
++struct regmap *devm_regmap_init_indirect_register(struct device *dev,
++						  void __iomem *base,
++						  struct regmap_config *cfg)
++{
++	struct indirect_ctx *ctx;
++
++	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
++
++	if (!ctx)
++		return NULL;
++
++	ctx->base = base;
++	ctx->dev = dev;
++
++	return devm_regmap_init(dev, &indirect_bus, ctx, cfg);
++}
++EXPORT_SYMBOL_GPL(devm_regmap_init_indirect_register);
++
++MODULE_DESCRIPTION("Indirect Register Access");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+diff --git a/include/linux/regmap.h b/include/linux/regmap.h
+index e7834d98207f..cbe4e72a099f 100644
+--- a/include/linux/regmap.h
++++ b/include/linux/regmap.h
+@@ -631,6 +631,18 @@ struct regmap *__devm_regmap_init_spi_avmm(struct spi_device *spi,
+ 					   const struct regmap_config *config,
+ 					   struct lock_class_key *lock_key,
+ 					   const char *lock_name);
++/**
++ * devm_regmap_init_indirect_register - create a regmap for indirect register access
++ * @dev: device creating the regmap
++ * @base: __iomem point to base of memory with mailbox
++ * @cfg: regmap_config describing interface
++ *
++ * Return: 0 on success, negative error code otherwise.
++ */
++struct regmap *devm_regmap_init_indirect_register(struct device *dev,
++						  void __iomem *base,
++						  struct regmap_config *cfg);
++
+ /*
+  * Wrapper for regmap_init macros to include a unique lockdep key and name
+  * for each call. No-op if CONFIG_LOCKDEP is not set.
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0049-net-ethernet-intel-add-s10hssi-driver.patch new/debian/patches/fpga-ofs/0049-net-ethernet-intel-add-s10hssi-driver.patch
--- org/debian/patches/fpga-ofs/0049-net-ethernet-intel-add-s10hssi-driver.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0049-net-ethernet-intel-add-s10hssi-driver.patch	2021-07-20 06:17:11.408844856 +0200
@@ -0,0 +1,582 @@
+From 0ceadd5546eafe7898d31b24fc5534f58229ebc8 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Mon, 20 Apr 2020 17:31:44 -0700
+Subject: [PATCH 049/149] net: ethernet: intel: add s10hssi driver
+
+Add stratix 10 high speed interface driver supporting both
+10G and 100G ethernet.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Based-on: Wu Hao <hao.wu@intel.com>
+Based-on: Xu Yilun <yilun.xu@intel.com>
+---
+ drivers/net/ethernet/intel/Kconfig   |  13 +
+ drivers/net/ethernet/intel/Makefile  |   2 +
+ drivers/net/ethernet/intel/s10hssi.c | 523 +++++++++++++++++++++++++++
+ 3 files changed, 538 insertions(+)
+ create mode 100644 drivers/net/ethernet/intel/s10hssi.c
+
+diff --git a/drivers/net/ethernet/intel/Kconfig b/drivers/net/ethernet/intel/Kconfig
+index 61b5d91bff74..d0e023a73485 100644
+--- a/drivers/net/ethernet/intel/Kconfig
++++ b/drivers/net/ethernet/intel/Kconfig
+@@ -373,4 +373,17 @@ config INTEL_M10_BMC_RETIMER
+ 	  To compile this driver as a module, choose M here. The module
+ 	  will be called intel-m10-bmc-retimer.
+ 
++config S10HSSI
++	tristate "Control Plane Driver for Stratix 10 HSSI"
++	select REGMAP_INDIRECT_REGISTER
++	help
++	  This driver provides control plane support for an Stratix 10
++	  High Speed Serial Interface.
++
++          The Stratix 10 High Speed Serial Interface provides a data
++          path between the FPGA and the external QSFP interfaces.  This
++          data path does not involve packets transferred between host
++          memory and the fpga.  As such a very limited set of networking
++          functionality is provided.
++
+ endif # NET_VENDOR_INTEL
+diff --git a/drivers/net/ethernet/intel/Makefile b/drivers/net/ethernet/intel/Makefile
+index be097656a79e..12c1d7a66d18 100644
+--- a/drivers/net/ethernet/intel/Makefile
++++ b/drivers/net/ethernet/intel/Makefile
+@@ -20,3 +20,5 @@ obj-$(CONFIG_ICE) += ice/
+ dfl-eth-group-objs := dfl-eth-group-main.o dfl-eth-group-10g.o dfl-eth-group-25g.o
+ obj-$(CONFIG_FPGA_DFL_ETH_GROUP) += dfl-eth-group.o
+ obj-$(CONFIG_INTEL_M10_BMC_RETIMER) += intel-m10-bmc-retimer.o
++obj-$(CONFIG_INTEL_M10_BMC_PKVL) += intel-m10-bmc-pkvl.o
++obj-$(CONFIG_S10HSSI) += s10hssi.o
+diff --git a/drivers/net/ethernet/intel/s10hssi.c b/drivers/net/ethernet/intel/s10hssi.c
+new file mode 100644
+index 000000000000..116988760486
+--- /dev/null
++++ b/drivers/net/ethernet/intel/s10hssi.c
+@@ -0,0 +1,523 @@
++// SPDX-License-Identifier: GPL-2.0
++
++/* Intel(R) Low Latency 10G Network Driver
++ *
++ * Copyright (C) 2020 Intel Corporation. All rights reserved.
++ */
++
++#include <linux/bitfield.h>
++#include <linux/dfl.h>
++#include <linux/etherdevice.h>
++#include <linux/ethtool.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/module.h>
++#include <linux/netdevice.h>
++#include <linux/regmap.h>
++#include <linux/uaccess.h>
++
++#define CAPABILITY_OFF		0x08
++#define CAP_AVAILABLE_RATES	GENMASK_ULL(7, 0)
++#define CAP_CONTAINS_PCS	GENMASK_ULL(15, 8)
++#define CAP_CONTAINS_FEC	GENMASK_ULL(23, 16)
++#define CAP_RATE_1G		BIT_ULL(0)
++#define CAP_RATE_10G		BIT_ULL(1)
++#define CAP_RATE_25G		BIT_ULL(2)
++#define CAP_RATE_40G		BIT_ULL(3)
++#define CAP_RATE_50G		BIT_ULL(4)
++#define CAP_RATE_100G		BIT_ULL(5)
++#define CAP_RATE_200G		BIT_ULL(6)
++#define CAP_RATE_400G		BIT_ULL(7)
++
++#define MB_BASE_OFF		0x28
++
++#define PHY_BASE_OFF		0x2000
++#define PHY_RX_SER_LOOP_BACK	0x4e1
++#define PHY_MAX_OFF		0x541
++
++#define ILL_10G_BASE_OFF	0
++#define ILL_10G_MAX_OFF		0x1d00
++#define ILL_10G_TX_STATS_CLR	0x1c00
++#define ILL_10G_RX_STATS_CLR	0x0c00
++
++#define ILL_100G_BASE_OFF	0x400
++#define ILL_100G_MAX_OFF	0x9ff
++#define ILL_100G_TX_STATS_CLR	0x845
++#define ILL_100G_RX_STATS_CLR	0x945
++
++#define ILL_100G_PHY_BASE_OFF	0x300
++#define ILL_100G_PHY_MAX_OFF	0x3ff
++#define ILL_100G_LPBK_OFF	0x313
++#define ILL_100G_LPBK_EN_VAL	0xffff
++
++#define STATS_CLR_INT_US		1
++#define STATS_CLR_INT_TIMEOUT_US	1000
++
++struct s10hssi_drvdata {
++	struct net_device *netdev;
++};
++
++struct s10hssi_ops_params {
++	struct stat_info *stats;
++	u32 num_stats;
++	u32 tx_clr_off;
++	u32 rx_clr_off;
++	u32 lpbk_off;
++	u32 lpbk_en_val;
++};
++
++struct s10hssi_netdata {
++	struct dfl_device *dfl_dev;
++	struct regmap *regmap;
++	const struct s10hssi_ops_params *ops_params;
++};
++
++static int netdev_change_mtu(struct net_device *netdev, int new_mtu)
++{
++	netdev->mtu = new_mtu;
++
++	return 0;
++}
++
++static int netdev_set_loopback(struct net_device *netdev, bool en)
++{
++	struct s10hssi_netdata *npriv = netdev_priv(netdev);
++	u32 val = 0;
++
++	if (en)
++		val = npriv->ops_params->lpbk_en_val;
++
++	return regmap_write(npriv->regmap, npriv->ops_params->lpbk_off, val);
++}
++
++static int netdev_set_features(struct net_device *netdev,
++			       netdev_features_t features)
++{
++	netdev_features_t changed = netdev->features ^ features;
++
++	if (changed & NETIF_F_LOOPBACK)
++		return netdev_set_loopback(netdev, !!(features & NETIF_F_LOOPBACK));
++
++	return 0;
++}
++
++static int netdev_set_mac_address(struct net_device *ndev, void *p)
++{
++	struct sockaddr *addr = p;
++
++	memcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);
++
++	/* TODO program hardware */
++
++	return 0;
++}
++
++static const struct net_device_ops netdev_ops = {
++	.ndo_change_mtu = netdev_change_mtu,
++	.ndo_set_features = netdev_set_features,
++	.ndo_set_mac_address = netdev_set_mac_address,
++};
++
++struct stat_info {
++	unsigned int addr;
++	char string[ETH_GSTRING_LEN];
++};
++
++#define STAT_INFO(_addr, _string) \
++	.addr = _addr, .string = _string,
++
++static struct stat_info stats_10g[] = {
++	/* TX Statistics */
++	{STAT_INFO(0x1c02, "tx_frame_ok")},
++	{STAT_INFO(0x1c04, "tx_frame_err")},
++	{STAT_INFO(0x1c06, "tx_frame_crc_err")},
++	{STAT_INFO(0x1c08, "tx_octets_ok")},
++	{STAT_INFO(0x1c0a, "tx_pause_mac_ctrl_frames")},
++	{STAT_INFO(0x1c0c, "tx_if_err")},
++	{STAT_INFO(0x1c0e, "tx_unicast_frame_ok")},
++	{STAT_INFO(0x1c10, "tx_unicast_frame_err")},
++	{STAT_INFO(0x1c12, "tx_multicast_frame_ok")},
++	{STAT_INFO(0x1c14, "tx_multicast_frame_err")},
++	{STAT_INFO(0x1c16, "tx_broadcast_frame_ok")},
++	{STAT_INFO(0x1c18, "tx_broadcast_frame_err")},
++	{STAT_INFO(0x1c1a, "tx_ether_octets")},
++	{STAT_INFO(0x1c1c, "tx_ether_pkts")},
++	{STAT_INFO(0x1c1e, "tx_ether_undersize_pkts")},
++	{STAT_INFO(0x1c20, "tx_ether_oversize_pkts")},
++	{STAT_INFO(0x1c22, "tx_ether_pkts_64_octets")},
++	{STAT_INFO(0x1c24, "tx_ether_pkts_65_127_octets")},
++	{STAT_INFO(0x1c26, "tx_ether_pkts_128_255_octets")},
++	{STAT_INFO(0x1c28, "tx_ether_pkts_256_511_octets")},
++	{STAT_INFO(0x1c2a, "tx_ether_pkts_512_1023_octets")},
++	{STAT_INFO(0x1c2c, "tx_ether_pkts_1024_1518_octets")},
++	{STAT_INFO(0x1c2e, "tx_ether_pkts_1519_x_octets")},
++	{STAT_INFO(0x1c30, "tx_ether_fragments")},
++	{STAT_INFO(0x1c32, "tx_ether_jabbers")},
++	{STAT_INFO(0x1c34, "tx_ether_crc_err")},
++	{STAT_INFO(0x1c36, "tx_unicast_mac_ctrl_frames")},
++	{STAT_INFO(0x1c38, "tx_multicast_mac_ctrl_frames")},
++	{STAT_INFO(0x1c3a, "tx_broadcast_mac_ctrl_frames")},
++	{STAT_INFO(0x1c3c, "tx_pfc_mac_ctrl_frames")},
++
++	/* RX Statistics */
++	{STAT_INFO(0x0c02, "rx_frame_ok")},
++	{STAT_INFO(0x0c04, "rx_frame_err")},
++	{STAT_INFO(0x0c06, "rx_frame_crc_err")},
++	{STAT_INFO(0x0c08, "rx_octets_ok")},
++	{STAT_INFO(0x0c0a, "rx_pause_mac_ctrl_frames")},
++	{STAT_INFO(0x0c0c, "rx_if_err")},
++	{STAT_INFO(0x0c0e, "rx_unicast_frame_ok")},
++	{STAT_INFO(0x0c10, "rx_unicast_frame_err")},
++	{STAT_INFO(0x0c12, "rx_multicast_frame_ok")},
++	{STAT_INFO(0x0c14, "rx_multicast_frame_err")},
++	{STAT_INFO(0x0c16, "rx_broadcast_frame_ok")},
++	{STAT_INFO(0x0c18, "rx_broadcast_frame_err")},
++	{STAT_INFO(0x0c1a, "rx_ether_octets")},
++	{STAT_INFO(0x0c1c, "rx_ether_pkts")},
++	{STAT_INFO(0x0c1e, "rx_ether_undersize_pkts")},
++	{STAT_INFO(0x0c20, "rx_ether_oversize_pkts")},
++	{STAT_INFO(0x0c22, "rx_ether_pkts_64_octets")},
++	{STAT_INFO(0x0c24, "rx_ether_pkts_65_127_octets")},
++	{STAT_INFO(0x0c26, "rx_ether_pkts_128_255_octets")},
++	{STAT_INFO(0x0c28, "rx_ether_pkts_256_511_octets")},
++	{STAT_INFO(0x0c2a, "rx_ether_pkts_512_1023_octets")},
++	{STAT_INFO(0x0c2c, "rx_ether_pkts_1024_1518_octets")},
++	{STAT_INFO(0x0c2e, "rx_ether_pkts_1519_x_octets")},
++	{STAT_INFO(0x0c30, "rx_ether_fragments")},
++	{STAT_INFO(0x0c32, "rx_ether_jabbers")},
++	{STAT_INFO(0x0c34, "rx_ether_crc_err")},
++	{STAT_INFO(0x0c36, "rx_unicast_mac_ctrl_frames")},
++	{STAT_INFO(0x0c38, "rx_multicast_mac_ctrl_frames")},
++	{STAT_INFO(0x0c3a, "rx_broadcast_mac_ctrl_frames")},
++	{STAT_INFO(0x0c3c, "rx_pfc_mac_ctrl_frames")},
++};
++
++static void ethtool_get_strings(struct net_device *netdev, u32 stringset,
++				u8 *s)
++{
++	struct s10hssi_netdata *npriv = netdev_priv(netdev);
++	unsigned int i, stats_num = 0;
++	struct stat_info *stat;
++
++	switch (stringset) {
++	case ETH_SS_STATS:
++		stat = npriv->ops_params->stats;
++		stats_num = npriv->ops_params->num_stats;
++		break;
++	default:
++		return;
++	}
++
++	for (i = 0; i < stats_num; i++, s += ETH_GSTRING_LEN)
++		memcpy(s, stat[i].string, ETH_GSTRING_LEN);
++}
++
++static int ethtool_get_sset_count(struct net_device *netdev, int stringset)
++{
++	struct s10hssi_netdata *npriv = netdev_priv(netdev);
++
++	switch (stringset) {
++	case ETH_SS_STATS:
++		return npriv->ops_params->num_stats;
++
++	default:
++		return 0;
++	}
++}
++
++static u64 read_mac_stat(struct regmap *regmap, unsigned int addr)
++{
++	u32 data_l, data_h;
++
++	regmap_read(regmap, addr, &data_l);
++	regmap_read(regmap, addr + 1, &data_h);
++
++	return data_l + ((u64)data_h << 32);
++}
++
++static int ethtool_reset(struct net_device *netdev, u32 *flags)
++{
++	struct s10hssi_netdata *npriv = netdev_priv(netdev);
++	int ret;
++	u32 val;
++
++	if (*flags | ETH_RESET_MGMT) {
++		regmap_write(npriv->regmap, npriv->ops_params->tx_clr_off, 1);
++
++		ret = regmap_read_poll_timeout(npriv->regmap,  npriv->ops_params->tx_clr_off,
++					       val, (!val), STATS_CLR_INT_US,
++					       STATS_CLR_INT_TIMEOUT_US);
++
++		if (ret) {
++			dev_err(&netdev->dev, "%s failed to clear tx stats\n", __func__);
++			return ret;
++		}
++
++		regmap_write(npriv->regmap, npriv->ops_params->rx_clr_off, 1);
++
++		ret = regmap_read_poll_timeout(npriv->regmap,  npriv->ops_params->rx_clr_off,
++					       val, (!val), STATS_CLR_INT_US,
++					       STATS_CLR_INT_TIMEOUT_US);
++
++		if (ret) {
++			dev_err(&netdev->dev, "%s failed to clear rx stats\n", __func__);
++			return ret;
++		}
++		dev_info(&netdev->dev, "%s reset statistics registers\n", __func__);
++	}
++
++	return 0;
++}
++
++static void ethtool_get_stats(struct net_device *netdev,
++			      struct ethtool_stats *stats, u64 *data)
++{
++	struct s10hssi_netdata *npriv = netdev_priv(netdev);
++	unsigned int i, stats_num = npriv->ops_params->num_stats;
++	struct stat_info *stat = npriv->ops_params->stats;
++	u32 flags = ETH_RESET_MGMT;
++
++	for (i = 0; i < stats_num; i++)
++		data[i] = read_mac_stat(npriv->regmap, stat[i].addr);
++
++	ethtool_reset(netdev, &flags);
++}
++
++static const struct ethtool_ops ethtool_ops = {
++	.get_strings = ethtool_get_strings,
++	.get_sset_count = ethtool_get_sset_count,
++	.get_ethtool_stats = ethtool_get_stats,
++	.reset = ethtool_reset,
++};
++
++static const struct s10hssi_ops_params s10hssi_params = {
++	.stats = stats_10g,
++	.num_stats = ARRAY_SIZE(stats_10g),
++	.tx_clr_off = ILL_10G_TX_STATS_CLR,
++	.rx_clr_off = ILL_10G_RX_STATS_CLR,
++	.lpbk_off = PHY_BASE_OFF + PHY_RX_SER_LOOP_BACK,
++	.lpbk_en_val = 1,
++};
++
++static const struct regmap_range regmap_range_10g[] = {
++	regmap_reg_range(ILL_10G_BASE_OFF, ILL_10G_MAX_OFF),
++	regmap_reg_range(PHY_BASE_OFF, PHY_BASE_OFF + PHY_MAX_OFF),
++};
++
++static const struct regmap_access_table access_table_10g = {
++	.yes_ranges	= regmap_range_10g,
++	.n_yes_ranges	= ARRAY_SIZE(regmap_range_10g),
++};
++
++static struct stat_info stats_100g[] = {
++	/* tx statistics */
++	{STAT_INFO(0x800, "tx_fragments")},
++	{STAT_INFO(0x802, "tx_jabbers")},
++	{STAT_INFO(0x804, "tx_crcerr")},
++	{STAT_INFO(0x806, "tx_crcerr_sizeok")},
++	{STAT_INFO(0x808, "tx_mcast_data_err")},
++	{STAT_INFO(0x80a, "tx_bcast_data_err")},
++	{STAT_INFO(0x80c, "tx_ucast_data_err")},
++	{STAT_INFO(0x80e, "tx_mcast_ctrl_err")},
++	{STAT_INFO(0x810, "tx_bcast_ctrl_err")},
++	{STAT_INFO(0x812, "tx_ucast_ctrl_err")},
++	{STAT_INFO(0x814, "tx_pause_err")},
++	{STAT_INFO(0x816, "tx_64b")},
++	{STAT_INFO(0x818, "tx_65to127b")},
++	{STAT_INFO(0x81a, "tx_128to255b")},
++	{STAT_INFO(0x81c, "tx_256to511b")},
++	{STAT_INFO(0x81e, "tx_512to1023b")},
++	{STAT_INFO(0x820, "tx_1024to1518b")},
++	{STAT_INFO(0x822, "tx_1519tomaxb")},
++	{STAT_INFO(0x824, "tx_oversize")},
++	{STAT_INFO(0x836, "tx_st")},
++	{STAT_INFO(0x826, "tx_mcast_data_ok")},
++	{STAT_INFO(0x828, "tx_bcast_data_ok")},
++	{STAT_INFO(0x82a, "tx_ucast_data_ok")},
++	{STAT_INFO(0x82c, "tx_mcast_ctrl_ok")},
++	{STAT_INFO(0x82e, "tx_bcast_ctrl_ok")},
++	{STAT_INFO(0x830, "tx_ucast_ctrl_ok")},
++	{STAT_INFO(0x832, "tx_pause")},
++	{STAT_INFO(0x860, "tx_payload_octets_ok")},
++	{STAT_INFO(0x862, "tx_frame_octets_ok")},
++
++	/* rx statistics */
++	{STAT_INFO(0x900, "rx_fragments")},
++	{STAT_INFO(0x902, "rx_jabbers")},
++	{STAT_INFO(0x904, "rx_crcerr")},
++	{STAT_INFO(0x906, "rx_crcerr_sizeok")},
++	{STAT_INFO(0x908, "rx_mcast_data_err")},
++	{STAT_INFO(0x90a, "rx_bcast_data_err")},
++	{STAT_INFO(0x90c, "rx_ucast_data_err")},
++	{STAT_INFO(0x90e, "rx_mcast_ctrl_err")},
++	{STAT_INFO(0x910, "rx_bcast_ctrl_err")},
++	{STAT_INFO(0x912, "rx_ucast_ctrl_err")},
++	{STAT_INFO(0x914, "rx_pause_err")},
++	{STAT_INFO(0x916, "rx_64b")},
++	{STAT_INFO(0x918, "rx_65to127b")},
++	{STAT_INFO(0x91a, "rx_128to255b")},
++	{STAT_INFO(0x91c, "rx_256to511b")},
++	{STAT_INFO(0x91e, "rx_512to1023b")},
++	{STAT_INFO(0x920, "rx_1024to1518b")},
++	{STAT_INFO(0x922, "rx_1519tomaxb")},
++	{STAT_INFO(0x924, "rx_oversize")},
++	{STAT_INFO(0x936, "rx_st")},
++	{STAT_INFO(0x926, "rx_mcast_data_ok")},
++	{STAT_INFO(0x928, "rx_bcast_data_ok")},
++	{STAT_INFO(0x92a, "rx_ucast_data_ok")},
++	{STAT_INFO(0x92c, "rx_mcast_ctrl_ok")},
++	{STAT_INFO(0x92e, "rx_bcast_ctrl_ok")},
++	{STAT_INFO(0x930, "rx_ucast_ctrl_ok")},
++	{STAT_INFO(0x932, "rx_pause")},
++	{STAT_INFO(0x960, "rx_payload_octets_ok")},
++	{STAT_INFO(0x962, "rx_frame_octets_ok")}
++};
++
++static const struct s10hssi_ops_params intel_ll_100g_params = {
++	.stats = stats_100g,
++	.num_stats = ARRAY_SIZE(stats_100g),
++	.tx_clr_off = ILL_100G_TX_STATS_CLR,
++	.rx_clr_off = ILL_100G_RX_STATS_CLR,
++	.lpbk_off = ILL_100G_LPBK_OFF,
++	.lpbk_en_val = ILL_100G_LPBK_EN_VAL,
++};
++
++static const struct regmap_range regmap_range_100g[] = {
++	regmap_reg_range(ILL_100G_PHY_BASE_OFF, ILL_100G_PHY_MAX_OFF),
++	regmap_reg_range(ILL_100G_BASE_OFF, ILL_100G_MAX_OFF),
++};
++
++static const struct regmap_access_table access_table_100g = {
++	.yes_ranges	= regmap_range_100g,
++	.n_yes_ranges	= ARRAY_SIZE(regmap_range_100g),
++};
++
++static void s10hssi_init_netdev(struct net_device *netdev)
++{
++	netdev->ethtool_ops = &ethtool_ops;
++	netdev->netdev_ops = &netdev_ops;
++	netdev->features = 0;
++	netdev->hw_features |= NETIF_F_LOOPBACK;
++	netdev->hard_header_len = 0;
++	netdev->priv_flags |= IFF_NO_QUEUE;
++
++	netdev->needs_free_netdev  = true;
++
++	ether_setup(netdev);
++}
++
++static int s10hssi_mac_probe(struct dfl_device *dfl_dev)
++{
++	struct device *dev = &dfl_dev->dev;
++	struct regmap_config cfg = {0};
++	struct s10hssi_netdata *npriv;
++	struct s10hssi_drvdata *priv;
++	struct regmap *regmap;
++	void __iomem *base;
++	u64 val, pcs_speed;
++	u32 flags;
++	int ret;
++
++	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
++
++	if (!priv)
++		return -ENOMEM;
++
++	dev_set_drvdata(dev, priv);
++
++	base = devm_ioremap_resource(dev, &dfl_dev->mmio_res);
++
++	if (!base)
++		return -ENOMEM;
++
++	priv->netdev = alloc_netdev(sizeof(struct s10hssi_netdata),
++				    "s10hssi%d", NET_NAME_UNKNOWN,
++				    s10hssi_init_netdev);
++
++	if (!priv->netdev)
++		return -ENOMEM;
++
++	npriv = netdev_priv(priv->netdev);
++
++	npriv->dfl_dev = dfl_dev;
++
++	val = readq(base + CAPABILITY_OFF);
++
++	dev_info(dev, "%s capability register 0x%llx\n", __func__, val);
++
++	pcs_speed = FIELD_GET(CAP_CONTAINS_PCS, val);
++
++	if (pcs_speed == CAP_RATE_10G) {
++		dev_info(dev, "%s found 10G\n", __func__);
++		npriv->ops_params = &s10hssi_params;
++		cfg.wr_table = &access_table_10g;
++		cfg.rd_table = &access_table_10g;
++		cfg.max_register = PHY_BASE_OFF + PHY_MAX_OFF;
++	} else if (pcs_speed == CAP_RATE_100G) {
++		dev_info(dev, "%s found 100G\n", __func__);
++		npriv->ops_params = &intel_ll_100g_params;
++		cfg.wr_table = &access_table_100g;
++		cfg.rd_table = &access_table_100g;
++		cfg.max_register = ILL_100G_MAX_OFF;
++	} else {
++		dev_err(dev, "%s unsupported pcs data rate 0x%llx\n",
++			__func__, pcs_speed);
++		return -EINVAL;
++	}
++
++	cfg.reg_bits = 32;
++	cfg.val_bits = 32;
++
++	regmap = devm_regmap_init_indirect_register(dev, base + MB_BASE_OFF, &cfg);
++
++	if (!regmap)
++		return -ENOMEM;
++
++	npriv->regmap = regmap;
++
++	SET_NETDEV_DEV(priv->netdev, &dfl_dev->dev);
++
++	flags = ETH_RESET_MGMT;
++
++	ret = ethtool_reset(priv->netdev, &flags);
++
++	if (ret)
++		dev_err(&dfl_dev->dev, "failed to reset MGMT %s: %d",
++			priv->netdev->name, ret);
++
++	ret = register_netdev(priv->netdev);
++
++	if (ret)
++		dev_err(&dfl_dev->dev, "failed to register %s: %d",
++			priv->netdev->name, ret);
++
++	return ret;
++}
++
++static void s10hssi_mac_remove(struct dfl_device *dfl_dev)
++{
++	struct s10hssi_drvdata *priv = dev_get_drvdata(&dfl_dev->dev);
++
++	unregister_netdev(priv->netdev);
++}
++
++#define FME_FEATURE_ID_LL_10G_MAC 0xf
++
++static const struct dfl_device_id s10hssi_mac_ids[] = {
++	{ FME_ID, FME_FEATURE_ID_LL_10G_MAC },
++	{ }
++};
++
++static struct dfl_driver s10hssi_mac_driver = {
++	.drv = {
++		.name = "s10hssi",
++	},
++	.id_table = s10hssi_mac_ids,
++	.probe = s10hssi_mac_probe,
++	.remove = s10hssi_mac_remove,
++};
++
++module_dfl_driver(s10hssi_mac_driver);
++MODULE_DEVICE_TABLE(dfl, s10hssi_mac_ids);
++MODULE_DESCRIPTION("Network Device Driver for Intel(R) Startix10 HSSI");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0050-drivers-fpga-dfl-spi-altera-enable-regmap-debugfs.patch new/debian/patches/fpga-ofs/0050-drivers-fpga-dfl-spi-altera-enable-regmap-debugfs.patch
--- org/debian/patches/fpga-ofs/0050-drivers-fpga-dfl-spi-altera-enable-regmap-debugfs.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0050-drivers-fpga-dfl-spi-altera-enable-regmap-debugfs.patch	2021-07-20 06:17:11.408844856 +0200
@@ -0,0 +1,29 @@
+From 287dcf7e3b41f9ffc22709b66601d6b5e149b016 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Wed, 21 Oct 2020 12:49:19 -0400
+Subject: [PATCH 050/149] drivers: fpga: dfl-spi-altera: enable regmap debugfs
+
+Enable debugfs access to regmap used to interacte with Altera
+SPI Master component by adding an appropriate value to the
+max_register field in the regmap_config.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ drivers/fpga/dfl-spi-altera.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/drivers/fpga/dfl-spi-altera.c b/drivers/fpga/dfl-spi-altera.c
+index b21c344d596f..21223d7437a2 100644
+--- a/drivers/fpga/dfl-spi-altera.c
++++ b/drivers/fpga/dfl-spi-altera.c
+@@ -104,6 +104,7 @@ static const struct regmap_config indirect_regbus_cfg = {
+ 	.reg_stride = 4,
+ 	.val_bits = 32,
+ 	.fast_io = true,
++	.max_register = 24,
+ 
+ 	.reg_write = indirect_bus_reg_write,
+ 	.reg_read = indirect_bus_reg_read,
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0051-drivers-mfd-intel-m10-bmc-add-debugfs-support-to-reg.patch new/debian/patches/fpga-ofs/0051-drivers-mfd-intel-m10-bmc-add-debugfs-support-to-reg.patch
--- org/debian/patches/fpga-ofs/0051-drivers-mfd-intel-m10-bmc-add-debugfs-support-to-reg.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0051-drivers-mfd-intel-m10-bmc-add-debugfs-support-to-reg.patch	2021-07-20 06:17:11.408844856 +0200
@@ -0,0 +1,60 @@
+From 75d4ed4872c33efd1efea7f6b484bb8a7d5c20c8 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Tue, 20 Oct 2020 14:19:50 -0400
+Subject: [PATCH 051/149] drivers: mfd: intel-m10-bmc add debugfs support to
+ regmap
+
+Add access tables and a max_registers field to enable
+the regmap-debugfs interface.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ drivers/mfd/intel-m10-bmc.c       | 12 ++++++++++++
+ include/linux/mfd/intel-m10-bmc.h |  2 ++
+ 2 files changed, 14 insertions(+)
+
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index 25539109c9e5..c8201a5a1e84 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -124,10 +124,22 @@ int m10bmc_sys_update_bits(struct intel_m10bmc *m10bmc, unsigned int offset,
+ }
+ EXPORT_SYMBOL_GPL(m10bmc_sys_update_bits);
+ 
++static const struct regmap_range m10_regmap_range[] = {
++	regmap_reg_range(M10BMC_LEGACY_SYS_BASE, M10BMC_SYS_END),
++	regmap_reg_range(M10BMC_FLASH_BASE, M10BMC_MEM_END),
++};
++
++static const struct regmap_access_table m10_access_table = {
++	.yes_ranges	= m10_regmap_range,
++	.n_yes_ranges	= ARRAY_SIZE(m10_regmap_range),
++};
++
+ static struct regmap_config intel_m10bmc_regmap_config = {
+ 	.reg_bits = 32,
+ 	.val_bits = 32,
+ 	.reg_stride = 4,
++	.wr_table = &m10_access_table,
++	.rd_table = &m10_access_table,
+ 	.max_register = M10BMC_MEM_END,
+ };
+ 
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 1eeeb523422b..3af503c24aba 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -18,8 +18,10 @@ enum m10bmc_type {
+ 
+ #define M10BMC_LEGACY_SYS_BASE		0x300400
+ #define M10BMC_SYS_BASE			0x300800
++#define M10BMC_SYS_END			0x300fff
+ #define M10BMC_MEM_END			0x200000fc
+ 
++#define M10BMC_FLASH_BASE		0x10000000
+ #define M10BMC_STAGING_BASE		0x18000000
+ #define M10BMC_STAGING_SIZE		0x3800000
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0052-fpga-dfl-export-fme-and-port-error-DFH-revision-to-s.patch new/debian/patches/fpga-ofs/0052-fpga-dfl-export-fme-and-port-error-DFH-revision-to-s.patch
--- org/debian/patches/fpga-ofs/0052-fpga-dfl-export-fme-and-port-error-DFH-revision-to-s.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0052-fpga-dfl-export-fme-and-port-error-DFH-revision-to-s.patch	2021-07-20 06:17:11.408844856 +0200
@@ -0,0 +1,81 @@
+From 4bac984008b97fbd6b6bd3a5a7115c93268826f7 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Thu, 22 Oct 2020 14:25:27 -0400
+Subject: [PATCH 052/149] fpga: dfl: export fme and port error DFH revision to
+ sysfs
+
+With Intel OFS, the definition of the port error bits have
+changed to reflect the transition from CCI-P to AXI-S TLP.
+Export the DFH revision to sysfs so that user space can
+properly decode the port errors.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ drivers/fpga/dfl-afu-error.c | 14 ++++++++++++++
+ drivers/fpga/dfl-fme-error.c | 14 ++++++++++++++
+ 2 files changed, 28 insertions(+)
+
+diff --git a/drivers/fpga/dfl-afu-error.c b/drivers/fpga/dfl-afu-error.c
+index 0806532a3e9f..230b1085f55a 100644
+--- a/drivers/fpga/dfl-afu-error.c
++++ b/drivers/fpga/dfl-afu-error.c
+@@ -178,10 +178,24 @@ static ssize_t first_malformed_req_show(struct device *dev,
+ }
+ static DEVICE_ATTR_RO(first_malformed_req);
+ 
++static ssize_t revision_show(struct device *dev, struct device_attribute *attr, char *buf)
++{
++	void __iomem *base;
++	u64 dfh;
++
++	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);
++
++	dfh = readq(base);
++
++	return sprintf(buf, "%lld\n", FIELD_GET(DFH_REVISION, dfh));
++}
++static DEVICE_ATTR_RO(revision);
++
+ static struct attribute *port_err_attrs[] = {
+ 	&dev_attr_errors.attr,
+ 	&dev_attr_first_error.attr,
+ 	&dev_attr_first_malformed_req.attr,
++	&dev_attr_revision.attr,
+ 	NULL,
+ };
+ 
+diff --git a/drivers/fpga/dfl-fme-error.c b/drivers/fpga/dfl-fme-error.c
+index 51c2892ec06d..52d03d38b4ad 100644
+--- a/drivers/fpga/dfl-fme-error.c
++++ b/drivers/fpga/dfl-fme-error.c
+@@ -279,6 +279,19 @@ static ssize_t next_error_show(struct device *dev,
+ }
+ static DEVICE_ATTR_RO(next_error);
+ 
++static ssize_t revision_show(struct device *dev, struct device_attribute *attr, char *buf)
++{
++	void __iomem *base;
++	u64 dfh;
++
++	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++
++	dfh = readq(base);
++
++	return sprintf(buf, "%lld\n", FIELD_GET(DFH_REVISION, dfh));
++}
++static DEVICE_ATTR_RO(revision);
++
+ static struct attribute *fme_global_err_attrs[] = {
+ 	&dev_attr_pcie0_errors.attr,
+ 	&dev_attr_pcie1_errors.attr,
+@@ -288,6 +301,7 @@ static struct attribute *fme_global_err_attrs[] = {
+ 	&dev_attr_fme_errors.attr,
+ 	&dev_attr_first_error.attr,
+ 	&dev_attr_next_error.attr,
++	&dev_attr_revision.attr,
+ 	NULL,
+ };
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0053-DEBUG-WARNING-enable-debugfs-writing-of-regmap-regis.patch new/debian/patches/fpga-ofs/0053-DEBUG-WARNING-enable-debugfs-writing-of-regmap-regis.patch
--- org/debian/patches/fpga-ofs/0053-DEBUG-WARNING-enable-debugfs-writing-of-regmap-regis.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0053-DEBUG-WARNING-enable-debugfs-writing-of-regmap-regis.patch	2021-07-20 06:17:11.412844844 +0200
@@ -0,0 +1,33 @@
+From 50731b580d322342b4508d7d9792cb0ac883d268 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Tue, 20 Oct 2020 13:59:26 -0400
+Subject: [PATCH 053/149] DEBUG WARNING enable debugfs writing of regmap
+ registers
+
+Enable writing via debugfs to regmap registers by defining the necessary
+macro.
+
+This change is potentially dangerous and is intended for development
+only and not recommended for production deployment.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ drivers/base/regmap/regmap-debugfs.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
+index 8dfac7f3ed7a..8a45caabe797 100644
+--- a/drivers/base/regmap/regmap-debugfs.c
++++ b/drivers/base/regmap/regmap-debugfs.c
+@@ -290,7 +290,7 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
+ 				   count, ppos);
+ }
+ 
+-#undef REGMAP_ALLOW_WRITE_DEBUGFS
++#define REGMAP_ALLOW_WRITE_DEBUGFS
+ #ifdef REGMAP_ALLOW_WRITE_DEBUGFS
+ /*
+  * This can be dangerous especially when we have clients such as
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0054-net-ethernet-intel-add-polling-of-link-status.patch new/debian/patches/fpga-ofs/0054-net-ethernet-intel-add-polling-of-link-status.patch
--- org/debian/patches/fpga-ofs/0054-net-ethernet-intel-add-polling-of-link-status.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0054-net-ethernet-intel-add-polling-of-link-status.patch	2021-07-20 06:17:11.412844844 +0200
@@ -0,0 +1,180 @@
+From a36578b9a179fc1406f9963595b40cb3fa5301b9 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Thu, 17 Dec 2020 12:14:00 -0800
+Subject: [PATCH 054/149] net: ethernet: intel: add polling of link status
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add polling for the link statatus in the phy and update
+the netdev object accordingly.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Based-on: Martin Hundebøll <mhu@silicom.dk>
+---
+ drivers/net/ethernet/intel/s10hssi.c | 85 ++++++++++++++++++++++++++--
+ 1 file changed, 80 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/net/ethernet/intel/s10hssi.c b/drivers/net/ethernet/intel/s10hssi.c
+index 116988760486..c6dc551c637d 100644
+--- a/drivers/net/ethernet/intel/s10hssi.c
++++ b/drivers/net/ethernet/intel/s10hssi.c
+@@ -31,6 +31,9 @@
+ #define MB_BASE_OFF		0x28
+ 
+ #define PHY_BASE_OFF		0x2000
++#define PHY_RX_LOCKED_OFF	0x480
++#define PHY_RX_LOCKED_DATA	(BIT(0) | BIT(1))
++
+ #define PHY_RX_SER_LOOP_BACK	0x4e1
+ #define PHY_MAX_OFF		0x541
+ 
+@@ -45,15 +48,29 @@
+ #define ILL_100G_RX_STATS_CLR	0x945
+ 
+ #define ILL_100G_PHY_BASE_OFF	0x300
+-#define ILL_100G_PHY_MAX_OFF	0x3ff
++#define ILL_100G_RX_PCS_ALN_OFF	0x326
++#define ILL_100G_RX_RCS_ALIGNED BIT(0)
++
+ #define ILL_100G_LPBK_OFF	0x313
+ #define ILL_100G_LPBK_EN_VAL	0xffff
+ 
++#define ILL_100G_PHY_MAX_OFF	0x3ff
++
++#define ILL_100G_TX_FEC_OFF	0xc00
++#define ILL_100G_TX_FEC_MAX_OFF	0xc07
++
++#define ILL_100G_RX_FEC_OFF	0xd00
++#define ILL_100G_RX_FEC_ST	0xd06
++#define ILL_100G_RX_FEC_ST_ALN	BIT(4)
++#define ILL_100G_RX_FEC_MAX_OFF	0xd08
++
+ #define STATS_CLR_INT_US		1
+ #define STATS_CLR_INT_TIMEOUT_US	1000
+ 
+ struct s10hssi_drvdata {
+ 	struct net_device *netdev;
++	struct timer_list poll_timer;
++	struct work_struct poll_workq;
+ };
+ 
+ struct s10hssi_ops_params {
+@@ -63,14 +80,47 @@ struct s10hssi_ops_params {
+ 	u32 rx_clr_off;
+ 	u32 lpbk_off;
+ 	u32 lpbk_en_val;
++	u32 link_off;
++	u32 link_mask;
+ };
+ 
+ struct s10hssi_netdata {
+ 	struct dfl_device *dfl_dev;
+ 	struct regmap *regmap;
+-	const struct s10hssi_ops_params *ops_params;
++	struct s10hssi_ops_params *ops_params;
++	u32 link_status;
+ };
+ 
++static void poll_work(struct work_struct *arg)
++{
++	struct s10hssi_netdata *npriv;
++	struct s10hssi_drvdata *priv;
++	u32 link_status = 0;
++
++	priv = container_of(arg, struct s10hssi_drvdata, poll_workq);
++	npriv = netdev_priv(priv->netdev);
++
++	regmap_read(npriv->regmap, npriv->ops_params->link_off, &link_status);
++	link_status &= npriv->ops_params->link_mask;
++	if (link_status != npriv->link_status) {
++		npriv->link_status = link_status;
++		dev_dbg(&priv->netdev->dev, "link state: %u\n", link_status);
++
++		if (link_status == npriv->ops_params->link_mask)
++			netif_carrier_on(priv->netdev);
++		else
++			netif_carrier_off(priv->netdev);
++	}
++}
++
++static void poll_timerf(struct timer_list *timer_arg)
++{
++	struct s10hssi_drvdata *priv = from_timer(priv, timer_arg, poll_timer);
++
++	schedule_work(&priv->poll_workq);
++	mod_timer(&priv->poll_timer, jiffies + msecs_to_jiffies(1000));
++}
++
+ static int netdev_change_mtu(struct net_device *netdev, int new_mtu)
+ {
+ 	netdev->mtu = new_mtu;
+@@ -296,6 +346,8 @@ static const struct s10hssi_ops_params s10hssi_params = {
+ 	.rx_clr_off = ILL_10G_RX_STATS_CLR,
+ 	.lpbk_off = PHY_BASE_OFF + PHY_RX_SER_LOOP_BACK,
+ 	.lpbk_en_val = 1,
++	.link_off = PHY_BASE_OFF + PHY_RX_LOCKED_OFF,
++	.link_mask = PHY_RX_LOCKED_DATA,
+ };
+ 
+ static const struct regmap_range regmap_range_10g[] = {
+@@ -384,6 +436,8 @@ static const struct s10hssi_ops_params intel_ll_100g_params = {
+ static const struct regmap_range regmap_range_100g[] = {
+ 	regmap_reg_range(ILL_100G_PHY_BASE_OFF, ILL_100G_PHY_MAX_OFF),
+ 	regmap_reg_range(ILL_100G_BASE_OFF, ILL_100G_MAX_OFF),
++	regmap_reg_range(ILL_100G_TX_FEC_OFF, ILL_100G_TX_FEC_MAX_OFF),
++	regmap_reg_range(ILL_100G_RX_FEC_OFF, ILL_100G_RX_FEC_MAX_OFF),
+ };
+ 
+ static const struct regmap_access_table access_table_100g = {
+@@ -448,16 +502,30 @@ static int s10hssi_mac_probe(struct dfl_device *dfl_dev)
+ 
+ 	if (pcs_speed == CAP_RATE_10G) {
+ 		dev_info(dev, "%s found 10G\n", __func__);
+-		npriv->ops_params = &s10hssi_params;
++		npriv->ops_params = (struct s10hssi_ops_params *)&s10hssi_params;
+ 		cfg.wr_table = &access_table_10g;
+ 		cfg.rd_table = &access_table_10g;
+ 		cfg.max_register = PHY_BASE_OFF + PHY_MAX_OFF;
+ 	} else if (pcs_speed == CAP_RATE_100G) {
+ 		dev_info(dev, "%s found 100G\n", __func__);
+-		npriv->ops_params = &intel_ll_100g_params;
++		npriv->ops_params = devm_kmalloc(dev, sizeof(*npriv->ops_params), GFP_KERNEL);
++		if (!npriv->ops_params)
++			return -ENOMEM;
++
++		*npriv->ops_params = intel_ll_100g_params;
++		if (FIELD_GET(CAP_CONTAINS_FEC, val)) {
++			dev_info(dev, "%s contains FEC\n", __func__);
++			npriv->ops_params->link_off = ILL_100G_RX_FEC_ST;
++			npriv->ops_params->link_mask = ILL_100G_RX_FEC_ST_ALN;
++		} else {
++			dev_info(dev, "%s no FEC\n", __func__);
++			npriv->ops_params->link_off = ILL_100G_RX_PCS_ALN_OFF;
++			npriv->ops_params->link_mask = ILL_100G_RX_RCS_ALIGNED;
++		}
++
+ 		cfg.wr_table = &access_table_100g;
+ 		cfg.rd_table = &access_table_100g;
+-		cfg.max_register = ILL_100G_MAX_OFF;
++		cfg.max_register = ILL_100G_RX_FEC_MAX_OFF;
+ 	} else {
+ 		dev_err(dev, "%s unsupported pcs data rate 0x%llx\n",
+ 			__func__, pcs_speed);
+@@ -490,6 +558,13 @@ static int s10hssi_mac_probe(struct dfl_device *dfl_dev)
+ 		dev_err(&dfl_dev->dev, "failed to register %s: %d",
+ 			priv->netdev->name, ret);
+ 
++	dev_info(&dfl_dev->dev, "setting carrier off\n");
++	netif_carrier_off(priv->netdev);
++
++	INIT_WORK(&priv->poll_workq, poll_work);
++	timer_setup(&priv->poll_timer, poll_timerf, 0);
++	mod_timer(&priv->poll_timer, jiffies + msecs_to_jiffies(1000));
++
+ 	return ret;
+ }
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0055-dfl-add-config-fragment-and-readme.patch new/debian/patches/fpga-ofs/0055-dfl-add-config-fragment-and-readme.patch
--- org/debian/patches/fpga-ofs/0055-dfl-add-config-fragment-and-readme.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0055-dfl-add-config-fragment-and-readme.patch	2021-07-20 06:17:11.412844844 +0200
@@ -0,0 +1,86 @@
+From 52caa9cbd1fb78ed1298afaaf4dbe8b0c0968c7c Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Mon, 4 May 2020 18:21:44 -0400
+Subject: [PATCH 055/149] dfl: add config fragment and readme
+
+Add a directory that contains kernel configuration fragments
+for the Device Feature List driver framework.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ configs/n3000_d5005_defconfig | 38 +++++++++++++++++++++++++++++++++++
+ configs/readme.txt            | 16 +++++++++++++++
+ 2 files changed, 54 insertions(+)
+ create mode 100644 configs/n3000_d5005_defconfig
+ create mode 100644 configs/readme.txt
+
+diff --git a/configs/n3000_d5005_defconfig b/configs/n3000_d5005_defconfig
+new file mode 100644
+index 000000000000..79c66efcca59
+--- /dev/null
++++ b/configs/n3000_d5005_defconfig
+@@ -0,0 +1,38 @@
++CONFIG_FPGA_DFL=m
++CONFIG_FPGA_DFL_FME=m
++CONFIG_FPGA_DFL_FME_MGR=m
++CONFIG_FPGA_DFL_FME_BRIDGE=m
++CONFIG_FPGA_DFL_FME_REGION=m
++CONFIG_FPGA_DFL_AFU=m
++CONFIG_FPGA_DFL_NIOS_INTEL_PAC_N3000=m
++CONFIG_FPGA_DFL_SPI_ALTERA=m
++CONFIG_FPGA_DFL_PCI=m
++CONFIG_FPGA_DFl_HSSI=m
++CONFIG_FPGA_DFL_INTEL_S10_IOPLL=m
++
++CONFIG_FPGA=m
++CONFIG_FPGA_BRIDGE=m
++CONFIG_FPGA_REGION=m
++
++CONFIG_FPGA_SEC_MGR=m
++CONFIG_IFPGA_M10_BMC_SECURE=m
++
++CONFIG_UIO_PDRV_GENIRQ=m
++CONFIG_FPGA_DFL_UIO_PDEV=m
++
++CONFIG_SENSORS_INTEL_M10_BMC_HWMON=m
++CONFIG_MFD_INTEL_M10_BMC=m
++
++CONFIG_SPI_ALTERA=m
++
++CONFIG_FPGA_DFL_ETH_GROUP=m
++CONFIG_INTEL_S10_PHY=m
++CONFIG_INTEL_M10_BMC_RETIMER=m
++CONFIG_S10HSSI=m
++
++CONFIG_REGMAP_MMIO=m
++
++CONFIG_MEMORY=y
++CONFIG_FPGA_DFL_EMIF=m
++
++CONFIG_IIO_INTERRUPT_TRIGGER=m
+diff --git a/configs/readme.txt b/configs/readme.txt
+new file mode 100644
+index 000000000000..285d09021633
+--- /dev/null
++++ b/configs/readme.txt
+@@ -0,0 +1,16 @@
++This directory contains linux kernel configuration fragments related to
++the Device Feature List (DFL) driver collection. By design the DFL driver
++collection is extendable, and it is anticipated that new drivers will be added
++to the collection.
++
++The fragments are intended to be appended to a base kernel configuration.
++For example the following commands would configure the kernel source to
++support the Intel n3000 and d5005 PCIe cards:
++
++	# cd kernel_source_directory
++	# cp /boot/config-`uname -r` .config
++	# cat configs/n3000_d5005_defconfig >> .config
++	# make olddefconfig
++
++n3000_d5005_defconfig
++	Default configuration for Intel n3000 and d5005 PCIe cards.
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0056-net-ethernet-intel-s10hssi-delete-timer-in-remove-fu.patch new/debian/patches/fpga-ofs/0056-net-ethernet-intel-s10hssi-delete-timer-in-remove-fu.patch
--- org/debian/patches/fpga-ofs/0056-net-ethernet-intel-s10hssi-delete-timer-in-remove-fu.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0056-net-ethernet-intel-s10hssi-delete-timer-in-remove-fu.patch	2021-07-20 06:17:11.412844844 +0200
@@ -0,0 +1,34 @@
+From 13a7108fb8f3212d379b2cffeb5c2520c452b3ba Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Wed, 6 Jan 2021 16:03:12 -0800
+Subject: [PATCH 056/149] net: ethernet: intel: s10hssi: delete timer in remove
+ function
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Fix crash on driver removal by deleting the timer in the
+remove function.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Based-on: Martin Hundebøll <mhu@silicom.dk>
+---
+ drivers/net/ethernet/intel/s10hssi.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drivers/net/ethernet/intel/s10hssi.c b/drivers/net/ethernet/intel/s10hssi.c
+index c6dc551c637d..a3db9bb7101f 100644
+--- a/drivers/net/ethernet/intel/s10hssi.c
++++ b/drivers/net/ethernet/intel/s10hssi.c
+@@ -573,6 +573,8 @@ static void s10hssi_mac_remove(struct dfl_device *dfl_dev)
+ 	struct s10hssi_drvdata *priv = dev_get_drvdata(&dfl_dev->dev);
+ 
+ 	unregister_netdev(priv->netdev);
++
++	del_timer_sync(&priv->poll_timer);
+ }
+ 
+ #define FME_FEATURE_ID_LL_10G_MAC 0xf
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0057-fpga-sec-mgr-do-not-require-line-return-for-image-fi.patch new/debian/patches/fpga-ofs/0057-fpga-sec-mgr-do-not-require-line-return-for-image-fi.patch
--- org/debian/patches/fpga-ofs/0057-fpga-sec-mgr-do-not-require-line-return-for-image-fi.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0057-fpga-sec-mgr-do-not-require-line-return-for-image-fi.patch	2021-07-20 06:17:11.412844844 +0200
@@ -0,0 +1,33 @@
+From cc5bc607d48d5d365c7fa87b4f5e1f5f0fc216e4 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Mon, 11 Jan 2021 17:09:18 -0800
+Subject: [PATCH 057/149] fpga: sec-mgr: do not require line-return for image
+ filename
+
+The filename sysfs entry that is used to start a secure update
+was requiring a line-return at the end of the filename (e.g.
+echo IMAGE_FILE > filename). This is incorrect, so the line-return
+is being removed. To start an update directly with sysfs, do
+"echo -n IMAGE_FILE > filename".
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/fpga-sec-mgr.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index 72b61dc173db..5a43c6d05cf9 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -423,7 +423,7 @@ static ssize_t filename_store(struct device *dev, struct device_attribute *attr,
+ 		goto unlock_exit;
+ 	}
+ 
+-	smgr->filename = kstrndup(buf, count - 1, GFP_KERNEL);
++	smgr->filename = kstrndup(buf, count, GFP_KERNEL);
+ 	if (!smgr->filename) {
+ 		ret = -ENOMEM;
+ 		goto unlock_exit;
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0058-drivers-fpga-dfl-pci-Add-PCIE-device-ID-for-OFS.patch new/debian/patches/fpga-ofs/0058-drivers-fpga-dfl-pci-Add-PCIE-device-ID-for-OFS.patch
--- org/debian/patches/fpga-ofs/0058-drivers-fpga-dfl-pci-Add-PCIE-device-ID-for-OFS.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0058-drivers-fpga-dfl-pci-Add-PCIE-device-ID-for-OFS.patch	2021-07-20 06:17:11.412844844 +0200
@@ -0,0 +1,35 @@
+From bcf34c12b61a84f4169a0901c2a8eb6e3a5c129e Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Thu, 7 Jan 2021 12:19:26 -0800
+Subject: [PATCH 058/149] drivers: fpga: dfl-pci: Add PCIE device ID for OFS
+
+Add the generic Open Fpga Stack device id to pci_dev_table.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ drivers/fpga/dfl-pci.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drivers/fpga/dfl-pci.c b/drivers/fpga/dfl-pci.c
+index bc108ee8e9eb..d844bebb4cd4 100644
+--- a/drivers/fpga/dfl-pci.c
++++ b/drivers/fpga/dfl-pci.c
+@@ -66,6 +66,7 @@ static void cci_pci_free_irq(struct pci_dev *pcidev)
+ #define PCIE_DEVICE_ID_PF_DSC_1_X		0x09C4
+ #define PCIE_DEVICE_ID_INTEL_PAC_N3000		0x0B30
+ #define PCIE_DEVICE_ID_INTEL_PAC_D5005		0x0B2B
++#define PCIE_DEVCIE_ID_INTEL_OFS		0xaf00
+ /* VF Device */
+ #define PCIE_DEVICE_ID_VF_INT_5_X		0xBCBF
+ #define PCIE_DEVICE_ID_VF_INT_6_X		0xBCC1
+@@ -82,6 +83,7 @@ static struct pci_device_id cci_pcie_id_tbl[] = {
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_N3000),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_D5005),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_D5005_VF),},
++	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVCIE_ID_INTEL_OFS),},
+ 	{0,}
+ };
+ MODULE_DEVICE_TABLE(pci, cci_pcie_id_tbl);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0059-drivers-fpga-dfl-handle-empty-port-list.patch new/debian/patches/fpga-ofs/0059-drivers-fpga-dfl-handle-empty-port-list.patch
--- org/debian/patches/fpga-ofs/0059-drivers-fpga-dfl-handle-empty-port-list.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0059-drivers-fpga-dfl-handle-empty-port-list.patch	2021-07-20 06:17:11.412844844 +0200
@@ -0,0 +1,30 @@
+From c7f2b81d62195df3b0e7872430d3f9153f9b2fd5 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Mon, 11 Jan 2021 10:52:56 -0800
+Subject: [PATCH 059/149] drivers: fpga: dfl: handle empty port list
+
+Not all FPGA designs managed by the DFL driver have a port.
+In these cases, don't write the Port Access Control register
+when enabling SRIOV.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ drivers/fpga/dfl.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index e2935c46deee..0df3fbbbb25b 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -1783,6 +1783,8 @@ int dfl_fpga_cdev_config_ports_vf(struct dfl_fpga_cdev *cdev, int num_vfs)
+ 	int ret = 0;
+ 
+ 	mutex_lock(&cdev->lock);
++	if (list_empty(&cdev->port_dev_list))
++		goto done;
+ 	/*
+ 	 * can't turn multiple ports into 1 VF device, only 1 port for 1 VF
+ 	 * device, so if released port number doesn't match VF device number,
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0060-fpga-dfl-Move-DFH-header-register-macros-to-linux-df.patch new/debian/patches/fpga-ofs/0060-fpga-dfl-Move-DFH-header-register-macros-to-linux-df.patch
--- org/debian/patches/fpga-ofs/0060-fpga-dfl-Move-DFH-header-register-macros-to-linux-df.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0060-fpga-dfl-Move-DFH-header-register-macros-to-linux-df.patch	2021-07-20 06:17:11.416844833 +0200
@@ -0,0 +1,164 @@
+From a970418b023b2e3f2f02cfab8ef0780c57d243f9 Mon Sep 17 00:00:00 2001
+From: Debarati Biswas <debaratix.biswas@intel.com>
+Date: Tue, 2 Feb 2021 02:35:49 -0800
+Subject: [PATCH 060/149] fpga: dfl: Move DFH header register macros to
+ linux/dfl.h
+
+Device Feature List (DFL) drivers may be defined in subdirectories other
+than drivers/fpga, and each DFL driver should have access to the Device
+Feature Header (DFH) register, which contains revision and type
+information. This change moves the macros specific to the DFH register
+from drivers/fpga/dfl.h to include/linux/dfl.h.
+
+Signed-off-by: Debarati Biswas <debaratix.biswas@intel.com>
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl.h  | 48 +----------------------------------------
+ include/linux/dfl.h | 52 +++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 53 insertions(+), 47 deletions(-)
+
+diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
+index 6c7a69612bff..26567b081e59 100644
+--- a/drivers/fpga/dfl.h
++++ b/drivers/fpga/dfl.h
+@@ -17,6 +17,7 @@
+ #include <linux/bitfield.h>
+ #include <linux/cdev.h>
+ #include <linux/delay.h>
++#include <linux/dfl.h>
+ #include <linux/eventfd.h>
+ #include <linux/fs.h>
+ #include <linux/interrupt.h>
+@@ -53,32 +54,6 @@
+ #define PORT_FEATURE_ID_UINT		0x12
+ #define PORT_FEATURE_ID_STP		0x13
+ 
+-/*
+- * Device Feature Header Register Set
+- *
+- * For FIUs, they all have DFH + GUID + NEXT_AFU as common header registers.
+- * For AFUs, they have DFH + GUID as common header registers.
+- * For private features, they only have DFH register as common header.
+- */
+-#define DFH			0x0
+-#define GUID_L			0x8
+-#define GUID_H			0x10
+-#define NEXT_AFU		0x18
+-
+-#define DFH_SIZE		0x8
+-
+-/* Device Feature Header Register Bitfield */
+-#define DFH_ID			GENMASK_ULL(11, 0)	/* Feature ID */
+-#define DFH_ID_FIU_FME		0
+-#define DFH_ID_FIU_PORT		1
+-#define DFH_REVISION		GENMASK_ULL(15, 12)	/* Feature revision */
+-#define DFH_NEXT_HDR_OFST	GENMASK_ULL(39, 16)	/* Offset to next DFH */
+-#define DFH_EOL			BIT_ULL(40)		/* End of list */
+-#define DFH_TYPE		GENMASK_ULL(63, 60)	/* Feature type */
+-#define DFH_TYPE_AFU		1
+-#define DFH_TYPE_PRIVATE	3
+-#define DFH_TYPE_FIU		4
+-
+ /* Next AFU Register Bitfield */
+ #define NEXT_AFU_NEXT_DFH_OFST	GENMASK_ULL(23, 0)	/* Offset to next AFU */
+ 
+@@ -415,27 +390,6 @@ struct device *dfl_fpga_pdata_to_parent(struct dfl_feature_platform_data *pdata)
+ 	return pdata->dev->dev.parent->parent;
+ }
+ 
+-static inline bool dfl_feature_is_fme(void __iomem *base)
+-{
+-	u64 v = readq(base + DFH);
+-
+-	return (FIELD_GET(DFH_TYPE, v) == DFH_TYPE_FIU) &&
+-		(FIELD_GET(DFH_ID, v) == DFH_ID_FIU_FME);
+-}
+-
+-static inline bool dfl_feature_is_port(void __iomem *base)
+-{
+-	u64 v = readq(base + DFH);
+-
+-	return (FIELD_GET(DFH_TYPE, v) == DFH_TYPE_FIU) &&
+-		(FIELD_GET(DFH_ID, v) == DFH_ID_FIU_PORT);
+-}
+-
+-static inline u8 dfl_feature_revision(void __iomem *base)
+-{
+-	return (u8)FIELD_GET(DFH_REVISION, readq(base + DFH));
+-}
+-
+ /**
+  * struct dfl_fpga_enum_info - DFL FPGA enumeration information
+  *
+diff --git a/include/linux/dfl.h b/include/linux/dfl.h
+index dd313f24efef..b36c2be63bd1 100644
+--- a/include/linux/dfl.h
++++ b/include/linux/dfl.h
+@@ -8,7 +8,9 @@
+ #ifndef __LINUX_FPGA_DFL_H
+ #define __LINUX_FPGA_DFL_H
+ 
++#include <linux/bitfield.h>
+ #include <linux/device.h>
++#include <linux/io.h>
+ #include <linux/mod_devicetable.h>
+ 
+ /**
+@@ -88,4 +90,54 @@ void dfl_driver_unregister(struct dfl_driver *dfl_drv);
+ 	module_driver(__dfl_driver, dfl_driver_register, \
+ 		      dfl_driver_unregister)
+ 
++/*
++ * Device Feature Header Register Set
++ *
++ * For FIUs, they all have DFH + GUID + NEXT_AFU as common header registers.
++ * For AFUs, they have DFH + GUID as common header registers.
++ * For private features, they only have DFH register as common header.
++ */
++#define DFH                     0x0
++#define GUID_L                  0x8
++#define GUID_H                  0x10
++#define NEXT_AFU                0x18
++
++#define DFH_SIZE                0x8
++
++/* Device Feature Header Register Bitfield */
++#define DFH_ID                  GENMASK_ULL(11, 0)      /* Feature ID */
++#define DFH_ID_FIU_FME          0
++#define DFH_ID_FIU_PORT         1
++#define DFH_REVISION            GENMASK_ULL(15, 12)
++#define DFH_NEXT_HDR_OFST       GENMASK_ULL(39, 16)     /* Offset to next DFH */
++#define DFH_EOL                 BIT_ULL(40)             /* End of list */
++#define DFH_TYPE                GENMASK_ULL(63, 60)     /* Feature type */
++#define DFH_TYPE_AFU            1
++#define DFH_TYPE_PRIVATE        3
++#define DFH_TYPE_FIU            4
++
++/* Function to read from DFH and check if the Feature type is FME */
++static inline bool dfl_feature_is_fme(void __iomem *base)
++{
++	u64 v = readq(base + DFH);
++
++	return (FIELD_GET(DFH_TYPE, v) == DFH_TYPE_FIU) &&
++		(FIELD_GET(DFH_ID, v) == DFH_ID_FIU_FME);
++}
++
++/* Function to read from DFH and check if the Feature type is port*/
++static inline bool dfl_feature_is_port(void __iomem *base)
++{
++	u64 v = readq(base + DFH);
++
++	return (FIELD_GET(DFH_TYPE, v) == DFH_TYPE_FIU) &&
++		 (FIELD_GET(DFH_ID, v) == DFH_ID_FIU_PORT);
++}
++
++/* Function to read feature revision from DFH */
++static inline u8 dfl_feature_revision(void __iomem *base)
++{
++	return (u8)FIELD_GET(DFH_REVISION, readq(base + DFH));
++}
++
+ #endif /* __LINUX_FPGA_DFL_H */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0061-fpga-dfl-Update-the-dfl-emif-driver-support-revision.patch new/debian/patches/fpga-ofs/0061-fpga-dfl-Update-the-dfl-emif-driver-support-revision.patch
--- org/debian/patches/fpga-ofs/0061-fpga-dfl-Update-the-dfl-emif-driver-support-revision.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0061-fpga-dfl-Update-the-dfl-emif-driver-support-revision.patch	2021-07-20 06:17:11.416844833 +0200
@@ -0,0 +1,127 @@
+From 9a41bdd57ea00f897508458e5e9dda115d177abf Mon Sep 17 00:00:00 2001
+From: Debarati Biswas <debaratix.biswas@intel.com>
+Date: Tue, 2 Feb 2021 02:42:18 -0800
+Subject: [PATCH 061/149] fpga: dfl: Update the dfl emif driver support
+ revision 1
+
+The next generation (revision 1) of the DFL EMIF feature device requires
+support for more than 4 memory banks. It does not support the selective
+clearing of memory banks. A capability register replaces the previous
+control register, and contains a bitmask to indicate the presence of each
+memory bank. This bitmask aligns with the previous control register
+bitmask that served the same purpose. The control and capability
+registers are treated like a C Union structure in order to support both
+the new and old revisions of the EMIF device.
+
+Signed-off-by: Debarati Biswas <debaratix.biswas@intel.com>
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/memory/dfl-emif.c | 55 +++++++++++++++++++++++++++++++++++----
+ 1 file changed, 50 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/memory/dfl-emif.c b/drivers/memory/dfl-emif.c
+index 3f719816771d..dfcc2b6da47d 100644
+--- a/drivers/memory/dfl-emif.c
++++ b/drivers/memory/dfl-emif.c
+@@ -24,11 +24,23 @@
+ #define EMIF_STAT_CLEAR_BUSY_SFT	16
+ #define EMIF_CTRL			0x10
+ #define EMIF_CTRL_CLEAR_EN_SFT		0
+-#define EMIF_CTRL_CLEAR_EN_MSK		GENMASK_ULL(3, 0)
++#define EMIF_CTRL_CLEAR_EN_MSK		GENMASK_ULL(7, 0)
+ 
+ #define EMIF_POLL_INVL			10000 /* us */
+ #define EMIF_POLL_TIMEOUT		5000000 /* us */
+ 
++/*
++ * The Capability Register replaces the Control Register (at the same
++ * offset) for EMIF feature revisions > 0. The bitmask that indicates
++ * the presence of memory channels exists in both the Capability Register
++ * and Control Register definitions. These can be thought of as a C union.
++ * The Capability Register definitions are used to check for the existence
++ * of a memory channel, and the Control Register definitions are used for
++ * managing the memory-clear functionality in revision 0.
++ */
++#define EMIF_CAPABILITY_BASE            0x10
++#define EMIF_CAPABILITY_CHN_MSK         GENMASK_ULL(7, 0)
++
+ struct dfl_emif {
+ 	struct device *dev;
+ 	void __iomem *base;
+@@ -106,16 +118,30 @@ emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 0);
+ emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 1);
+ emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 2);
+ emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 3);
++emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 4);
++emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 5);
++emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 6);
++emif_state_attr(init_done, EMIF_STAT_INIT_DONE_SFT, 7);
+ 
+ emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 0);
+ emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 1);
+ emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 2);
+ emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 3);
++emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 4);
++emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 5);
++emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 6);
++emif_state_attr(cal_fail, EMIF_STAT_CALC_FAIL_SFT, 7);
++
+ 
+ emif_clear_attr(0);
+ emif_clear_attr(1);
+ emif_clear_attr(2);
+ emif_clear_attr(3);
++emif_clear_attr(4);
++emif_clear_attr(5);
++emif_clear_attr(6);
++emif_clear_attr(7);
++
+ 
+ static struct attribute *dfl_emif_attrs[] = {
+ 	&emif_attr_inf0_init_done.attr.attr,
+@@ -134,6 +160,22 @@ static struct attribute *dfl_emif_attrs[] = {
+ 	&emif_attr_inf3_cal_fail.attr.attr,
+ 	&emif_attr_inf3_clear.attr.attr,
+ 
++	&emif_attr_inf4_init_done.attr.attr,
++	&emif_attr_inf4_cal_fail.attr.attr,
++	&emif_attr_inf4_clear.attr.attr,
++
++	&emif_attr_inf5_init_done.attr.attr,
++	&emif_attr_inf5_cal_fail.attr.attr,
++	&emif_attr_inf5_clear.attr.attr,
++
++	&emif_attr_inf6_init_done.attr.attr,
++	&emif_attr_inf6_cal_fail.attr.attr,
++	&emif_attr_inf6_clear.attr.attr,
++
++	&emif_attr_inf7_init_done.attr.attr,
++	&emif_attr_inf7_cal_fail.attr.attr,
++	&emif_attr_inf7_clear.attr.attr,
++
+ 	NULL,
+ };
+ 
+@@ -146,12 +188,15 @@ static umode_t dfl_emif_visible(struct kobject *kobj,
+ 	u64 val;
+ 
+ 	/*
+-	 * This device supports upto 4 memory interfaces, but not all
++	 * This device supports up to 8 memory interfaces, but not all
+ 	 * interfaces are used on different platforms. The read out value of
+-	 * CLEAN_EN field (which is a bitmap) could tell how many interfaces
+-	 * are available.
++	 * CAPABILITY_CHN_MSK field (which is a bitmap) indicates which
++	 * interfaces are available.
+ 	 */
+-	val = FIELD_GET(EMIF_CTRL_CLEAR_EN_MSK, readq(de->base + EMIF_CTRL));
++	if (dfl_feature_revision(de->base) > 0 && strstr(attr->name, "_clear"))
++		return 0;
++
++	val = FIELD_GET(EMIF_CAPABILITY_CHN_MSK, readq(de->base + EMIF_CAPABILITY_BASE));
+ 
+ 	return (val & BIT_ULL(eattr->index)) ? attr->mode : 0;
+ }
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0062-fpga-sec-mgr-move-sysfs-security-sub-directory.patch new/debian/patches/fpga-ofs/0062-fpga-sec-mgr-move-sysfs-security-sub-directory.patch
--- org/debian/patches/fpga-ofs/0062-fpga-sec-mgr-move-sysfs-security-sub-directory.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0062-fpga-sec-mgr-move-sysfs-security-sub-directory.patch	2021-07-20 06:17:11.428844799 +0200
@@ -0,0 +1,816 @@
+From 1a719208550a4d34d2e65500a7348309a297c3cc Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 16 Feb 2021 10:52:04 -0800
+Subject: [PATCH 062/149] fpga: sec-mgr: move sysfs security sub-directory
+
+The security subdirectory of the security manager is not considered
+generic enough to be a part of the class driver. This subdirectory
+is therefore being moved out of the class driver and into the
+device-specific parent driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ .../ABI/testing/sysfs-class-fpga-sec-mgr      |  90 +------
+ .../testing/sysfs-driver-intel-m10-bmc-secure |  61 +++++
+ MAINTAINERS                                   |   1 +
+ drivers/fpga/fpga-sec-mgr.c                   | 191 --------------
+ drivers/fpga/intel-m10-bmc-secure.c           | 249 +++++++-----------
+ include/linux/mfd/intel-m10-bmc.h             |   4 +-
+ 6 files changed, 180 insertions(+), 416 deletions(-)
+ create mode 100644 Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-secure
+
+diff --git a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+index a153a274cd51..29efacedaa3e 100644
+--- a/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
++++ b/Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
+@@ -1,74 +1,12 @@
+ What: 		/sys/class/fpga_sec_mgr/fpga_secX/name
+-Date:		Oct 2020
+-KernelVersion:  5.11
++Date:		January 2021
++KernelVersion:  5.12
+ Contact:	Russ Weight <russell.h.weight@intel.com>
+ Description:	Name of low level fpga security manager driver.
+ 
+-What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/sr_root_entry_hash
+-Date:		Oct 2020
+-KernelVersion:  5.11
+-Contact:	Russ Weight <russell.h.weight@intel.com>
+-Description:	Read only. Returns the root entry hash for the static
+-		region if one is programmed, else it returns the
+-		string: "hash not programmed".  This file is only
+-		visible if the underlying device supports it.
+-		Format: "0x%x".
+-
+-What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/pr_root_entry_hash
+-Date:		Oct 2020
+-KernelVersion:  5.11
+-Contact:	Russ Weight <russell.h.weight@intel.com>
+-Description:	Read only. Returns the root entry hash for the partial
+-		reconfiguration region if one is programmed, else it
+-		returns the string: "hash not programmed".  This file
+-		is only visible if the underlying device supports it.
+-		Format: "0x%x".
+-
+-What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/bmc_root_entry_hash
+-Date:		Oct 2020
+-KernelVersion:  5.11
+-Contact:	Russ Weight <russell.h.weight@intel.com>
+-Description:	Read only. Returns the root entry hash for the BMC image
+-		if one is programmed, else it returns the string:
+-		"hash not programmed".  This file is only visible if the
+-		underlying device supports it.
+-		Format: "0x%x".
+-
+-What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/sr_canceled_csks
+-Date:		Oct 2020
+-KernelVersion:  5.11
+-Contact:	Russ Weight <russell.h.weight@intel.com>
+-Description:	Read only. Returns a list of indices for canceled code
+-		signing keys for the static region. The standard bitmap
+-		list format is used (e.g. "1,2-6,9").
+-
+-What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/pr_canceled_csks
+-Date:		Oct 2020
+-KernelVersion:  5.11
+-Contact:	Russ Weight <russell.h.weight@intel.com>
+-Description:	Read only. Returns a list of indices for canceled code
+-		signing keys for the partial reconfiguration region. The
+-		standard bitmap list format is used (e.g. "1,2-6,9").
+-
+-What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/bmc_canceled_csks
+-Date:		Oct 2020
+-KernelVersion:  5.11
+-Contact:	Russ Weight <russell.h.weight@intel.com>
+-Description:	Read only. Returns a list of indices for canceled code
+-		signing keys for the BMC.  The standard bitmap list format
+-		is used (e.g. "1,2-6,9").
+-
+-What: 		/sys/class/fpga_sec_mgr/fpga_secX/security/user_flash_count
+-Date:		Oct 2020
+-KernelVersion:  5.11
+-Contact:	Russ Weight <russell.h.weight@intel.com>
+-Description:	Read only. Returns number of times the user image for the
+-		static region has been flashed.
+-		Format: "%u".
+-
+ What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/filename
+-Date:		Oct 2020
+-KernelVersion:  5.11
++Date:		January 2021
++KernelVersion:  5.12
+ Contact:	Russ Weight <russell.h.weight@intel.com>
+ Description:	Write only. Write the filename of an image
+ 		file to this sysfs file to initiate a secure
+@@ -80,8 +18,8 @@ Description:	Write only. Write the filename of an image
+ 		Keys (CSK).
+ 
+ What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/cancel
+-Date:		Oct 2020
+-KernelVersion:  5.11
++Date:		January 2021
++KernelVersion:  5.12
+ Contact:	Russ Weight <russell.h.weight@intel.com>
+ Description:	Write-only. Write a "1" to this file to request
+ 		that a current update be canceled. This request
+@@ -90,8 +28,8 @@ Description:	Write-only. Write a "1" to this file to request
+ 		update in progress.
+ 
+ What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/status
+-Date:		Oct 2020
+-KernelVersion:  5.11
++Date:		January 2021
++KernelVersion:  5.12
+ Contact:	Russ Weight <russell.h.weight@intel.com>
+ Description:	Read-only. Returns a string describing the current
+ 		status of an update. The string will be one of the
+@@ -101,8 +39,8 @@ Description:	Read-only. Returns a string describing the current
+ 		state change.
+ 
+ What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/remaining_size
+-Date:		Oct 2020
+-KernelVersion:  5.11
++Date:		January 2021
++KernelVersion:  5.12
+ Contact:	Russ Weight <russell.h.weight@intel.com>
+ Description:	Read-only. Returns the size of data that remains to
+ 		be written to the secure update engine. The size
+@@ -112,8 +50,8 @@ Description:	Read-only. Returns the size of data that remains to
+ 		Format: "%u".
+ 
+ What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/error
+-Date:		Oct 2020
+-KernelVersion:  5.11
++Date:		January 2021
++KernelVersion:  5.12
+ Contact:	Russ Weight <russell.h.weight@intel.com>
+ Description:	Read-only. Returns a string describing the failure
+ 		of a secure update. This string will be in the form
+@@ -129,8 +67,8 @@ Description:	Read-only. Returns a string describing the failure
+ 		EBUSY.
+ 
+ What: 		/sys/class/fpga_sec_mgr/fpga_secX/update/hw_errinfo
+-Date:		Oct 2020
+-KernelVersion:  5.11
++Date:		January 2021
++KernelVersion:  5.12
+ Contact:	Russ Weight <russell.h.weight@intel.com>
+ Description:	Read-only. Returns a 64 bit error value providing
+ 		hardware specific information that may be useful in
+diff --git a/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-secure b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-secure
+new file mode 100644
+index 000000000000..27890a9ba355
+--- /dev/null
++++ b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-secure
+@@ -0,0 +1,61 @@
++What:		/sys/bus/platform/devices/n3000bmc-secure.*.auto/security/sr_root_entry_hash
++Date:		January 2021
++KernelVersion:  5.12
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns the root entry hash for the static
++		region if one is programmed, else it returns the
++		string: "hash not programmed".  This file is only
++		visible if the underlying device supports it.
++		Format: "0x%x".
++
++What:		/sys/bus/platform/devices/n3000bmc-secure.*.auto/security/pr_root_entry_hash
++Date:		January 2021
++KernelVersion:  5.12
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns the root entry hash for the partial
++		reconfiguration region if one is programmed, else it
++		returns the string: "hash not programmed".  This file
++		is only visible if the underlying device supports it.
++		Format: "0x%x".
++
++What:		/sys/bus/platform/devices/n3000bmc-secure.*.auto/security/bmc_root_entry_hash
++Date:		January 2021
++KernelVersion:  5.12
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns the root entry hash for the BMC image
++		if one is programmed, else it returns the string:
++		"hash not programmed".  This file is only visible if the
++		underlying device supports it.
++		Format: "0x%x".
++
++What:		/sys/bus/platform/devices/n3000bmc-secure.*.auto/security/sr_canceled_csks
++Date:		January 2021
++KernelVersion:  5.12
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns a list of indices for canceled code
++		signing keys for the static region. The standard bitmap
++		list format is used (e.g. "1,2-6,9").
++
++What:		/sys/bus/platform/devices/n3000bmc-secure.*.auto/security/pr_canceled_csks
++Date:		January 2021
++KernelVersion:  5.12
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns a list of indices for canceled code
++		signing keys for the partial reconfiguration region. The
++		standard bitmap list format is used (e.g. "1,2-6,9").
++
++What:		/sys/bus/platform/devices/n3000bmc-secure.*.auto/security/bmc_canceled_csks
++Date:		January 2021
++KernelVersion:  5.12
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns a list of indices for canceled code
++		signing keys for the BMC.  The standard bitmap list format
++		is used (e.g. "1,2-6,9").
++
++What:		/sys/bus/platform/devices/n3000bmc-secure.*.auto/security/flash_count
++Date:		January 2021
++KernelVersion:  5.12
++Contact:	Russ Weight <russell.h.weight@intel.com>
++Description:	Read only. Returns number of times the secure update
++		staging area has been flashed.
++		Format: "%u".
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 937b6aa2c717..3eccdcfc7984 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -6917,6 +6917,7 @@ M:	Russ Weight <russell.h.weight@intel.com>
+ L:	linux-fpga@vger.kernel.org
+ S:	Maintained
+ F:	Documentation/ABI/testing/sysfs-class-fpga-sec-mgr
++F:	Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-secure
+ F:	Documentation/fpga/fpga-sec-mgr.rst
+ F:	drivers/fpga/fpga-sec-mgr.c
+ F:	drivers/fpga/intel-m10-bmc-secure.c
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index 5a43c6d05cf9..f2584a63313f 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -25,124 +25,6 @@ struct fpga_sec_mgr_devres {
+ 
+ #define to_sec_mgr(d) container_of(d, struct fpga_sec_mgr, dev)
+ 
+-static ssize_t
+-show_canceled_csk(struct fpga_sec_mgr *smgr,
+-		  int (*get_csk)(struct fpga_sec_mgr *smgr,
+-				 unsigned long *csk_map, unsigned int nbits),
+-		  int (*get_csk_nbits)(struct fpga_sec_mgr *smgr),
+-		  char *buf)
+-{
+-	unsigned long *csk_map = NULL;
+-	unsigned int nbits;
+-	int ret;
+-
+-	ret = get_csk_nbits(smgr);
+-	if (ret < 0)
+-		return ret;
+-
+-	nbits = (unsigned int)ret;
+-	csk_map = vmalloc(sizeof(unsigned long) * BITS_TO_LONGS(nbits));
+-	if (!csk_map)
+-		return -ENOMEM;
+-
+-	ret = get_csk(smgr, csk_map, nbits);
+-	if (ret)
+-		goto vfree_exit;
+-
+-	ret = bitmap_print_to_pagebuf(1, buf, csk_map, nbits);
+-
+-vfree_exit:
+-	vfree(csk_map);
+-	return ret;
+-}
+-
+-static ssize_t
+-show_root_entry_hash(struct fpga_sec_mgr *smgr,
+-		     int (*get_reh)(struct fpga_sec_mgr *smgr, u8 *hash,
+-				    unsigned int size),
+-		     int (*get_reh_size)(struct fpga_sec_mgr *smgr),
+-		     char *buf)
+-{
+-	int size, i, cnt, ret;
+-	u8 *hash;
+-
+-	ret = get_reh_size(smgr);
+-	if (ret < 0)
+-		return ret;
+-	else if (!ret)
+-		return sysfs_emit(buf, "hash not programmed\n");
+-
+-	size = ret;
+-	hash = vmalloc(size);
+-	if (!hash)
+-		return -ENOMEM;
+-
+-	ret = get_reh(smgr, hash, size);
+-	if (ret)
+-		goto vfree_exit;
+-
+-	cnt = sprintf(buf, "0x");
+-	for (i = 0; i < size; i++)
+-		cnt += sprintf(buf + cnt, "%02x", hash[i]);
+-	cnt += sprintf(buf + cnt, "\n");
+-
+-vfree_exit:
+-	vfree(hash);
+-	return ret ? : cnt;
+-}
+-
+-#define DEVICE_ATTR_SEC_CSK(_name) \
+-static ssize_t _name##_canceled_csks_show(struct device *dev, \
+-					  struct device_attribute *attr, \
+-					  char *buf) \
+-{ \
+-	struct fpga_sec_mgr *smgr = to_sec_mgr(dev); \
+-	return show_canceled_csk(smgr, \
+-	       smgr->sops->_name##_canceled_csks, \
+-	       smgr->sops->_name##_canceled_csk_nbits, buf); \
+-} \
+-static DEVICE_ATTR_RO(_name##_canceled_csks)
+-
+-#define DEVICE_ATTR_SEC_ROOT_ENTRY_HASH(_name) \
+-static ssize_t _name##_root_entry_hash_show(struct device *dev, \
+-				     struct device_attribute *attr, \
+-				     char *buf) \
+-{ \
+-	struct fpga_sec_mgr *smgr = to_sec_mgr(dev); \
+-	return show_root_entry_hash(smgr, \
+-	       smgr->sops->_name##_root_entry_hash, \
+-	       smgr->sops->_name##_reh_size, buf); \
+-} \
+-static DEVICE_ATTR_RO(_name##_root_entry_hash)
+-
+-static ssize_t user_flash_count_show(struct device *dev,
+-				     struct device_attribute *attr, char *buf)
+-{
+-	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
+-	int cnt = smgr->sops->user_flash_count(smgr);
+-
+-	return cnt < 0 ? cnt : sysfs_emit(buf, "%u\n", cnt);
+-}
+-static DEVICE_ATTR_RO(user_flash_count);
+-
+-DEVICE_ATTR_SEC_ROOT_ENTRY_HASH(sr);
+-DEVICE_ATTR_SEC_ROOT_ENTRY_HASH(pr);
+-DEVICE_ATTR_SEC_ROOT_ENTRY_HASH(bmc);
+-DEVICE_ATTR_SEC_CSK(sr);
+-DEVICE_ATTR_SEC_CSK(pr);
+-DEVICE_ATTR_SEC_CSK(bmc);
+-
+-static struct attribute *sec_mgr_security_attrs[] = {
+-	&dev_attr_user_flash_count.attr,
+-	&dev_attr_bmc_root_entry_hash.attr,
+-	&dev_attr_sr_root_entry_hash.attr,
+-	&dev_attr_pr_root_entry_hash.attr,
+-	&dev_attr_sr_canceled_csks.attr,
+-	&dev_attr_pr_canceled_csks.attr,
+-	&dev_attr_bmc_canceled_csks.attr,
+-	NULL,
+-};
+-
+ static void update_progress(struct fpga_sec_mgr *smgr,
+ 			    enum fpga_sec_prog new_progress)
+ {
+@@ -274,36 +156,6 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ 	progress_complete(smgr);
+ }
+ 
+-#define check_attr(attribute, _name) \
+-	((attribute) == &dev_attr_##_name.attr && smgr->sops->_name)
+-
+-static umode_t sec_mgr_visible(struct kobject *kobj,
+-			       struct attribute *attr, int n)
+-{
+-	struct fpga_sec_mgr *smgr = to_sec_mgr(kobj_to_dev(kobj));
+-
+-	/*
+-	 * Only display optional sysfs attributes if a
+-	 * corresponding handler is provided
+-	 */
+-	if (check_attr(attr, user_flash_count) ||
+-	    check_attr(attr, bmc_root_entry_hash) ||
+-	    check_attr(attr, sr_root_entry_hash) ||
+-	    check_attr(attr, pr_root_entry_hash) ||
+-	    check_attr(attr, sr_canceled_csks) ||
+-	    check_attr(attr, pr_canceled_csks) ||
+-	    check_attr(attr, bmc_canceled_csks))
+-		return attr->mode;
+-
+-	return 0;
+-}
+-
+-static struct attribute_group sec_mgr_security_attr_group = {
+-	.name = "security",
+-	.attrs = sec_mgr_security_attrs,
+-	.is_visible = sec_mgr_visible,
+-};
+-
+ static const char * const sec_mgr_prog_str[] = {
+ 	"idle",			/* FPGA_SEC_PROG_IDLE */
+ 	"reading",		/* FPGA_SEC_PROG_READING */
+@@ -556,44 +408,10 @@ static struct attribute_group sec_mgr_attr_group = {
+ 
+ static const struct attribute_group *fpga_sec_mgr_attr_groups[] = {
+ 	&sec_mgr_attr_group,
+-	&sec_mgr_security_attr_group,
+ 	&sec_mgr_update_attr_group,
+ 	NULL,
+ };
+ 
+-static bool check_sysfs_handler(struct device *dev,
+-				void *sysfs_handler, void *size_handler,
+-				const char *sysfs_handler_name,
+-				const char *size_handler_name)
+-{
+-	/*
+-	 * sysfs_handler and size_handler must either both be
+-	 * defined or both be NULL.
+-	 */
+-	if (sysfs_handler && !size_handler) {
+-		dev_err(dev, "%s registered without %s\n",
+-			sysfs_handler_name, size_handler_name);
+-		return false;
+-	} else if (!sysfs_handler && size_handler) {
+-		dev_err(dev, "%s registered without %s\n",
+-			size_handler_name, sysfs_handler_name);
+-		return false;
+-	}
+-	return true;
+-}
+-
+-#define check_reh_handler(_dev, _sops, _name) \
+-	check_sysfs_handler(_dev, (_sops)->_name##_root_entry_hash, \
+-			    (_sops)->_name##_reh_size, \
+-			    __stringify(_name##_root_entry_hash), \
+-			    __stringify(_name##_reh_size))
+-
+-#define check_csk_handler(_dev, _sops, _name) \
+-	check_sysfs_handler(_dev, (_sops)->_name##_canceled_csks, \
+-			    (_sops)->_name##_canceled_csk_nbits, \
+-			    __stringify(_name##_canceled_csks), \
+-			    __stringify(_name##_canceled_csk_nbits))
+-
+ /**
+  * fpga_sec_mgr_create - create and initialize an FPGA
+  *			  security manager struct
+@@ -623,15 +441,6 @@ fpga_sec_mgr_create(struct device *dev, const char *name,
+ 		return NULL;
+ 	}
+ 
+-	if (!check_reh_handler(dev, sops, bmc) ||
+-	    !check_reh_handler(dev, sops, sr) ||
+-	    !check_reh_handler(dev, sops, pr) ||
+-	    !check_csk_handler(dev, sops, bmc) ||
+-	    !check_csk_handler(dev, sops, sr) ||
+-	    !check_csk_handler(dev, sops, pr)) {
+-		return NULL;
+-	}
+-
+ 	if (sops->image_load) {
+ 		for (hndlr = sops->image_load; hndlr->name; hndlr++) {
+ 			if (!hndlr->load_image) {
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 0d8eefbce97d..b14e967ebe5f 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -13,7 +13,6 @@
+ #include <linux/module.h>
+ #include <linux/platform_device.h>
+ #include <linux/slab.h>
+-#include <linux/vmalloc.h>
+ 
+ struct m10bmc_sec {
+ 	struct device *dev;
+@@ -26,25 +25,24 @@ struct m10bmc_sec {
+ #define REH_MAGIC		GENMASK(15, 0)
+ #define REH_SHA_NUM_BYTES	GENMASK(31, 16)
+ 
+-static int m10bmc_reh_size(struct fpga_sec_mgr *smgr,
+-			   u32 exp_magic, u32 prog_addr)
++static ssize_t
++show_root_entry_hash(struct device *dev, u32 exp_magic,
++		     u32 prog_addr, u32 reh_addr, char *buf)
+ {
+-	struct m10bmc_sec *sec = smgr->priv;
+-	int sha_num_bytes, ret;
++	struct m10bmc_sec *sec = dev_get_drvdata(dev);
++	unsigned int stride = regmap_get_reg_stride(sec->m10bmc->regmap);
++	int sha_num_bytes, i, cnt, ret;
++	u8 hash[REH_SHA384_SIZE];
+ 	u32 magic;
+ 
+ 	ret = m10bmc_raw_read(sec->m10bmc, prog_addr, &magic);
+ 	if (ret)
+ 		return ret;
+ 
+-	dev_dbg(sec->dev, "%s magic 0x%08x\n", __func__, magic);
++	dev_dbg(dev, "%s magic 0x%08x\n", __func__, magic);
+ 
+-	/*
+-	 * If no magic number, then no Root Entry Hash (REH) is programmed,
+-	 * so the REH size is zero.
+-	 */
+ 	if (FIELD_GET(REH_MAGIC, magic) != exp_magic)
+-		return 0;
++		return sysfs_emit(buf, "hash not programmed\n");
+ 
+ 	sha_num_bytes = FIELD_GET(REH_SHA_NUM_BYTES, magic) / 8;
+ 	if (sha_num_bytes != REH_SHA256_SIZE &&
+@@ -54,165 +52,134 @@ static int m10bmc_reh_size(struct fpga_sec_mgr *smgr,
+ 		return -EINVAL;
+ 	}
+ 
+-	return sha_num_bytes;
+-}
++	WARN_ON(sha_num_bytes % stride);
++	ret = regmap_bulk_read(sec->m10bmc->regmap, reh_addr,
++			       hash, sha_num_bytes / stride);
++	if (ret) {
++		dev_err(dev, "failed to read root entry hash: %x cnt %x: %d\n",
++			reh_addr, sha_num_bytes / stride, ret);
++		return ret;
++	}
+ 
+-static int m10bmc_bmc_reh_size(struct fpga_sec_mgr *smgr)
+-{
+-	return m10bmc_reh_size(smgr, BMC_PROG_MAGIC, BMC_PROG_ADDR);
+-}
++	cnt = sprintf(buf, "0x");
++	for (i = 0; i < sha_num_bytes; i++)
++		cnt += sprintf(buf + cnt, "%02x", hash[i]);
++	cnt += sprintf(buf + cnt, "\n");
+ 
+-static int m10bmc_sr_reh_size(struct fpga_sec_mgr *smgr)
+-{
+-	return m10bmc_reh_size(smgr, SR_PROG_MAGIC, SR_PROG_ADDR);
++	return cnt;
+ }
+ 
+-static int m10bmc_pr_reh_size(struct fpga_sec_mgr *smgr)
+-{
+-	return m10bmc_reh_size(smgr, PR_PROG_MAGIC, PR_PROG_ADDR);
+-}
++#define DEVICE_ATTR_SEC_REH_RO(_name, _magic, _prog_addr, _reh_addr) \
++static ssize_t _name##_root_entry_hash_show(struct device *dev, \
++					    struct device_attribute *attr, \
++					    char *buf) \
++{ return show_root_entry_hash(dev, _magic, _prog_addr, _reh_addr, buf); } \
++static DEVICE_ATTR_RO(_name##_root_entry_hash)
++
++DEVICE_ATTR_SEC_REH_RO(bmc, BMC_PROG_MAGIC, BMC_PROG_ADDR, BMC_REH_ADDR);
++DEVICE_ATTR_SEC_REH_RO(sr, SR_PROG_MAGIC, SR_PROG_ADDR, SR_REH_ADDR);
++DEVICE_ATTR_SEC_REH_RO(pr, PR_PROG_MAGIC, PR_PROG_ADDR, PR_REH_ADDR);
+ 
+-static int m10bmc_reh(struct fpga_sec_mgr *smgr, u32 hash_addr,
+-		      u8 *hash, unsigned int size)
++#define CSK_BIT_LEN		128U
++#define CSK_32ARRAY_SIZE	DIV_ROUND_UP(CSK_BIT_LEN, 32)
++
++static ssize_t
++show_canceled_csk(struct device *dev, u32 addr, char *buf)
+ {
+-	struct m10bmc_sec *sec = smgr->priv;
+-	unsigned int stride = regmap_get_reg_stride(sec->m10bmc->regmap);
++	unsigned int i, stride, size = CSK_32ARRAY_SIZE * sizeof(u32);
++	struct m10bmc_sec *sec = dev_get_drvdata(dev);
++	DECLARE_BITMAP(csk_map, CSK_BIT_LEN);
++	__le32 csk_le32[CSK_32ARRAY_SIZE];
++	u32 csk32[CSK_32ARRAY_SIZE];
+ 	int ret;
+ 
+-	ret = regmap_bulk_read(sec->m10bmc->regmap, hash_addr,
+-			       hash, size / stride);
+-	if (ret)
+-		dev_err(sec->m10bmc->dev,
+-			"failed to read root entry hash: %x cnt %x: %d\n",
+-			hash_addr, size / stride, ret);
++	stride = regmap_get_reg_stride(sec->m10bmc->regmap);
+ 
+-	return ret;
+-}
++	WARN_ON(size % stride);
++	ret = regmap_bulk_read(sec->m10bmc->regmap, addr, csk_le32,
++			       size / stride);
++	if (ret) {
++		dev_err(sec->dev, "failed to read CSK vector: %x cnt %x: %d\n",
++			addr, size / stride, ret);
++		return ret;
++	}
+ 
+-static int m10bmc_bmc_reh(struct fpga_sec_mgr *smgr, u8 *hash,
+-			  unsigned int size)
+-{
+-	return m10bmc_reh(smgr, BMC_REH_ADDR, hash, size);
+-}
++	for (i = 0; i < CSK_32ARRAY_SIZE; i++)
++		csk32[i] = le32_to_cpu(((csk_le32[i])));
+ 
+-static int m10bmc_sr_reh(struct fpga_sec_mgr *smgr, u8 *hash,
+-			 unsigned int size)
+-{
+-	return m10bmc_reh(smgr, SR_REH_ADDR, hash, size);
++	bitmap_from_arr32(csk_map, csk32, CSK_BIT_LEN);
++	bitmap_complement(csk_map, csk_map, CSK_BIT_LEN);
++	return bitmap_print_to_pagebuf(1, buf, csk_map, CSK_BIT_LEN);
+ }
+ 
+-static int m10bmc_pr_reh(struct fpga_sec_mgr *smgr, u8 *hash,
+-			 unsigned int size)
+-{
+-	return m10bmc_reh(smgr, PR_REH_ADDR, hash, size);
+-}
++#define DEVICE_ATTR_SEC_CSK_RO(_name, _addr) \
++static ssize_t _name##_canceled_csks_show(struct device *dev, \
++					  struct device_attribute *attr, \
++					  char *buf) \
++{ return show_canceled_csk(dev, _addr, buf); } \
++static DEVICE_ATTR_RO(_name##_canceled_csks)
++
++#define CSK_VEC_OFFSET 0x34
+ 
+-#define FLASH_COUNT_SIZE 4096	/* count stored in inverted bit vector */
++DEVICE_ATTR_SEC_CSK_RO(bmc, BMC_PROG_ADDR + CSK_VEC_OFFSET);
++DEVICE_ATTR_SEC_CSK_RO(sr, SR_PROG_ADDR + CSK_VEC_OFFSET);
++DEVICE_ATTR_SEC_CSK_RO(pr, PR_PROG_ADDR + CSK_VEC_OFFSET);
+ 
+-static int m10bmc_user_flash_count(struct fpga_sec_mgr *smgr)
++#define FLASH_COUNT_SIZE 4096	/* count stored as inverted bit vector */
++
++static ssize_t flash_count_show(struct device *dev,
++				struct device_attribute *attr, char *buf)
+ {
+-	struct m10bmc_sec *sec = smgr->priv;
+-	unsigned int stride = regmap_get_reg_stride(sec->m10bmc->regmap);
+-	unsigned int num_bits = FLASH_COUNT_SIZE * 8;
++	struct m10bmc_sec *sec = dev_get_drvdata(dev);
++	unsigned int stride, num_bits;
+ 	u8 *flash_buf;
+-	int ret;
++	int cnt, ret;
++
++	stride = regmap_get_reg_stride(sec->m10bmc->regmap);
++	num_bits = FLASH_COUNT_SIZE * 8;
+ 
+ 	flash_buf = kmalloc(FLASH_COUNT_SIZE, GFP_KERNEL);
+ 	if (!flash_buf)
+ 		return -ENOMEM;
+ 
+-	ret = regmap_bulk_read(sec->m10bmc->regmap, USER_FLASH_COUNT,
++	WARN_ON(FLASH_COUNT_SIZE % stride);
++	ret = regmap_bulk_read(sec->m10bmc->regmap, STAGING_FLASH_COUNT,
+ 			       flash_buf, FLASH_COUNT_SIZE / stride);
+ 	if (ret) {
+ 		dev_err(sec->dev,
+ 			"failed to read flash count: %x cnt %x: %d\n",
+-			USER_FLASH_COUNT, FLASH_COUNT_SIZE / stride, ret);
++			STAGING_FLASH_COUNT, FLASH_COUNT_SIZE / stride, ret);
+ 		goto exit_free;
+ 	}
+-
+-	ret = num_bits - bitmap_weight((unsigned long *)flash_buf, num_bits);
++	cnt = num_bits - bitmap_weight((unsigned long *)flash_buf, num_bits);
+ 
+ exit_free:
+ 	kfree(flash_buf);
+ 
+-	return ret;
+-}
+-
+-#define CSK_BIT_LEN			128U
+-#define CSK_32ARRAY_SIZE(_nbits)	DIV_ROUND_UP(_nbits, 32)
+-
+-static int m10bmc_csk_cancel_nbits(struct fpga_sec_mgr *smgr)
+-{
+-	return (int)CSK_BIT_LEN;
+-}
+-
+-static int m10bmc_csk_vector(struct fpga_sec_mgr *smgr, u32 addr,
+-			     unsigned long *csk_map, unsigned int nbits)
+-{
+-	unsigned int i, size, arr_size = CSK_32ARRAY_SIZE(nbits);
+-	struct m10bmc_sec *sec = smgr->priv;
+-	unsigned int stride;
+-	__le32 *csk_le32;
+-	u32 *csk32;
+-	int ret;
+-
+-	stride = regmap_get_reg_stride(sec->m10bmc->regmap);
+-	size = arr_size * sizeof(u32);
+-
+-	csk32 = vmalloc(size);
+-	if (!csk32)
+-		return -ENOMEM;
+-
+-	csk_le32 = vmalloc(size);
+-	if (!csk_le32) {
+-		vfree(csk32);
+-		return -ENOMEM;
+-	}
+-
+-	ret = regmap_bulk_read(sec->m10bmc->regmap, addr, csk_le32, size / stride);
+-	if (ret) {
+-		dev_err(sec->dev, "failed to read CSK vector: %x cnt %x: %d\n",
+-			addr, size / stride, ret);
+-		goto vfree_exit;
+-	}
+-
+-	for (i = 0; i < arr_size; i++)
+-		csk32[i] = le32_to_cpu(((csk_le32[i])));
+-
+-	bitmap_from_arr32(csk_map, csk32, nbits);
+-	bitmap_complement(csk_map, csk_map, nbits);
+-
+-vfree_exit:
+-	vfree(csk_le32);
+-	vfree(csk32);
+-	return ret;
++	return ret ? : sysfs_emit(buf, "%u\n", cnt);
+ }
++static DEVICE_ATTR_RO(flash_count);
+ 
+-#define CSK_VEC_OFFSET 0x34
+-
+-static int m10bmc_bmc_canceled_csks(struct fpga_sec_mgr *smgr,
+-				    unsigned long *csk_map,
+-				    unsigned int nbits)
+-{
+-	return m10bmc_csk_vector(smgr, BMC_PROG_ADDR + CSK_VEC_OFFSET,
+-				 csk_map, nbits);
+-}
++static struct attribute *m10bmc_security_attrs[] = {
++	&dev_attr_flash_count.attr,
++	&dev_attr_bmc_root_entry_hash.attr,
++	&dev_attr_sr_root_entry_hash.attr,
++	&dev_attr_pr_root_entry_hash.attr,
++	&dev_attr_sr_canceled_csks.attr,
++	&dev_attr_pr_canceled_csks.attr,
++	&dev_attr_bmc_canceled_csks.attr,
++	NULL,
++};
+ 
+-static int m10bmc_sr_canceled_csks(struct fpga_sec_mgr *smgr,
+-				   unsigned long *csk_map,
+-				   unsigned int nbits)
+-{
+-	return m10bmc_csk_vector(smgr, SR_PROG_ADDR + CSK_VEC_OFFSET,
+-				 csk_map, nbits);
+-}
++static struct attribute_group m10bmc_security_attr_group = {
++	.name = "security",
++	.attrs = m10bmc_security_attrs,
++};
+ 
+-static int m10bmc_pr_canceled_csks(struct fpga_sec_mgr *smgr,
+-				   unsigned long *csk_map,
+-				   unsigned int nbits)
+-{
+-	return m10bmc_csk_vector(smgr, PR_PROG_ADDR + CSK_VEC_OFFSET,
+-				 csk_map, nbits);
+-}
++static const struct attribute_group *m10bmc_sec_attr_groups[] = {
++	&m10bmc_security_attr_group,
++	NULL,
++};
+ 
+ static void log_error_regs(struct m10bmc_sec *sec, u32 doorbell)
+ {
+@@ -777,19 +744,6 @@ m10bmc_sops_create(struct device *dev, enum m10bmc_type type)
+ 	if (!sops)
+ 		return NULL;
+ 
+-	sops->user_flash_count = m10bmc_user_flash_count;
+-	sops->bmc_root_entry_hash = m10bmc_bmc_reh;
+-	sops->sr_root_entry_hash = m10bmc_sr_reh;
+-	sops->pr_root_entry_hash = m10bmc_pr_reh;
+-	sops->bmc_canceled_csks = m10bmc_bmc_canceled_csks;
+-	sops->sr_canceled_csks = m10bmc_sr_canceled_csks;
+-	sops->pr_canceled_csks = m10bmc_pr_canceled_csks;
+-	sops->bmc_reh_size = m10bmc_bmc_reh_size;
+-	sops->sr_reh_size = m10bmc_sr_reh_size;
+-	sops->pr_reh_size = m10bmc_pr_reh_size;
+-	sops->bmc_canceled_csk_nbits = m10bmc_csk_cancel_nbits;
+-	sops->sr_canceled_csk_nbits = m10bmc_csk_cancel_nbits;
+-	sops->pr_canceled_csk_nbits = m10bmc_csk_cancel_nbits;
+ 	sops->prepare = m10bmc_sec_prepare;
+ 	sops->write_blk = m10bmc_sec_write_blk;
+ 	sops->poll_complete = m10bmc_sec_poll_complete;
+@@ -850,6 +804,7 @@ static struct platform_driver intel_m10bmc_secure_driver = {
+ 	.probe = m10bmc_secure_probe,
+ 	.driver = {
+ 		.name = "intel-m10bmc-secure",
++		.dev_groups = m10bmc_sec_attr_groups,
+ 	},
+ 	.id_table = intel_m10bmc_secure_ids,
+ };
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 3af503c24aba..3356b2ce3174 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -163,8 +163,8 @@ enum m10bmc_type {
+ #define PR_PROG_ADDR	0x17ffe000
+ #define PR_PROG_MAGIC	0x5250
+ 
+-/* Address of inverted bit vector containing user the image FLASH count */
+-#define USER_FLASH_COUNT 0x17ffb000
++/* Address of 4KB inverted bit vector containing staging area FLASH count */
++#define STAGING_FLASH_COUNT	0x17ffb000
+ 
+ /**
+  * struct intel_m10bmc_retimer_pdata - subdev retimer platform data
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0063-fpga-m10bmc-sec-fix-rsu_check_complete-criteria.patch new/debian/patches/fpga-ofs/0063-fpga-m10bmc-sec-fix-rsu_check_complete-criteria.patch
--- org/debian/patches/fpga-ofs/0063-fpga-m10bmc-sec-fix-rsu_check_complete-criteria.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0063-fpga-m10bmc-sec-fix-rsu_check_complete-criteria.patch	2021-07-20 06:17:11.428844799 +0200
@@ -0,0 +1,30 @@
+From ba400137b3da26baeba3c40229f03b6d0e021500 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 16 Feb 2021 11:42:42 -0800
+Subject: [PATCH 063/149] fpga: m10bmc-sec: fix rsu_check_complete criteria
+
+Remove the RSU_STAT_WEAROUT status condition from the check for
+a completed update. This status should not be seen during the
+authentication phase of an update, but it also does not indicate
+a successful update.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index b14e967ebe5f..a7b3fde47cda 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -349,7 +349,6 @@ static int rsu_check_complete(struct m10bmc_sec *sec, u32 *doorbell)
+ 	case RSU_STAT_NIOS_OK:
+ 	case RSU_STAT_USER_OK:
+ 	case RSU_STAT_FACTORY_OK:
+-	case RSU_STAT_WEAROUT:
+ 		break;
+ 	default:
+ 		return -EINVAL;
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0064-fpga-m10bmc-sec-fix-count-parameter-to-regmap_bulk_w.patch new/debian/patches/fpga-ofs/0064-fpga-m10bmc-sec-fix-count-parameter-to-regmap_bulk_w.patch
--- org/debian/patches/fpga-ofs/0064-fpga-m10bmc-sec-fix-count-parameter-to-regmap_bulk_w.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0064-fpga-m10bmc-sec-fix-count-parameter-to-regmap_bulk_w.patch	2021-07-20 06:17:11.428844799 +0200
@@ -0,0 +1,32 @@
+From a72e98b23173a5adc1c1ab8a8603802a5a0db28f Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 16 Feb 2021 12:02:41 -0800
+Subject: [PATCH 064/149] fpga: m10bmc-sec: fix count parameter to
+ regmap_bulk_write
+
+Fix the arithmetic for the count parameter that is passed to
+regmap_bulk_write() in the m10bmc_sec_write_blk() function.
+Ensure that the count is not off by one.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index a7b3fde47cda..82016cf5d69c 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -413,7 +413,8 @@ m10bmc_sec_write_blk(struct fpga_sec_mgr *smgr, u32 offset, u32 size)
+ 
+ 	ret = regmap_bulk_write(sec->m10bmc->regmap,
+ 				M10BMC_STAGING_BASE + offset,
+-				(void *)smgr->data + offset, size / stride);
++				(void *)smgr->data + offset,
++				(size + stride - 1) / stride);
+ 
+ 	return ret ? FPGA_SEC_ERR_RW_ERROR : FPGA_SEC_ERR_NONE;
+ }
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0065-fpga-m10bmc-sec-Add-missing-line-return-to-error-mes.patch new/debian/patches/fpga-ofs/0065-fpga-m10bmc-sec-Add-missing-line-return-to-error-mes.patch
--- org/debian/patches/fpga-ofs/0065-fpga-m10bmc-sec-Add-missing-line-return-to-error-mes.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0065-fpga-m10bmc-sec-Add-missing-line-return-to-error-mes.patch	2021-07-20 06:17:11.428844799 +0200
@@ -0,0 +1,29 @@
+From 45981cde20978c1b3d97726b3cb2a85b5c848ee6 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 16 Feb 2021 12:12:46 -0800
+Subject: [PATCH 065/149] fpga: m10bmc-sec: Add missing line-return to error
+ message
+
+Add missing line return to error message in m10bmc_secure_probe().
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 82016cf5d69c..9999bdef6e0e 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -781,7 +781,7 @@ static int m10bmc_secure_probe(struct platform_device *pdev)
+ 	smgr = devm_fpga_sec_mgr_create(sec->dev, "Max10 BMC Secure Update",
+ 					sops, sec);
+ 	if (!smgr) {
+-		dev_err(sec->dev, "Security manager failed to start");
++		dev_err(sec->dev, "Security manager failed to start\n");
+ 		return -ENOMEM;
+ 	}
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0066-mfd-intel-m10-bmc-Fix-n3000-telemetry-address-range.patch new/debian/patches/fpga-ofs/0066-mfd-intel-m10-bmc-Fix-n3000-telemetry-address-range.patch
--- org/debian/patches/fpga-ofs/0066-mfd-intel-m10-bmc-Fix-n3000-telemetry-address-range.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0066-mfd-intel-m10-bmc-Fix-n3000-telemetry-address-range.patch	2021-07-20 06:17:11.432844788 +0200
@@ -0,0 +1,46 @@
+From 45f184b3818b27ff596728c4ea2fc72c4f23a152 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 24 Feb 2021 14:22:26 -0800
+Subject: [PATCH 066/149] mfd: intel-m10-bmc: Fix n3000 telemetry address range
+
+Reduce the telemetry address range to more correctly describe the addresses
+for the telemetry registers of the N3000. Also, change the macro names to
+specifically name the N3000. The range may be different for other devices.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/mfd/intel-m10-bmc.c       | 2 +-
+ include/linux/mfd/intel-m10-bmc.h | 4 ++--
+ 2 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index c8201a5a1e84..31bad6a950d3 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -40,7 +40,7 @@ m10bmc_init_cells_platdata(struct intel_m10bmc_platdata *pdata,
+ }
+ 
+ static const struct regmap_range n3000_fw_handshake_regs[] = {
+-	regmap_reg_range(M10BMC_TELEM_START, M10BMC_TELEM_END),
++	regmap_reg_range(M10BMC_N3000_TELEM_START, M10BMC_N3000_TELEM_END),
+ };
+ 
+ int m10bmc_fw_state_enter(struct intel_m10bmc *m10bmc,
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 3356b2ce3174..3764df9e6fa4 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -81,8 +81,8 @@ enum m10bmc_type {
+ #define PKVL_PRELOAD_TIMEOUT_US		(30 * 1000 * 1000)
+ 
+ /* Telemetry registers */
+-#define M10BMC_TELEM_START		0x100
+-#define M10BMC_TELEM_END		0x33c
++#define M10BMC_N3000_TELEM_START	0x100
++#define M10BMC_N3000_TELEM_END		0x250
+ 
+ /* Secure update doorbell register, in system register region */
+ #define M10BMC_DOORBELL			0x400
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0067-mfd-intel-m10-bmc-Handle-d5005-fw-handshake-register.patch new/debian/patches/fpga-ofs/0067-mfd-intel-m10-bmc-Handle-d5005-fw-handshake-register.patch
--- org/debian/patches/fpga-ofs/0067-mfd-intel-m10-bmc-Handle-d5005-fw-handshake-register.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0067-mfd-intel-m10-bmc-Handle-d5005-fw-handshake-register.patch	2021-07-20 06:17:11.432844788 +0200
@@ -0,0 +1,113 @@
+From d847e0bf1ef2f9e413097ed4a63228021b406c8e Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 9 Feb 2021 11:58:59 -0800
+Subject: [PATCH 067/149] mfd: intel-m10-bmc: Handle d5005 fw handshake
+ registers
+
+Some of the MAX10 BMC registers can become stale if they are not
+regularly updated by the BMC firmware. The prime examples are the
+telemetry registers which require frequent updates. During a
+secure update of the FPGA or BMC images, we cause reads to these
+registers to faile with -EBUSY, because the BMC firmware cannot
+keep them up to date during a secure update.
+
+Currently, the driver only supports the n3000 telemetry register
+range. This change adds a specific range for the d5005 telemetry
+register range.
+
+- Russ
+---
+ drivers/mfd/intel-m10-bmc.c       | 21 ++++++++++++++++-----
+ include/linux/mfd/intel-m10-bmc.h |  4 ++++
+ 2 files changed, 20 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index 31bad6a950d3..555e98c2e723 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -18,6 +18,10 @@ static struct mfd_cell m10bmc_bmc_subdevs[] = {
+ 	{ .name = "d5005bmc-secure" }
+ };
+ 
++static const struct regmap_range d5005_fw_handshake_regs[] = {
++	regmap_reg_range(M10BMC_D5005_TELEM_START, M10BMC_D5005_TELEM_END),
++};
++
+ static struct mfd_cell m10bmc_pacn3000_subdevs[] = {
+ 	{ .name = "n3000bmc-hwmon" },
+ 	{ .name = "n3000bmc-retimer" },
+@@ -74,10 +78,11 @@ void m10bmc_fw_state_exit(struct intel_m10bmc *m10bmc)
+ }
+ EXPORT_SYMBOL_GPL(m10bmc_fw_state_exit);
+ 
+-static bool is_handshake_sys_reg(unsigned int offset)
++static bool is_handshake_sys_reg(struct intel_m10bmc *m10bmc,
++				 unsigned int offset)
+ {
+-	return regmap_reg_in_ranges(offset, n3000_fw_handshake_regs,
+-				    ARRAY_SIZE(n3000_fw_handshake_regs));
++	return regmap_reg_in_ranges(offset, m10bmc->handshake_sys_reg_ranges,
++				    m10bmc->handshake_sys_reg_nranges);
+ }
+ 
+ int m10bmc_sys_read(struct intel_m10bmc *m10bmc, unsigned int offset,
+@@ -85,7 +90,7 @@ int m10bmc_sys_read(struct intel_m10bmc *m10bmc, unsigned int offset,
+ {
+ 	int ret;
+ 
+-	if (!is_handshake_sys_reg(offset))
++	if (!is_handshake_sys_reg(m10bmc, offset))
+ 		return m10bmc_raw_read(m10bmc, M10BMC_SYS_BASE + (offset), val);
+ 
+ 	down_read(&m10bmc->bmcfw_lock);
+@@ -106,7 +111,7 @@ int m10bmc_sys_update_bits(struct intel_m10bmc *m10bmc, unsigned int offset,
+ {
+ 	int ret;
+ 
+-	if (!is_handshake_sys_reg(offset))
++	if (!is_handshake_sys_reg(m10bmc, offset))
+ 		return regmap_update_bits(m10bmc->regmap,
+ 					  M10BMC_SYS_BASE + (offset), msk, val);
+ 
+@@ -287,10 +292,16 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ 	case M10_N3000:
+ 		cells = m10bmc_pacn3000_subdevs;
+ 		n_cell = ARRAY_SIZE(m10bmc_pacn3000_subdevs);
++		ddata->handshake_sys_reg_ranges = n3000_fw_handshake_regs;
++		ddata->handshake_sys_reg_nranges =
++			ARRAY_SIZE(n3000_fw_handshake_regs);
+ 		break;
+ 	case M10_D5005:
+ 		cells = m10bmc_bmc_subdevs;
+ 		n_cell = ARRAY_SIZE(m10bmc_bmc_subdevs);
++		ddata->handshake_sys_reg_ranges = d5005_fw_handshake_regs;
++		ddata->handshake_sys_reg_nranges =
++			ARRAY_SIZE(d5005_fw_handshake_regs);
+ 		break;
+ 	default:
+ 		return -ENODEV;
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 3764df9e6fa4..5d8edd5bcd2d 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -83,6 +83,8 @@ enum m10bmc_type {
+ /* Telemetry registers */
+ #define M10BMC_N3000_TELEM_START	0x100
+ #define M10BMC_N3000_TELEM_END		0x250
++#define M10BMC_D5005_TELEM_START	0x100
++#define M10BMC_D5005_TELEM_END		0x300
+ 
+ /* Secure update doorbell register, in system register region */
+ #define M10BMC_DOORBELL			0x400
+@@ -195,6 +197,8 @@ struct intel_m10bmc {
+ 	struct regmap *regmap;
+ 	struct rw_semaphore bmcfw_lock;
+ 	enum m10bmc_fw_state bmcfw_state;
++	const struct regmap_range *handshake_sys_reg_ranges;
++	unsigned int handshake_sys_reg_nranges;
+ };
+ 
+ /*
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0068-Revert-REVERTME-fpga-dfl-init-needs_suppliers-after-.patch new/debian/patches/fpga-ofs/0068-Revert-REVERTME-fpga-dfl-init-needs_suppliers-after-.patch
--- org/debian/patches/fpga-ofs/0068-Revert-REVERTME-fpga-dfl-init-needs_suppliers-after-.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0068-Revert-REVERTME-fpga-dfl-init-needs_suppliers-after-.patch	2021-07-20 06:17:11.432844788 +0200
@@ -0,0 +1,35 @@
+From 69b7f854e7463e8410124e78033c15cb21914a18 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 23 Feb 2021 09:50:17 -0800
+Subject: [PATCH 068/149] Revert "REVERTME: fpga: dfl: init needs_suppliers
+ after disabling sriov"
+
+Reverting work-around for port release/assign sequence.
+This reverts commit 2e674d9274ac3f0723b1c0d0aa9f59cc9f7abc81.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl.c | 7 -------
+ 1 file changed, 7 deletions(-)
+
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index 0df3fbbbb25b..94cd53d5c922 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -1697,13 +1697,6 @@ int dfl_fpga_cdev_assign_port(struct dfl_fpga_cdev *cdev, int port_id)
+ 		goto put_dev_exit;
+ 	}
+ 
+-	/*
+-	 * HACK: See the commit message associated with the
+-	 * INIT_LIST_HEAD() line below. The long term fix
+-	 * is to create a new device structure instead of
+-	 * reviving the existing device structure.
+-	 */
+-	INIT_LIST_HEAD(&(&port_pdev->dev)->links.needs_suppliers);
+ 	ret = platform_device_add(port_pdev);
+ 	if (ret)
+ 		goto put_dev_exit;
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0069-fpga-dfl-fix-the-kernel-warning-when-release-assign-.patch new/debian/patches/fpga-ofs/0069-fpga-dfl-fix-the-kernel-warning-when-release-assign-.patch
--- org/debian/patches/fpga-ofs/0069-fpga-dfl-fix-the-kernel-warning-when-release-assign-.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0069-fpga-dfl-fix-the-kernel-warning-when-release-assign-.patch	2021-07-20 06:17:11.440844765 +0200
@@ -0,0 +1,3340 @@
+From 96c1297e8fa214fc5824eaee4533e8982a51d1d0 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Mon, 22 Feb 2021 16:48:15 +0800
+Subject: [PATCH 069/149] fpga: dfl: fix the kernel warning when release/assign
+ ports for SRIOV
+
+The dfl ports are registered as platform devices in PF mode. The port
+device should be removed from host when the user wants to configure the
+port as VF and pass through to VM. The FME dev ioctls
+DFL_FPGA_FME_PORT_RELEASE/ASSIGN are designed for this purpose.
+
+In previous implementation, the port platform device is not completely
+destroyed on port release. It is removed from system by
+platform_device_del(), but the platform device instance is retained.
+When the port assign ioctl is called, it is added back by
+platform_device_add(). It conflicts to the comments of device_add():
+"Do not call this routine more than once for any device structure",
+and will cause kernel warning at runtime.
+
+The patch tries to completely unregisters the port platform device on
+release and registers a new one on assign. But the main work is to
+remove the dependency of struct dfl_feature_platform_data for many
+internal DFL APIs. This structure holds many DFL enumeration info for
+feature devices. Many DFL APIs are expected to work with these info even
+when the port platform device is unregistered. But with the change the
+platform_data will be freed in this case. So this patch introduced a new
+structure dfl_feature_dev_data for these APIs, it acts similarly as the
+previous dfl_feature_platform_data. The dfl_feature_platform_data then
+only needs a pointer this dfl_feature_dev_data to make feature device
+driver work.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+---
+ drivers/fpga/dfl-afu-dma-region.c | 109 ++++----
+ drivers/fpga/dfl-afu-error.c      |  62 ++---
+ drivers/fpga/dfl-afu-main.c       | 254 +++++++++---------
+ drivers/fpga/dfl-afu-region.c     |  50 ++--
+ drivers/fpga/dfl-afu.h            |  26 +-
+ drivers/fpga/dfl-fme-br.c         |  24 +-
+ drivers/fpga/dfl-fme-error.c      | 101 +++----
+ drivers/fpga/dfl-fme-main.c       |  67 +++--
+ drivers/fpga/dfl-fme-pr.c         |  84 +++---
+ drivers/fpga/dfl.c                | 427 +++++++++++++++---------------
+ drivers/fpga/dfl.h                | 141 +++++-----
+ 11 files changed, 695 insertions(+), 650 deletions(-)
+
+diff --git a/drivers/fpga/dfl-afu-dma-region.c b/drivers/fpga/dfl-afu-dma-region.c
+index 84abbecfb66a..14d82cef0a04 100644
+--- a/drivers/fpga/dfl-afu-dma-region.c
++++ b/drivers/fpga/dfl-afu-dma-region.c
+@@ -16,26 +16,26 @@
+ 
+ #include "dfl-afu.h"
+ 
+-void afu_dma_region_init(struct dfl_feature_platform_data *pdata)
++void afu_dma_region_init(struct dfl_feature_dev_data *fdata)
+ {
+-	struct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);
++	struct dfl_afu *afu = dfl_fpga_fdata_get_private(fdata);
+ 
+ 	afu->dma_regions = RB_ROOT;
+ }
+ 
+ /**
+  * afu_dma_pin_pages - pin pages of given dma memory region
+- * @pdata: feature device platform data
++ * @fdata: feature dev data
+  * @region: dma memory region to be pinned
+  *
+  * Pin all the pages of given dfl_afu_dma_region.
+  * Return 0 for success or negative error code.
+  */
+-static int afu_dma_pin_pages(struct dfl_feature_platform_data *pdata,
++static int afu_dma_pin_pages(struct dfl_feature_dev_data *fdata,
+ 			     struct dfl_afu_dma_region *region)
+ {
+ 	int npages = region->length >> PAGE_SHIFT;
+-	struct device *dev = &pdata->dev->dev;
++	struct device *dev = &fdata->dev->dev;
+ 	unsigned int flags = FOLL_LONGTERM;
+ 	int ret, pinned;
+ 
+@@ -77,17 +77,17 @@ static int afu_dma_pin_pages(struct dfl_feature_platform_data *pdata,
+ 
+ /**
+  * afu_dma_unpin_pages - unpin pages of given dma memory region
+- * @pdata: feature device platform data
++ * @fdata: feature dev data
+  * @region: dma memory region to be unpinned
+  *
+  * Unpin all the pages of given dfl_afu_dma_region.
+  * Return 0 for success or negative error code.
+  */
+-static void afu_dma_unpin_pages(struct dfl_feature_platform_data *pdata,
++static void afu_dma_unpin_pages(struct dfl_feature_dev_data *fdata,
+ 				struct dfl_afu_dma_region *region)
+ {
++	struct device *dev = &fdata->dev->dev;
+ 	long npages = region->length >> PAGE_SHIFT;
+-	struct device *dev = &pdata->dev->dev;
+ 
+ 	unpin_user_pages(region->pages, npages);
+ 	kfree(region->pages);
+@@ -137,20 +137,21 @@ static bool dma_region_check_iova(struct dfl_afu_dma_region *region,
+ 
+ /**
+  * afu_dma_region_add - add given dma region to rbtree
+- * @pdata: feature device platform data
++ * @fdata: feature dev data
+  * @region: dma region to be added
+  *
+  * Return 0 for success, -EEXIST if dma region has already been added.
+  *
+  * Needs to be called with pdata->lock heold.
+  */
+-static int afu_dma_region_add(struct dfl_feature_platform_data *pdata,
++static int afu_dma_region_add(struct dfl_feature_dev_data *fdata,
+ 			      struct dfl_afu_dma_region *region)
+ {
+-	struct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);
++	struct dfl_afu *afu = dfl_fpga_fdata_get_private(fdata);
++	struct device *dev = &fdata->dev->dev;
+ 	struct rb_node **new, *parent = NULL;
+ 
+-	dev_dbg(&pdata->dev->dev, "add region (iova = %llx)\n",
++	dev_dbg(dev, "add region (iova = %llx)\n",
+ 		(unsigned long long)region->iova);
+ 
+ 	new = &afu->dma_regions.rb_node;
+@@ -181,50 +182,51 @@ static int afu_dma_region_add(struct dfl_feature_platform_data *pdata,
+ 
+ /**
+  * afu_dma_region_remove - remove given dma region from rbtree
+- * @pdata: feature device platform data
++ * @fdata: feature dev data
+  * @region: dma region to be removed
+  *
+  * Needs to be called with pdata->lock heold.
+  */
+-static void afu_dma_region_remove(struct dfl_feature_platform_data *pdata,
++static void afu_dma_region_remove(struct dfl_feature_dev_data *fdata,
+ 				  struct dfl_afu_dma_region *region)
+ {
++	struct device *dev = &fdata->dev->dev;
+ 	struct dfl_afu *afu;
+ 
+-	dev_dbg(&pdata->dev->dev, "del region (iova = %llx)\n",
++	dev_dbg(dev, "del region (iova = %llx)\n",
+ 		(unsigned long long)region->iova);
+ 
+-	afu = dfl_fpga_pdata_get_private(pdata);
++	afu = dfl_fpga_fdata_get_private(fdata);
+ 	rb_erase(&region->node, &afu->dma_regions);
+ }
+ 
+ /**
+  * afu_dma_region_destroy - destroy all regions in rbtree
+- * @pdata: feature device platform data
++ * @fdata: feature dev data
+  *
+  * Needs to be called with pdata->lock heold.
+  */
+-void afu_dma_region_destroy(struct dfl_feature_platform_data *pdata)
++void afu_dma_region_destroy(struct dfl_feature_dev_data *fdata)
+ {
+-	struct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);
++	struct dfl_afu *afu = dfl_fpga_fdata_get_private(fdata);
+ 	struct rb_node *node = rb_first(&afu->dma_regions);
+ 	struct dfl_afu_dma_region *region;
+ 
+ 	while (node) {
+ 		region = container_of(node, struct dfl_afu_dma_region, node);
+ 
+-		dev_dbg(&pdata->dev->dev, "del region (iova = %llx)\n",
++		dev_dbg(&fdata->dev->dev, "del region (iova = %llx)\n",
+ 			(unsigned long long)region->iova);
+ 
+ 		rb_erase(node, &afu->dma_regions);
+ 
+ 		if (region->iova)
+-			dma_unmap_page(dfl_fpga_pdata_to_parent(pdata),
++			dma_unmap_page(dfl_fpga_fdata_to_parent(fdata),
+ 				       region->iova, region->length,
+ 				       DMA_BIDIRECTIONAL);
+ 
+ 		if (region->pages)
+-			afu_dma_unpin_pages(pdata, region);
++			afu_dma_unpin_pages(fdata, region);
+ 
+ 		node = rb_next(node);
+ 		kfree(region);
+@@ -233,7 +235,7 @@ void afu_dma_region_destroy(struct dfl_feature_platform_data *pdata)
+ 
+ /**
+  * afu_dma_region_find - find the dma region from rbtree based on iova and size
+- * @pdata: feature device platform data
++ * @fdata: feature dev data
+  * @iova: address of the dma memory area
+  * @size: size of the dma memory area
+  *
+@@ -246,11 +248,11 @@ void afu_dma_region_destroy(struct dfl_feature_platform_data *pdata)
+  * Needs to be called with pdata->lock held.
+  */
+ struct dfl_afu_dma_region *
+-afu_dma_region_find(struct dfl_feature_platform_data *pdata, u64 iova, u64 size)
++afu_dma_region_find(struct dfl_feature_dev_data *fdata, u64 iova, u64 size)
+ {
+-	struct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);
++	struct dfl_afu *afu = dfl_fpga_fdata_get_private(fdata);
+ 	struct rb_node *node = afu->dma_regions.rb_node;
+-	struct device *dev = &pdata->dev->dev;
++	struct device *dev = &fdata->dev->dev;
+ 
+ 	while (node) {
+ 		struct dfl_afu_dma_region *region;
+@@ -280,15 +282,15 @@ afu_dma_region_find(struct dfl_feature_platform_data *pdata, u64 iova, u64 size)
+ 
+ /**
+  * afu_dma_region_find_iova - find the dma region from rbtree by iova
+- * @pdata: feature device platform data
++ * @fdata: feature dev data
+  * @iova: address of the dma region
+  *
+  * Needs to be called with pdata->lock held.
+  */
+ static struct dfl_afu_dma_region *
+-afu_dma_region_find_iova(struct dfl_feature_platform_data *pdata, u64 iova)
++afu_dma_region_find_iova(struct dfl_feature_dev_data *fdata, u64 iova)
+ {
+-	return afu_dma_region_find(pdata, iova, 0);
++	return afu_dma_region_find(fdata, iova, 0);
+ }
+ 
+ static enum dma_data_direction dma_flag_to_dir(u32 flags)
+@@ -312,7 +314,7 @@ static enum dma_data_direction dma_flag_to_dir(u32 flags)
+ 
+ /**
+  * afu_dma_map_region - map memory region for dma
+- * @pdata: feature device platform data
++ * @fdata: feature dev data
+  * @user_addr: address of the memory region
+  * @length: size of the memory region
+  * @flags: dma mapping flags
+@@ -322,9 +324,10 @@ static enum dma_data_direction dma_flag_to_dir(u32 flags)
+  * of the memory region via @iova.
+  * Return 0 for success, otherwise error code.
+  */
+-int afu_dma_map_region(struct dfl_feature_platform_data *pdata,
++int afu_dma_map_region(struct dfl_feature_dev_data *fdata,
+ 		       u64 user_addr, u64 length, u32 flags, u64 *iova)
+ {
++	struct device *dev = &fdata->dev->dev;
+ 	struct dfl_afu_dma_region *region;
+ 	int ret;
+ 
+@@ -348,47 +351,47 @@ int afu_dma_map_region(struct dfl_feature_platform_data *pdata,
+ 	region->direction = dma_flag_to_dir(flags);
+ 
+ 	/* Pin the user memory region */
+-	ret = afu_dma_pin_pages(pdata, region);
++	ret = afu_dma_pin_pages(fdata, region);
+ 	if (ret) {
+-		dev_err(&pdata->dev->dev, "failed to pin memory region\n");
++		dev_err(dev, "failed to pin memory region\n");
+ 		goto free_region;
+ 	}
+ 
+ 	/* Only accept continuous pages, return error else */
+ 	if (!afu_dma_check_continuous_pages(region)) {
+-		dev_err(&pdata->dev->dev, "pages are not continuous\n");
++		dev_err(dev, "pages are not continuous\n");
+ 		ret = -EINVAL;
+ 		goto unpin_pages;
+ 	}
+ 
+ 	/* As pages are continuous then start to do DMA mapping */
+-	region->iova = dma_map_page(dfl_fpga_pdata_to_parent(pdata),
++	region->iova = dma_map_page(dfl_fpga_fdata_to_parent(fdata),
+ 				    region->pages[0], 0,
+ 				    region->length,
+ 				    region->direction);
+-	if (dma_mapping_error(dfl_fpga_pdata_to_parent(pdata), region->iova)) {
+-		dev_err(&pdata->dev->dev, "failed to map for dma\n");
++	if (dma_mapping_error(dfl_fpga_fdata_to_parent(fdata), region->iova)) {
++		dev_err(dev, "failed to map for dma\n");
+ 		ret = -EFAULT;
+ 		goto unpin_pages;
+ 	}
+ 
+ 	*iova = region->iova;
+ 
+-	mutex_lock(&pdata->lock);
+-	ret = afu_dma_region_add(pdata, region);
+-	mutex_unlock(&pdata->lock);
++	mutex_lock(&fdata->lock);
++	ret = afu_dma_region_add(fdata, region);
++	mutex_unlock(&fdata->lock);
+ 	if (ret) {
+-		dev_err(&pdata->dev->dev, "failed to add dma region\n");
++		dev_err(dev, "failed to add dma region\n");
+ 		goto unmap_dma;
+ 	}
+ 
+ 	return 0;
+ 
+ unmap_dma:
+-	dma_unmap_page(dfl_fpga_pdata_to_parent(pdata),
++	dma_unmap_page(dfl_fpga_fdata_to_parent(fdata),
+ 		       region->iova, region->length, region->direction);
+ unpin_pages:
+-	afu_dma_unpin_pages(pdata, region);
++	afu_dma_unpin_pages(fdata, region);
+ free_region:
+ 	kfree(region);
+ 	return ret;
+@@ -396,34 +399,34 @@ int afu_dma_map_region(struct dfl_feature_platform_data *pdata,
+ 
+ /**
+  * afu_dma_unmap_region - unmap dma memory region
+- * @pdata: feature device platform data
++ * @fdata: feature dev data
+  * @iova: dma address of the region
+  *
+  * Unmap dma memory region based on @iova.
+  * Return 0 for success, otherwise error code.
+  */
+-int afu_dma_unmap_region(struct dfl_feature_platform_data *pdata, u64 iova)
++int afu_dma_unmap_region(struct dfl_feature_dev_data *fdata, u64 iova)
+ {
+ 	struct dfl_afu_dma_region *region;
+ 
+-	mutex_lock(&pdata->lock);
+-	region = afu_dma_region_find_iova(pdata, iova);
++	mutex_lock(&fdata->lock);
++	region = afu_dma_region_find_iova(fdata, iova);
+ 	if (!region) {
+-		mutex_unlock(&pdata->lock);
++		mutex_unlock(&fdata->lock);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (region->in_use) {
+-		mutex_unlock(&pdata->lock);
++		mutex_unlock(&fdata->lock);
+ 		return -EBUSY;
+ 	}
+ 
+-	afu_dma_region_remove(pdata, region);
+-	mutex_unlock(&pdata->lock);
++	afu_dma_region_remove(fdata, region);
++	mutex_unlock(&fdata->lock);
+ 
+-	dma_unmap_page(dfl_fpga_pdata_to_parent(pdata),
++	dma_unmap_page(dfl_fpga_fdata_to_parent(fdata),
+ 		       region->iova, region->length, region->direction);
+-	afu_dma_unpin_pages(pdata, region);
++	afu_dma_unpin_pages(fdata, region);
+ 	kfree(region);
+ 
+ 	return 0;
+diff --git a/drivers/fpga/dfl-afu-error.c b/drivers/fpga/dfl-afu-error.c
+index 230b1085f55a..4820ca3a837c 100644
+--- a/drivers/fpga/dfl-afu-error.c
++++ b/drivers/fpga/dfl-afu-error.c
+@@ -28,37 +28,36 @@
+ #define ERROR_MASK		GENMASK_ULL(63, 0)
+ 
+ /* mask or unmask port errors by the error mask register. */
+-static void __afu_port_err_mask(struct device *dev, bool mask)
++static void __afu_port_err_mask(struct dfl_feature_dev_data *fdata, bool mask)
+ {
+ 	void __iomem *base;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_ERROR);
+ 
+ 	writeq(mask ? ERROR_MASK : 0, base + PORT_ERROR_MASK);
+ }
+ 
+ static void afu_port_err_mask(struct device *dev, bool mask)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 
+-	mutex_lock(&pdata->lock);
+-	__afu_port_err_mask(dev, mask);
+-	mutex_unlock(&pdata->lock);
++	mutex_lock(&fdata->lock);
++	__afu_port_err_mask(fdata, mask);
++	mutex_unlock(&fdata->lock);
+ }
+ 
+ /* clear port errors. */
+ static int afu_port_err_clear(struct device *dev, u64 err)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
+-	struct platform_device *pdev = to_platform_device(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base_err, *base_hdr;
+ 	int ret = -EBUSY;
+ 	u64 v;
+ 
+-	base_err = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);
+-	base_hdr = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base_err = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_ERROR);
++	base_hdr = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 
+ 	/*
+ 	 * clear Port Errors
+@@ -80,12 +79,12 @@ static int afu_port_err_clear(struct device *dev, u64 err)
+ 	}
+ 
+ 	/* Halt Port by keeping Port in reset */
+-	ret = __afu_port_disable(pdev);
++	ret = __afu_port_disable(fdata);
+ 	if (ret)
+ 		goto done;
+ 
+ 	/* Mask all errors */
+-	__afu_port_err_mask(dev, true);
++	__afu_port_err_mask(fdata, true);
+ 
+ 	/* Clear errors if err input matches with current port errors.*/
+ 	v = readq(base_err + PORT_ERROR);
+@@ -100,28 +99,28 @@ static int afu_port_err_clear(struct device *dev, u64 err)
+ 	}
+ 
+ 	/* Clear mask */
+-	__afu_port_err_mask(dev, false);
++	__afu_port_err_mask(fdata, false);
+ 
+ 	/* Enable the Port by clear the reset */
+-	ret = __afu_port_enable(pdev);
++	ret = __afu_port_enable(fdata);
+ 
+ done:
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 	return ret;
+ }
+ 
+ static ssize_t errors_show(struct device *dev, struct device_attribute *attr,
+ 			   char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 error;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_ERROR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	error = readq(base + PORT_ERROR);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%llx\n", (unsigned long long)error);
+ }
+@@ -144,15 +143,15 @@ static DEVICE_ATTR_RW(errors);
+ static ssize_t first_error_show(struct device *dev,
+ 				struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 error;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_ERROR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	error = readq(base + PORT_FIRST_ERROR);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%llx\n", (unsigned long long)error);
+ }
+@@ -162,16 +161,16 @@ static ssize_t first_malformed_req_show(struct device *dev,
+ 					struct device_attribute *attr,
+ 					char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 req0, req1;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_ERROR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	req0 = readq(base + PORT_MALFORMED_REQ0);
+ 	req1 = readq(base + PORT_MALFORMED_REQ1);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%016llx%016llx\n",
+ 		       (unsigned long long)req1, (unsigned long long)req0);
+@@ -180,10 +179,11 @@ static DEVICE_ATTR_RO(first_malformed_req);
+ 
+ static ssize_t revision_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 dfh;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_ERROR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_ERROR);
+ 
+ 	dfh = readq(base);
+ 
+@@ -203,12 +203,14 @@ static umode_t port_err_attrs_visible(struct kobject *kobj,
+ 				      struct attribute *attr, int n)
+ {
+ 	struct device *dev = kobj_to_dev(kobj);
++	struct dfl_feature_dev_data *fdata;
+ 
++	fdata = to_dfl_feature_dev_data(dev);
+ 	/*
+ 	 * sysfs entries are visible only if related private feature is
+ 	 * enumerated.
+ 	 */
+-	if (!dfl_get_feature_by_id(dev, PORT_FEATURE_ID_ERROR))
++	if (!dfl_get_feature_by_id(fdata, PORT_FEATURE_ID_ERROR))
+ 		return 0;
+ 
+ 	return attr->mode;
+diff --git a/drivers/fpga/dfl-afu-main.c b/drivers/fpga/dfl-afu-main.c
+index b56d6a0ce7bd..4211cf3acb8a 100644
+--- a/drivers/fpga/dfl-afu-main.c
++++ b/drivers/fpga/dfl-afu-main.c
+@@ -26,7 +26,7 @@
+ 
+ /**
+  * __afu_port_enable - enable a port by clear reset
+- * @pdev: port platform device.
++ * @fdata: port feature dev data.
+  *
+  * Enable Port by clear the port soft reset bit, which is set by default.
+  * The AFU is unable to respond to any MMIO access while in reset.
+@@ -35,18 +35,17 @@
+  *
+  * The caller needs to hold lock for protection.
+  */
+-int __afu_port_enable(struct platform_device *pdev)
++int __afu_port_enable(struct dfl_feature_dev_data *fdata)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	WARN_ON(!pdata->disable_count);
++	WARN_ON(!fdata->disable_count);
+ 
+-	if (--pdata->disable_count != 0)
++	if (--fdata->disable_count != 0)
+ 		return 0;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(&pdev->dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+ 	/* Clear port soft reset */
+ 	v = readq(base + PORT_HDR_CTRL);
+@@ -60,7 +59,8 @@ int __afu_port_enable(struct platform_device *pdev)
+ 	if (readq_poll_timeout(base + PORT_HDR_CTRL, v,
+ 			       !(v & PORT_CTRL_SFTRST_ACK),
+ 			       RST_POLL_INVL, RST_POLL_TIMEOUT)) {
+-		dev_err(&pdev->dev, "timeout, failure to enable device\n");
++		dev_err(fdata->dfl_cdev->parent,
++			"timeout, failure to enable device\n");
+ 		return -ETIMEDOUT;
+ 	}
+ 
+@@ -69,22 +69,21 @@ int __afu_port_enable(struct platform_device *pdev)
+ 
+ /**
+  * __afu_port_disable - disable a port by hold reset
+- * @pdev: port platform device.
++ * @fdata: port feature dev data.
+  *
+  * Disable Port by setting the port soft reset bit, it puts the port into reset.
+  *
+  * The caller needs to hold lock for protection.
+  */
+-int __afu_port_disable(struct platform_device *pdev)
++int __afu_port_disable(struct dfl_feature_dev_data *fdata)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	if (pdata->disable_count++ != 0)
++	if (fdata->disable_count++ != 0)
+ 		return 0;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(&pdev->dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+ 	/* Set port soft reset */
+ 	v = readq(base + PORT_HDR_CTRL);
+@@ -99,7 +98,8 @@ int __afu_port_disable(struct platform_device *pdev)
+ 	if (readq_poll_timeout(base + PORT_HDR_CTRL, v,
+ 			       v & PORT_CTRL_SFTRST_ACK,
+ 			       RST_POLL_INVL, RST_POLL_TIMEOUT)) {
+-		dev_err(&pdev->dev, "timeout, fail to reset device\n");
++		dev_err(fdata->dfl_cdev->parent,
++			"timeout, fail to reset device\n");
+ 		return -ETIMEDOUT;
+ 	}
+ 
+@@ -118,34 +118,36 @@ int __afu_port_disable(struct platform_device *pdev)
+  * (disabled). Any attempts on MMIO access to AFU while in reset, will
+  * result errors reported via port error reporting sub feature (if present).
+  */
+-static int __port_reset(struct platform_device *pdev)
++static int __port_reset(struct dfl_feature_dev_data *fdata)
+ {
+ 	int ret;
+ 
+-	ret = __afu_port_disable(pdev);
++	ret = __afu_port_disable(fdata);
+ 	if (!ret)
+-		ret = __afu_port_enable(pdev);
++		ret = __afu_port_enable(fdata);
+ 
+ 	return ret;
+ }
+ 
+ static int port_reset(struct platform_device *pdev)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata;
+ 	int ret;
+ 
+-	mutex_lock(&pdata->lock);
+-	ret = __port_reset(pdev);
+-	mutex_unlock(&pdata->lock);
++	fdata = to_dfl_feature_dev_data(&pdev->dev);
++
++	mutex_lock(&fdata->lock);
++	ret = __port_reset(fdata);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return ret;
+ }
+ 
+-static int port_get_id(struct platform_device *pdev)
++static int port_get_id(struct dfl_feature_dev_data *fdata)
+ {
+ 	void __iomem *base;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(&pdev->dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+ 	return FIELD_GET(PORT_CAP_PORT_NUM, readq(base + PORT_HDR_CAP));
+ }
+@@ -153,7 +155,8 @@ static int port_get_id(struct platform_device *pdev)
+ static ssize_t
+ id_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+-	int id = port_get_id(to_platform_device(dev));
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
++	int id = port_get_id(fdata);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%d\n", id);
+ }
+@@ -162,15 +165,15 @@ static DEVICE_ATTR_RO(id);
+ static ssize_t
+ ltr_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	v = readq(base + PORT_HDR_CTRL);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "%x\n", (u8)FIELD_GET(PORT_CTRL_LATENCY, v));
+ }
+@@ -179,7 +182,7 @@ static ssize_t
+ ltr_store(struct device *dev, struct device_attribute *attr,
+ 	  const char *buf, size_t count)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	bool ltr;
+ 	u64 v;
+@@ -187,14 +190,14 @@ ltr_store(struct device *dev, struct device_attribute *attr,
+ 	if (kstrtobool(buf, &ltr))
+ 		return -EINVAL;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	v = readq(base + PORT_HDR_CTRL);
+ 	v &= ~PORT_CTRL_LATENCY;
+ 	v |= FIELD_PREP(PORT_CTRL_LATENCY, ltr ? 1 : 0);
+ 	writeq(v, base + PORT_HDR_CTRL);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return count;
+ }
+@@ -203,15 +206,15 @@ static DEVICE_ATTR_RW(ltr);
+ static ssize_t
+ ap1_event_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	v = readq(base + PORT_HDR_STS);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "%x\n", (u8)FIELD_GET(PORT_STS_AP1_EVT, v));
+ }
+@@ -220,18 +223,18 @@ static ssize_t
+ ap1_event_store(struct device *dev, struct device_attribute *attr,
+ 		const char *buf, size_t count)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	bool clear;
+ 
+ 	if (kstrtobool(buf, &clear) || !clear)
+ 		return -EINVAL;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	writeq(PORT_STS_AP1_EVT, base + PORT_HDR_STS);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return count;
+ }
+@@ -241,15 +244,15 @@ static ssize_t
+ ap2_event_show(struct device *dev, struct device_attribute *attr,
+ 	       char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	v = readq(base + PORT_HDR_STS);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "%x\n", (u8)FIELD_GET(PORT_STS_AP2_EVT, v));
+ }
+@@ -258,18 +261,18 @@ static ssize_t
+ ap2_event_store(struct device *dev, struct device_attribute *attr,
+ 		const char *buf, size_t count)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	bool clear;
+ 
+ 	if (kstrtobool(buf, &clear) || !clear)
+ 		return -EINVAL;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	writeq(PORT_STS_AP2_EVT, base + PORT_HDR_STS);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return count;
+ }
+@@ -278,15 +281,15 @@ static DEVICE_ATTR_RW(ap2_event);
+ static ssize_t
+ power_state_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	v = readq(base + PORT_HDR_STS);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%x\n", (u8)FIELD_GET(PORT_STS_PWR_STATE, v));
+ }
+@@ -296,18 +299,18 @@ static ssize_t
+ userclk_freqcmd_store(struct device *dev, struct device_attribute *attr,
+ 		      const char *buf, size_t count)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	u64 userclk_freq_cmd;
+ 	void __iomem *base;
+ 
+ 	if (kstrtou64(buf, 0, &userclk_freq_cmd))
+ 		return -EINVAL;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	writeq(userclk_freq_cmd, base + PORT_HDR_USRCLK_CMD0);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return count;
+ }
+@@ -317,18 +320,18 @@ static ssize_t
+ userclk_freqcntrcmd_store(struct device *dev, struct device_attribute *attr,
+ 			  const char *buf, size_t count)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	u64 userclk_freqcntr_cmd;
+ 	void __iomem *base;
+ 
+ 	if (kstrtou64(buf, 0, &userclk_freqcntr_cmd))
+ 		return -EINVAL;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	writeq(userclk_freqcntr_cmd, base + PORT_HDR_USRCLK_CMD1);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return count;
+ }
+@@ -338,15 +341,15 @@ static ssize_t
+ userclk_freqsts_show(struct device *dev, struct device_attribute *attr,
+ 		     char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	u64 userclk_freqsts;
+ 	void __iomem *base;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	userclk_freqsts = readq(base + PORT_HDR_USRCLK_STS0);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%llx\n", (unsigned long long)userclk_freqsts);
+ }
+@@ -356,15 +359,15 @@ static ssize_t
+ userclk_freqcntrsts_show(struct device *dev, struct device_attribute *attr,
+ 			 char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	u64 userclk_freqcntrsts;
+ 	void __iomem *base;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	userclk_freqcntrsts = readq(base + PORT_HDR_USRCLK_STS1);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%llx\n",
+ 		       (unsigned long long)userclk_freqcntrsts);
+@@ -388,10 +391,12 @@ static umode_t port_hdr_attrs_visible(struct kobject *kobj,
+ 				      struct attribute *attr, int n)
+ {
+ 	struct device *dev = kobj_to_dev(kobj);
++	struct dfl_feature_dev_data *fdata;
+ 	umode_t mode = attr->mode;
+ 	void __iomem *base;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_HEADER);
++	fdata = to_dfl_feature_dev_data(dev);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+ 	if (dfl_feature_revision(base) > 0) {
+ 		/*
+@@ -456,21 +461,21 @@ static const struct dfl_feature_ops port_hdr_ops = {
+ static ssize_t
+ afu_id_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 guidl, guidh;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, PORT_FEATURE_ID_AFU);
++	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_AFU);
+ 
+-	mutex_lock(&pdata->lock);
+-	if (pdata->disable_count) {
+-		mutex_unlock(&pdata->lock);
++	mutex_lock(&fdata->lock);
++	if (fdata->disable_count) {
++		mutex_unlock(&fdata->lock);
+ 		return -EBUSY;
+ 	}
+ 
+ 	guidl = readq(base + GUID_L);
+ 	guidh = readq(base + GUID_H);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return scnprintf(buf, PAGE_SIZE, "%016llx%016llx\n", guidh, guidl);
+ }
+@@ -485,12 +490,15 @@ static umode_t port_afu_attrs_visible(struct kobject *kobj,
+ 				      struct attribute *attr, int n)
+ {
+ 	struct device *dev = kobj_to_dev(kobj);
++	struct dfl_feature_dev_data *fdata;
++
++	fdata = to_dfl_feature_dev_data(dev);
+ 
+ 	/*
+ 	 * sysfs entries are visible only if related private feature is
+ 	 * enumerated.
+ 	 */
+-	if (!dfl_get_feature_by_id(dev, PORT_FEATURE_ID_AFU))
++	if (!dfl_get_feature_by_id(fdata, PORT_FEATURE_ID_AFU))
+ 		return 0;
+ 
+ 	return attr->mode;
+@@ -504,9 +512,11 @@ static const struct attribute_group port_afu_group = {
+ static int port_afu_init(struct platform_device *pdev,
+ 			 struct dfl_feature *feature)
+ {
++	struct dfl_feature_dev_data *fdata =
++					to_dfl_feature_dev_data(&pdev->dev);
+ 	struct resource *res = &pdev->resource[feature->resource_index];
+ 
+-	return afu_mmio_region_add(dev_get_platdata(&pdev->dev),
++	return afu_mmio_region_add(fdata,
+ 				   DFL_PORT_REGION_INDEX_AFU,
+ 				   resource_size(res), res->start,
+ 				   DFL_PORT_REGION_MMAP | DFL_PORT_REGION_READ |
+@@ -525,9 +535,11 @@ static const struct dfl_feature_ops port_afu_ops = {
+ static int port_stp_init(struct platform_device *pdev,
+ 			 struct dfl_feature *feature)
+ {
++	struct dfl_feature_dev_data *fdata =
++					to_dfl_feature_dev_data(&pdev->dev);
+ 	struct resource *res = &pdev->resource[feature->resource_index];
+ 
+-	return afu_mmio_region_add(dev_get_platdata(&pdev->dev),
++	return afu_mmio_region_add(fdata,
+ 				   DFL_PORT_REGION_INDEX_STP,
+ 				   resource_size(res), res->start,
+ 				   DFL_PORT_REGION_MMAP | DFL_PORT_REGION_READ |
+@@ -596,21 +608,19 @@ static struct dfl_feature_driver port_feature_drvs[] = {
+ static int afu_open(struct inode *inode, struct file *filp)
+ {
+ 	struct platform_device *fdev = dfl_fpga_inode_to_feature_dev(inode);
+-	struct dfl_feature_platform_data *pdata;
++	struct dfl_feature_dev_data *fdata;
+ 	int ret;
+ 
+-	pdata = dev_get_platdata(&fdev->dev);
+-	if (WARN_ON(!pdata))
+-		return -ENODEV;
++	fdata = to_dfl_feature_dev_data(&fdev->dev);
+ 
+-	mutex_lock(&pdata->lock);
+-	ret = dfl_feature_dev_use_begin(pdata, filp->f_flags & O_EXCL);
++	mutex_lock(&fdata->lock);
++	ret = dfl_feature_dev_use_begin(fdata, filp->f_flags & O_EXCL);
+ 	if (!ret) {
+ 		dev_dbg(&fdev->dev, "Device File Opened %d Times\n",
+-			dfl_feature_dev_use_count(pdata));
++			dfl_feature_dev_use_count(fdata));
+ 		filp->private_data = fdev;
+ 	}
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return ret;
+ }
+@@ -618,24 +628,24 @@ static int afu_open(struct inode *inode, struct file *filp)
+ static int afu_release(struct inode *inode, struct file *filp)
+ {
+ 	struct platform_device *pdev = filp->private_data;
+-	struct dfl_feature_platform_data *pdata;
++	struct dfl_feature_dev_data *fdata;
+ 	struct dfl_feature *feature;
+ 
+ 	dev_dbg(&pdev->dev, "Device File Release\n");
+ 
+-	pdata = dev_get_platdata(&pdev->dev);
++	fdata = to_dfl_feature_dev_data(&pdev->dev);
+ 
+-	mutex_lock(&pdata->lock);
+-	dfl_feature_dev_use_end(pdata);
++	mutex_lock(&fdata->lock);
++	dfl_feature_dev_use_end(fdata);
+ 
+-	if (!dfl_feature_dev_use_count(pdata)) {
+-		dfl_fpga_dev_for_each_feature(pdata, feature)
++	if (!dfl_feature_dev_use_count(fdata)) {
++		dfl_fpga_dev_for_each_feature(fdata, feature)
+ 			dfl_fpga_set_irq_triggers(feature, 0,
+ 						  feature->nr_irqs, NULL);
+-		__port_reset(pdev);
+-		afu_dma_region_destroy(pdata);
++		__port_reset(fdata);
++		afu_dma_region_destroy(fdata);
+ 	}
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return 0;
+ }
+@@ -650,6 +660,7 @@ static long afu_ioctl_check_extension(struct dfl_feature_platform_data *pdata,
+ static long
+ afu_ioctl_get_info(struct dfl_feature_platform_data *pdata, void __user *arg)
+ {
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
+ 	struct dfl_fpga_port_info info;
+ 	struct dfl_afu *afu;
+ 	unsigned long minsz;
+@@ -662,12 +673,12 @@ afu_ioctl_get_info(struct dfl_feature_platform_data *pdata, void __user *arg)
+ 	if (info.argsz < minsz)
+ 		return -EINVAL;
+ 
+-	mutex_lock(&pdata->lock);
+-	afu = dfl_fpga_pdata_get_private(pdata);
++	mutex_lock(&fdata->lock);
++	afu = dfl_fpga_fdata_get_private(fdata);
+ 	info.flags = 0;
+ 	info.num_regions = afu->num_regions;
+ 	info.num_umsgs = afu->num_umsgs;
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	if (copy_to_user(arg, &info, sizeof(info)))
+ 		return -EFAULT;
+@@ -691,7 +702,7 @@ static long afu_ioctl_get_region_info(struct dfl_feature_platform_data *pdata,
+ 	if (rinfo.argsz < minsz || rinfo.padding)
+ 		return -EINVAL;
+ 
+-	ret = afu_mmio_region_get_by_index(pdata, rinfo.index, &region);
++	ret = afu_mmio_region_get_by_index(pdata->fdata, rinfo.index, &region);
+ 	if (ret)
+ 		return ret;
+ 
+@@ -709,6 +720,7 @@ static long
+ afu_ioctl_dma_map(struct dfl_feature_platform_data *pdata, void __user *arg)
+ {
+ 	u32 dma_mask = DFL_DMA_MAP_FLAG_READ | DFL_DMA_MAP_FLAG_WRITE;
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
+ 	struct dfl_fpga_port_dma_map map;
+ 	unsigned long minsz;
+ 	long ret;
+@@ -721,17 +733,17 @@ afu_ioctl_dma_map(struct dfl_feature_platform_data *pdata, void __user *arg)
+ 	if (map.argsz < minsz || map.flags & ~dma_mask)
+ 		return -EINVAL;
+ 
+-	ret = afu_dma_map_region(pdata, map.user_addr, map.length, map.flags,
++	ret = afu_dma_map_region(fdata, map.user_addr, map.length, map.flags,
+ 				 &map.iova);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (copy_to_user(arg, &map, sizeof(map))) {
+-		afu_dma_unmap_region(pdata, map.iova);
++		afu_dma_unmap_region(fdata, map.iova);
+ 		return -EFAULT;
+ 	}
+ 
+-	dev_dbg(&pdata->dev->dev, "dma map: ua=%llx, len=%llx, iova=%llx\n",
++	dev_dbg(&fdata->dev->dev, "dma map: ua=%llx, len=%llx, iova=%llx\n",
+ 		(unsigned long long)map.user_addr,
+ 		(unsigned long long)map.length,
+ 		(unsigned long long)map.iova);
+@@ -753,7 +765,7 @@ afu_ioctl_dma_unmap(struct dfl_feature_platform_data *pdata, void __user *arg)
+ 	if (unmap.argsz < minsz || unmap.flags)
+ 		return -EINVAL;
+ 
+-	return afu_dma_unmap_region(pdata, unmap.iova);
++	return afu_dma_unmap_region(pdata->fdata, unmap.iova);
+ }
+ 
+ static long afu_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+@@ -787,7 +799,7 @@ static long afu_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+ 		 * handled in this sub feature, and returns 0 and other
+ 		 * error code if cmd is handled.
+ 		 */
+-		dfl_fpga_dev_for_each_feature(pdata, f)
++		dfl_fpga_dev_for_each_feature(pdata->fdata, f)
+ 			if (f->ops && f->ops->ioctl) {
+ 				ret = f->ops->ioctl(pdev, f, cmd, arg);
+ 				if (ret != -ENODEV)
+@@ -819,7 +831,8 @@ static int afu_mmap(struct file *filp, struct vm_area_struct *vma)
+ 	pdata = dev_get_platdata(&pdev->dev);
+ 
+ 	offset = vma->vm_pgoff << PAGE_SHIFT;
+-	ret = afu_mmio_region_get_by_offset(pdata, offset, size, &region);
++	ret = afu_mmio_region_get_by_offset(pdata->fdata, offset, size,
++					    &region);
+ 	if (ret)
+ 		return ret;
+ 
+@@ -854,6 +867,7 @@ static const struct file_operations afu_fops = {
+ static int afu_dev_init(struct platform_device *pdev)
+ {
+ 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
+ 	struct dfl_afu *afu;
+ 
+ 	afu = devm_kzalloc(&pdev->dev, sizeof(*afu), GFP_KERNEL);
+@@ -862,11 +876,11 @@ static int afu_dev_init(struct platform_device *pdev)
+ 
+ 	afu->pdata = pdata;
+ 
+-	mutex_lock(&pdata->lock);
+-	dfl_fpga_pdata_set_private(pdata, afu);
+-	afu_mmio_region_init(pdata);
+-	afu_dma_region_init(pdata);
+-	mutex_unlock(&pdata->lock);
++	mutex_lock(&fdata->lock);
++	dfl_fpga_fdata_set_private(fdata, afu);
++	afu_mmio_region_init(fdata);
++	afu_dma_region_init(fdata);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return 0;
+ }
+@@ -874,27 +888,27 @@ static int afu_dev_init(struct platform_device *pdev)
+ static int afu_dev_destroy(struct platform_device *pdev)
+ {
+ 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
+ 
+-	mutex_lock(&pdata->lock);
+-	afu_mmio_region_destroy(pdata);
+-	afu_dma_region_destroy(pdata);
+-	dfl_fpga_pdata_set_private(pdata, NULL);
+-	mutex_unlock(&pdata->lock);
++	mutex_lock(&fdata->lock);
++	afu_mmio_region_destroy(fdata);
++	afu_dma_region_destroy(fdata);
++	dfl_fpga_fdata_set_private(fdata, NULL);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return 0;
+ }
+ 
+-static int port_enable_set(struct platform_device *pdev, bool enable)
++static int port_enable_set(struct dfl_feature_dev_data *fdata, bool enable)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
+ 	int ret;
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	if (enable)
+-		ret = __afu_port_enable(pdev);
++		ret = __afu_port_enable(fdata);
+ 	else
+-		ret = __afu_port_disable(pdev);
+-	mutex_unlock(&pdata->lock);
++		ret = __afu_port_disable(fdata);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return ret;
+ }
+diff --git a/drivers/fpga/dfl-afu-region.c b/drivers/fpga/dfl-afu-region.c
+index 0804b7a0c298..b11a5b21e666 100644
+--- a/drivers/fpga/dfl-afu-region.c
++++ b/drivers/fpga/dfl-afu-region.c
+@@ -12,11 +12,11 @@
+ 
+ /**
+  * afu_mmio_region_init - init function for afu mmio region support
+- * @pdata: afu platform device's pdata.
++ * @fdata: afu feature dev data
+  */
+-void afu_mmio_region_init(struct dfl_feature_platform_data *pdata)
++void afu_mmio_region_init(struct dfl_feature_dev_data *fdata)
+ {
+-	struct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);
++	struct dfl_afu *afu = dfl_fpga_fdata_get_private(fdata);
+ 
+ 	INIT_LIST_HEAD(&afu->regions);
+ }
+@@ -39,6 +39,7 @@ static struct dfl_afu_mmio_region *get_region_by_index(struct dfl_afu *afu,
+ /**
+  * afu_mmio_region_add - add a mmio region to given feature dev.
+  *
++ * @fdata: afu feature dev data
+  * @region_index: region index.
+  * @region_size: region size.
+  * @phys: region's physical address of this region.
+@@ -46,14 +47,15 @@ static struct dfl_afu_mmio_region *get_region_by_index(struct dfl_afu *afu,
+  *
+  * Return: 0 on success, negative error code otherwise.
+  */
+-int afu_mmio_region_add(struct dfl_feature_platform_data *pdata,
++int afu_mmio_region_add(struct dfl_feature_dev_data *fdata,
+ 			u32 region_index, u64 region_size, u64 phys, u32 flags)
+ {
++	struct device *dev = &fdata->dev->dev;
+ 	struct dfl_afu_mmio_region *region;
+ 	struct dfl_afu *afu;
+ 	int ret = 0;
+ 
+-	region = devm_kzalloc(&pdata->dev->dev, sizeof(*region), GFP_KERNEL);
++	region = devm_kzalloc(dev, sizeof(*region), GFP_KERNEL);
+ 	if (!region)
+ 		return -ENOMEM;
+ 
+@@ -62,13 +64,13 @@ int afu_mmio_region_add(struct dfl_feature_platform_data *pdata,
+ 	region->phys = phys;
+ 	region->flags = flags;
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 
+-	afu = dfl_fpga_pdata_get_private(pdata);
++	afu = dfl_fpga_fdata_get_private(fdata);
+ 
+ 	/* check if @index already exists */
+ 	if (get_region_by_index(afu, region_index)) {
+-		mutex_unlock(&pdata->lock);
++		mutex_unlock(&fdata->lock);
+ 		ret = -EEXIST;
+ 		goto exit;
+ 	}
+@@ -79,37 +81,37 @@ int afu_mmio_region_add(struct dfl_feature_platform_data *pdata,
+ 
+ 	afu->region_cur_offset += region_size;
+ 	afu->num_regions++;
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return 0;
+ 
+ exit:
+-	devm_kfree(&pdata->dev->dev, region);
++	devm_kfree(dev, region);
+ 	return ret;
+ }
+ 
+ /**
+  * afu_mmio_region_destroy - destroy all mmio regions under given feature dev.
+- * @pdata: afu platform device's pdata.
++ * @fdata: afu feature dev data
+  */
+-void afu_mmio_region_destroy(struct dfl_feature_platform_data *pdata)
++void afu_mmio_region_destroy(struct dfl_feature_dev_data *fdata)
+ {
+-	struct dfl_afu *afu = dfl_fpga_pdata_get_private(pdata);
++	struct dfl_afu *afu = dfl_fpga_fdata_get_private(fdata);
+ 	struct dfl_afu_mmio_region *tmp, *region;
+ 
+ 	list_for_each_entry_safe(region, tmp, &afu->regions, node)
+-		devm_kfree(&pdata->dev->dev, region);
++		devm_kfree(&fdata->dev->dev, region);
+ }
+ 
+ /**
+  * afu_mmio_region_get_by_index - find an afu region by index.
+- * @pdata: afu platform device's pdata.
++ * @fdata: afu feature dev data
+  * @region_index: region index.
+  * @pregion: ptr to region for result.
+  *
+  * Return: 0 on success, negative error code otherwise.
+  */
+-int afu_mmio_region_get_by_index(struct dfl_feature_platform_data *pdata,
++int afu_mmio_region_get_by_index(struct dfl_feature_dev_data *fdata,
+ 				 u32 region_index,
+ 				 struct dfl_afu_mmio_region *pregion)
+ {
+@@ -117,8 +119,8 @@ int afu_mmio_region_get_by_index(struct dfl_feature_platform_data *pdata,
+ 	struct dfl_afu *afu;
+ 	int ret = 0;
+ 
+-	mutex_lock(&pdata->lock);
+-	afu = dfl_fpga_pdata_get_private(pdata);
++	mutex_lock(&fdata->lock);
++	afu = dfl_fpga_fdata_get_private(fdata);
+ 	region = get_region_by_index(afu, region_index);
+ 	if (!region) {
+ 		ret = -EINVAL;
+@@ -126,14 +128,14 @@ int afu_mmio_region_get_by_index(struct dfl_feature_platform_data *pdata,
+ 	}
+ 	*pregion = *region;
+ exit:
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 	return ret;
+ }
+ 
+ /**
+  * afu_mmio_region_get_by_offset - find an afu mmio region by offset and size
+  *
+- * @pdata: afu platform device's pdata.
++ * @fdata: afu feature dev data
+  * @offset: region offset from start of the device fd.
+  * @size: region size.
+  * @pregion: ptr to region for result.
+@@ -143,7 +145,7 @@ int afu_mmio_region_get_by_index(struct dfl_feature_platform_data *pdata,
+  *
+  * Return: 0 on success, negative error code otherwise.
+  */
+-int afu_mmio_region_get_by_offset(struct dfl_feature_platform_data *pdata,
++int afu_mmio_region_get_by_offset(struct dfl_feature_dev_data *fdata,
+ 				  u64 offset, u64 size,
+ 				  struct dfl_afu_mmio_region *pregion)
+ {
+@@ -151,8 +153,8 @@ int afu_mmio_region_get_by_offset(struct dfl_feature_platform_data *pdata,
+ 	struct dfl_afu *afu;
+ 	int ret = 0;
+ 
+-	mutex_lock(&pdata->lock);
+-	afu = dfl_fpga_pdata_get_private(pdata);
++	mutex_lock(&fdata->lock);
++	afu = dfl_fpga_fdata_get_private(fdata);
+ 	for_each_region(region, afu)
+ 		if (region->offset <= offset &&
+ 		    region->offset + region->size >= offset + size) {
+@@ -161,6 +163,6 @@ int afu_mmio_region_get_by_offset(struct dfl_feature_platform_data *pdata,
+ 		}
+ 	ret = -EINVAL;
+ exit:
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 	return ret;
+ }
+diff --git a/drivers/fpga/dfl-afu.h b/drivers/fpga/dfl-afu.h
+index 7c297834be05..5a6f8e4fae71 100644
+--- a/drivers/fpga/dfl-afu.h
++++ b/drivers/fpga/dfl-afu.h
+@@ -82,27 +82,27 @@ struct dfl_afu {
+ 	struct dfl_feature_platform_data *pdata;
+ };
+ 
+-/* hold pdata->lock when call __afu_port_enable/disable */
+-int __afu_port_enable(struct platform_device *pdev);
+-int __afu_port_disable(struct platform_device *pdev);
++/* hold fdata->lock when call __afu_port_enable/disable */
++int __afu_port_enable(struct dfl_feature_dev_data *fdata);
++int __afu_port_disable(struct dfl_feature_dev_data *fdata);
+ 
+-void afu_mmio_region_init(struct dfl_feature_platform_data *pdata);
+-int afu_mmio_region_add(struct dfl_feature_platform_data *pdata,
++void afu_mmio_region_init(struct dfl_feature_dev_data *fdata);
++int afu_mmio_region_add(struct dfl_feature_dev_data *fdata,
+ 			u32 region_index, u64 region_size, u64 phys, u32 flags);
+-void afu_mmio_region_destroy(struct dfl_feature_platform_data *pdata);
+-int afu_mmio_region_get_by_index(struct dfl_feature_platform_data *pdata,
++void afu_mmio_region_destroy(struct dfl_feature_dev_data *fdata);
++int afu_mmio_region_get_by_index(struct dfl_feature_dev_data *fdata,
+ 				 u32 region_index,
+ 				 struct dfl_afu_mmio_region *pregion);
+-int afu_mmio_region_get_by_offset(struct dfl_feature_platform_data *pdata,
++int afu_mmio_region_get_by_offset(struct dfl_feature_dev_data *fdata,
+ 				  u64 offset, u64 size,
+ 				  struct dfl_afu_mmio_region *pregion);
+-void afu_dma_region_init(struct dfl_feature_platform_data *pdata);
+-void afu_dma_region_destroy(struct dfl_feature_platform_data *pdata);
+-int afu_dma_map_region(struct dfl_feature_platform_data *pdata,
++void afu_dma_region_init(struct dfl_feature_dev_data *fdata);
++void afu_dma_region_destroy(struct dfl_feature_dev_data *fdata);
++int afu_dma_map_region(struct dfl_feature_dev_data *fdata,
+ 		       u64 user_addr, u64 length, u32 flags, u64 *iova);
+-int afu_dma_unmap_region(struct dfl_feature_platform_data *pdata, u64 iova);
++int afu_dma_unmap_region(struct dfl_feature_dev_data *fdata, u64 iova);
+ struct dfl_afu_dma_region *
+-afu_dma_region_find(struct dfl_feature_platform_data *pdata,
++afu_dma_region_find(struct dfl_feature_dev_data *fdata,
+ 		    u64 iova, u64 size);
+ 
+ extern const struct dfl_feature_ops port_err_ops;
+diff --git a/drivers/fpga/dfl-fme-br.c b/drivers/fpga/dfl-fme-br.c
+index 3ff9f3a687ce..70e39838dc09 100644
+--- a/drivers/fpga/dfl-fme-br.c
++++ b/drivers/fpga/dfl-fme-br.c
+@@ -22,34 +22,34 @@
+ struct fme_br_priv {
+ 	struct dfl_fme_br_pdata *pdata;
+ 	struct dfl_fpga_port_ops *port_ops;
+-	struct platform_device *port_pdev;
++	struct dfl_feature_dev_data *port_fdata;
+ };
+ 
+ static int fme_bridge_enable_set(struct fpga_bridge *bridge, bool enable)
+ {
+ 	struct fme_br_priv *priv = bridge->priv;
+-	struct platform_device *port_pdev;
++	struct dfl_feature_dev_data *port_fdata;
+ 	struct dfl_fpga_port_ops *ops;
+ 
+-	if (!priv->port_pdev) {
+-		port_pdev = dfl_fpga_cdev_find_port(priv->pdata->cdev,
+-						    &priv->pdata->port_id,
+-						    dfl_fpga_check_port_id);
+-		if (!port_pdev)
++	if (!priv->port_fdata) {
++		port_fdata = dfl_fpga_cdev_find_port_data(priv->pdata->cdev,
++							  &priv->pdata->port_id,
++							  dfl_fpga_check_port_id);
++		if (!port_fdata)
+ 			return -ENODEV;
+ 
+-		priv->port_pdev = port_pdev;
++		priv->port_fdata = port_fdata;
+ 	}
+ 
+-	if (priv->port_pdev && !priv->port_ops) {
+-		ops = dfl_fpga_port_ops_get(priv->port_pdev);
++	if (priv->port_fdata && !priv->port_ops) {
++		ops = dfl_fpga_port_ops_get(priv->port_fdata);
+ 		if (!ops || !ops->enable_set)
+ 			return -ENOENT;
+ 
+ 		priv->port_ops = ops;
+ 	}
+ 
+-	return priv->port_ops->enable_set(priv->port_pdev, enable);
++	return priv->port_ops->enable_set(priv->port_fdata, enable);
+ }
+ 
+ static const struct fpga_bridge_ops fme_bridge_ops = {
+@@ -85,8 +85,6 @@ static int fme_br_remove(struct platform_device *pdev)
+ 
+ 	fpga_bridge_unregister(br);
+ 
+-	if (priv->port_pdev)
+-		put_device(&priv->port_pdev->dev);
+ 	if (priv->port_ops)
+ 		dfl_fpga_port_ops_put(priv->port_ops);
+ 
+diff --git a/drivers/fpga/dfl-fme-error.c b/drivers/fpga/dfl-fme-error.c
+index 52d03d38b4ad..5b063fc82555 100644
+--- a/drivers/fpga/dfl-fme-error.c
++++ b/drivers/fpga/dfl-fme-error.c
+@@ -42,15 +42,15 @@
+ static ssize_t pcie0_errors_show(struct device *dev,
+ 				 struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 value;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	value = readq(base + PCIE0_ERROR);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%llx\n", (unsigned long long)value);
+ }
+@@ -59,7 +59,7 @@ static ssize_t pcie0_errors_store(struct device *dev,
+ 				  struct device_attribute *attr,
+ 				  const char *buf, size_t count)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	int ret = 0;
+ 	u64 v, val;
+@@ -67,9 +67,9 @@ static ssize_t pcie0_errors_store(struct device *dev,
+ 	if (kstrtou64(buf, 0, &val))
+ 		return -EINVAL;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	writeq(GENMASK_ULL(63, 0), base + PCIE0_ERROR_MASK);
+ 
+ 	v = readq(base + PCIE0_ERROR);
+@@ -79,7 +79,7 @@ static ssize_t pcie0_errors_store(struct device *dev,
+ 		ret = -EINVAL;
+ 
+ 	writeq(0ULL, base + PCIE0_ERROR_MASK);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 	return ret ? ret : count;
+ }
+ static DEVICE_ATTR_RW(pcie0_errors);
+@@ -87,15 +87,15 @@ static DEVICE_ATTR_RW(pcie0_errors);
+ static ssize_t pcie1_errors_show(struct device *dev,
+ 				 struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 value;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	value = readq(base + PCIE1_ERROR);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%llx\n", (unsigned long long)value);
+ }
+@@ -104,7 +104,7 @@ static ssize_t pcie1_errors_store(struct device *dev,
+ 				  struct device_attribute *attr,
+ 				  const char *buf, size_t count)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	int ret = 0;
+ 	u64 v, val;
+@@ -112,9 +112,9 @@ static ssize_t pcie1_errors_store(struct device *dev,
+ 	if (kstrtou64(buf, 0, &val))
+ 		return -EINVAL;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	writeq(GENMASK_ULL(63, 0), base + PCIE1_ERROR_MASK);
+ 
+ 	v = readq(base + PCIE1_ERROR);
+@@ -124,7 +124,7 @@ static ssize_t pcie1_errors_store(struct device *dev,
+ 		ret = -EINVAL;
+ 
+ 	writeq(0ULL, base + PCIE1_ERROR_MASK);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 	return ret ? ret : count;
+ }
+ static DEVICE_ATTR_RW(pcie1_errors);
+@@ -132,9 +132,10 @@ static DEVICE_ATTR_RW(pcie1_errors);
+ static ssize_t nonfatal_errors_show(struct device *dev,
+ 				    struct device_attribute *attr, char *buf)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+ 	return sprintf(buf, "0x%llx\n",
+ 		       (unsigned long long)readq(base + RAS_NONFAT_ERROR));
+@@ -144,9 +145,10 @@ static DEVICE_ATTR_RO(nonfatal_errors);
+ static ssize_t catfatal_errors_show(struct device *dev,
+ 				    struct device_attribute *attr, char *buf)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+ 	return sprintf(buf, "0x%llx\n",
+ 		       (unsigned long long)readq(base + RAS_CATFAT_ERROR));
+@@ -156,15 +158,15 @@ static DEVICE_ATTR_RO(catfatal_errors);
+ static ssize_t inject_errors_show(struct device *dev,
+ 				  struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	v = readq(base + RAS_ERROR_INJECT);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%llx\n",
+ 		       (unsigned long long)FIELD_GET(INJECT_ERROR_MASK, v));
+@@ -174,7 +176,7 @@ static ssize_t inject_errors_store(struct device *dev,
+ 				   struct device_attribute *attr,
+ 				   const char *buf, size_t count)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u8 inject_error;
+ 	u64 v;
+@@ -185,14 +187,14 @@ static ssize_t inject_errors_store(struct device *dev,
+ 	if (inject_error & ~INJECT_ERROR_MASK)
+ 		return -EINVAL;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	v = readq(base + RAS_ERROR_INJECT);
+ 	v &= ~INJECT_ERROR_MASK;
+ 	v |= FIELD_PREP(INJECT_ERROR_MASK, inject_error);
+ 	writeq(v, base + RAS_ERROR_INJECT);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return count;
+ }
+@@ -201,15 +203,15 @@ static DEVICE_ATTR_RW(inject_errors);
+ static ssize_t fme_errors_show(struct device *dev,
+ 			       struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 value;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	value = readq(base + FME_ERROR);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%llx\n", (unsigned long long)value);
+ }
+@@ -218,7 +220,7 @@ static ssize_t fme_errors_store(struct device *dev,
+ 				struct device_attribute *attr,
+ 				const char *buf, size_t count)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v, val;
+ 	int ret = 0;
+@@ -226,9 +228,9 @@ static ssize_t fme_errors_store(struct device *dev,
+ 	if (kstrtou64(buf, 0, &val))
+ 		return -EINVAL;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	writeq(GENMASK_ULL(63, 0), base + FME_ERROR_MASK);
+ 
+ 	v = readq(base + FME_ERROR);
+@@ -240,7 +242,7 @@ static ssize_t fme_errors_store(struct device *dev,
+ 	/* Workaround: disable MBP_ERROR if feature revision is 0 */
+ 	writeq(dfl_feature_revision(base) ? 0ULL : MBP_ERROR,
+ 	       base + FME_ERROR_MASK);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 	return ret ? ret : count;
+ }
+ static DEVICE_ATTR_RW(fme_errors);
+@@ -248,15 +250,15 @@ static DEVICE_ATTR_RW(fme_errors);
+ static ssize_t first_error_show(struct device *dev,
+ 				struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 value;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	value = readq(base + FME_FIRST_ERROR);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%llx\n", (unsigned long long)value);
+ }
+@@ -265,15 +267,15 @@ static DEVICE_ATTR_RO(first_error);
+ static ssize_t next_error_show(struct device *dev,
+ 			       struct device_attribute *attr, char *buf)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 value;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	value = readq(base + FME_NEXT_ERROR);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return sprintf(buf, "0x%llx\n", (unsigned long long)value);
+ }
+@@ -281,10 +283,11 @@ static DEVICE_ATTR_RO(next_error);
+ 
+ static ssize_t revision_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 dfh;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+ 	dfh = readq(base);
+ 
+@@ -309,12 +312,14 @@ static umode_t fme_global_err_attrs_visible(struct kobject *kobj,
+ 					    struct attribute *attr, int n)
+ {
+ 	struct device *dev = kobj_to_dev(kobj);
++	struct dfl_feature_dev_data *fdata;
+ 
++	fdata = to_dfl_feature_dev_data(dev);
+ 	/*
+ 	 * sysfs entries are visible only if related private feature is
+ 	 * enumerated.
+ 	 */
+-	if (!dfl_get_feature_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR))
++	if (!dfl_get_feature_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR))
+ 		return 0;
+ 
+ 	return attr->mode;
+@@ -328,12 +333,12 @@ const struct attribute_group fme_global_err_group = {
+ 
+ static void fme_err_mask(struct device *dev, bool mask)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_GLOBAL_ERR);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_GLOBAL_ERR);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 
+ 	/* Workaround: keep MBP_ERROR always masked if revision is 0 */
+ 	if (dfl_feature_revision(base))
+@@ -346,7 +351,7 @@ static void fme_err_mask(struct device *dev, bool mask)
+ 	writeq(mask ? ERROR_MASK : 0, base + RAS_NONFAT_ERROR_MASK);
+ 	writeq(mask ? ERROR_MASK : 0, base + RAS_CATFAT_ERROR_MASK);
+ 
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ }
+ 
+ static int fme_global_err_init(struct platform_device *pdev,
+diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
+index a2b8ba0bf291..687b7bd6e581 100644
+--- a/drivers/fpga/dfl-fme-main.c
++++ b/drivers/fpga/dfl-fme-main.c
+@@ -27,10 +27,11 @@
+ static ssize_t ports_num_show(struct device *dev,
+ 			      struct device_attribute *attr, char *buf)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
+ 
+ 	v = readq(base + FME_HDR_CAP);
+ 
+@@ -58,10 +59,11 @@ static DEVICE_ATTR_RO(bitstream_id);
+ static ssize_t bitstream_metadata_show(struct device *dev,
+ 				       struct device_attribute *attr, char *buf)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
+ 
+ 	v = readq(base + FME_HDR_BITSTREAM_MD);
+ 
+@@ -72,10 +74,11 @@ static DEVICE_ATTR_RO(bitstream_metadata);
+ static ssize_t cache_size_show(struct device *dev,
+ 			       struct device_attribute *attr, char *buf)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
+ 
+ 	v = readq(base + FME_HDR_CAP);
+ 
+@@ -87,10 +90,11 @@ static DEVICE_ATTR_RO(cache_size);
+ static ssize_t fabric_version_show(struct device *dev,
+ 				   struct device_attribute *attr, char *buf)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
+ 
+ 	v = readq(base + FME_HDR_CAP);
+ 
+@@ -102,10 +106,11 @@ static DEVICE_ATTR_RO(fabric_version);
+ static ssize_t socket_id_show(struct device *dev,
+ 			      struct device_attribute *attr, char *buf)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
+ 
+ 	v = readq(base + FME_HDR_CAP);
+ 
+@@ -131,7 +136,7 @@ static const struct attribute_group fme_hdr_group = {
+ static long fme_hdr_ioctl_release_port(struct dfl_feature_platform_data *pdata,
+ 				       unsigned long arg)
+ {
+-	struct dfl_fpga_cdev *cdev = pdata->dfl_cdev;
++	struct dfl_fpga_cdev *cdev = pdata->fdata->dfl_cdev;
+ 	int port_id;
+ 
+ 	if (get_user(port_id, (int __user *)arg))
+@@ -143,7 +148,7 @@ static long fme_hdr_ioctl_release_port(struct dfl_feature_platform_data *pdata,
+ static long fme_hdr_ioctl_assign_port(struct dfl_feature_platform_data *pdata,
+ 				      unsigned long arg)
+ {
+-	struct dfl_fpga_cdev *cdev = pdata->dfl_cdev;
++	struct dfl_fpga_cdev *cdev = pdata->fdata->dfl_cdev;
+ 	int port_id;
+ 
+ 	if (get_user(port_id, (int __user *)arg))
+@@ -404,14 +409,14 @@ static int power_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+ static int power_hwmon_write(struct device *dev, enum hwmon_sensor_types type,
+ 			     u32 attr, int channel, long val)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev->parent);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	struct dfl_feature *feature = dev_get_drvdata(dev);
+ 	int ret = 0;
+ 	u64 v;
+ 
+ 	val = clamp_val(val / 1000000, 0, PWR_THRESHOLD_MAX);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 
+ 	switch (attr) {
+ 	case hwmon_power_max:
+@@ -431,7 +436,7 @@ static int power_hwmon_write(struct device *dev, enum hwmon_sensor_types type,
+ 		break;
+ 	}
+ 
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return ret;
+ }
+@@ -593,19 +598,21 @@ static int fme_open(struct inode *inode, struct file *filp)
+ {
+ 	struct platform_device *fdev = dfl_fpga_inode_to_feature_dev(inode);
+ 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&fdev->dev);
++	struct dfl_feature_dev_data *fdata;
+ 	int ret;
+ 
+ 	if (WARN_ON(!pdata))
+ 		return -ENODEV;
+ 
+-	mutex_lock(&pdata->lock);
+-	ret = dfl_feature_dev_use_begin(pdata, filp->f_flags & O_EXCL);
++	fdata = pdata->fdata;
++	mutex_lock(&fdata->lock);
++	ret = dfl_feature_dev_use_begin(fdata, filp->f_flags & O_EXCL);
+ 	if (!ret) {
+ 		dev_dbg(&fdev->dev, "Device File Opened %d Times\n",
+-			dfl_feature_dev_use_count(pdata));
++			dfl_feature_dev_use_count(fdata));
+ 		filp->private_data = pdata;
+ 	}
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return ret;
+ }
+@@ -613,19 +620,20 @@ static int fme_open(struct inode *inode, struct file *filp)
+ static int fme_release(struct inode *inode, struct file *filp)
+ {
+ 	struct dfl_feature_platform_data *pdata = filp->private_data;
+-	struct platform_device *pdev = pdata->dev;
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
++	struct platform_device *pdev = fdata->dev;
+ 	struct dfl_feature *feature;
+ 
+ 	dev_dbg(&pdev->dev, "Device File Release\n");
+ 
+-	mutex_lock(&pdata->lock);
+-	dfl_feature_dev_use_end(pdata);
++	mutex_lock(&fdata->lock);
++	dfl_feature_dev_use_end(fdata);
+ 
+-	if (!dfl_feature_dev_use_count(pdata))
+-		dfl_fpga_dev_for_each_feature(pdata, feature)
++	if (!dfl_feature_dev_use_count(fdata))
++		dfl_fpga_dev_for_each_feature(fdata, feature)
+ 			dfl_fpga_set_irq_triggers(feature, 0,
+ 						  feature->nr_irqs, NULL);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return 0;
+ }
+@@ -633,7 +641,8 @@ static int fme_release(struct inode *inode, struct file *filp)
+ static long fme_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+ {
+ 	struct dfl_feature_platform_data *pdata = filp->private_data;
+-	struct platform_device *pdev = pdata->dev;
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
++	struct platform_device *pdev = fdata->dev;
+ 	struct dfl_feature *f;
+ 	long ret;
+ 
+@@ -651,7 +660,7 @@ static long fme_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+ 		 * handled in this sub feature, and returns 0 or other
+ 		 * error code if cmd is handled.
+ 		 */
+-		dfl_fpga_dev_for_each_feature(pdata, f) {
++		dfl_fpga_dev_for_each_feature(fdata, f) {
+ 			if (f->ops && f->ops->ioctl) {
+ 				ret = f->ops->ioctl(pdev, f, cmd, arg);
+ 				if (ret != -ENODEV)
+@@ -666,6 +675,7 @@ static long fme_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+ static int fme_dev_init(struct platform_device *pdev)
+ {
+ 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
+ 	struct dfl_fme *fme;
+ 
+ 	fme = devm_kzalloc(&pdev->dev, sizeof(*fme), GFP_KERNEL);
+@@ -674,9 +684,9 @@ static int fme_dev_init(struct platform_device *pdev)
+ 
+ 	fme->pdata = pdata;
+ 
+-	mutex_lock(&pdata->lock);
+-	dfl_fpga_pdata_set_private(pdata, fme);
+-	mutex_unlock(&pdata->lock);
++	mutex_lock(&fdata->lock);
++	dfl_fpga_fdata_set_private(fdata, fme);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return 0;
+ }
+@@ -684,10 +694,11 @@ static int fme_dev_init(struct platform_device *pdev)
+ static void fme_dev_destroy(struct platform_device *pdev)
+ {
+ 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
+ 
+-	mutex_lock(&pdata->lock);
+-	dfl_fpga_pdata_set_private(pdata, NULL);
+-	mutex_unlock(&pdata->lock);
++	mutex_lock(&fdata->lock);
++	dfl_fpga_fdata_set_private(fdata, NULL);
++	mutex_unlock(&fdata->lock);
+ }
+ 
+ static const struct file_operations fme_fops = {
+diff --git a/drivers/fpga/dfl-fme-pr.c b/drivers/fpga/dfl-fme-pr.c
+index 1194c0e850e0..b318ac61c472 100644
+--- a/drivers/fpga/dfl-fme-pr.c
++++ b/drivers/fpga/dfl-fme-pr.c
+@@ -65,7 +65,7 @@ static struct fpga_region *dfl_fme_region_find(struct dfl_fme *fme, int port_id)
+ 
+ static int fme_pr(struct platform_device *pdev, unsigned long arg)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(&pdev->dev);
+ 	void __user *argp = (void __user *)arg;
+ 	struct dfl_fpga_fme_port_pr port_pr;
+ 	struct fpga_image_info *info;
+@@ -87,8 +87,7 @@ static int fme_pr(struct platform_device *pdev, unsigned long arg)
+ 		return -EINVAL;
+ 
+ 	/* get fme header region */
+-	fme_hdr = dfl_get_feature_ioaddr_by_id(&pdev->dev,
+-					       FME_FEATURE_ID_HEADER);
++	fme_hdr = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
+ 
+ 	/* check port id */
+ 	v = readq(fme_hdr + FME_HDR_CAP);
+@@ -123,8 +122,8 @@ static int fme_pr(struct platform_device *pdev, unsigned long arg)
+ 
+ 	info->flags |= FPGA_MGR_PARTIAL_RECONFIG;
+ 
+-	mutex_lock(&pdata->lock);
+-	fme = dfl_fpga_pdata_get_private(pdata);
++	mutex_lock(&fdata->lock);
++	fme = dfl_fpga_fdata_get_private(fdata);
+ 	/* fme device has been unregistered. */
+ 	if (!fme) {
+ 		ret = -EINVAL;
+@@ -156,7 +155,7 @@ static int fme_pr(struct platform_device *pdev, unsigned long arg)
+ 
+ 	put_device(&region->dev);
+ unlock_exit:
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ free_exit:
+ 	vfree(buf);
+ 	return ret;
+@@ -170,10 +169,10 @@ static int fme_pr(struct platform_device *pdev, unsigned long arg)
+  * Return: mgr platform device if successful, and error code otherwise.
+  */
+ static struct platform_device *
+-dfl_fme_create_mgr(struct dfl_feature_platform_data *pdata,
++dfl_fme_create_mgr(struct dfl_feature_dev_data *fdata,
+ 		   struct dfl_feature *feature)
+ {
+-	struct platform_device *mgr, *fme = pdata->dev;
++	struct platform_device *mgr, *fme = fdata->dev;
+ 	struct dfl_fme_mgr_pdata mgr_pdata;
+ 	int ret = -ENOMEM;
+ 
+@@ -211,9 +210,9 @@ dfl_fme_create_mgr(struct dfl_feature_platform_data *pdata,
+  * dfl_fme_destroy_mgr - destroy fpga mgr platform device
+  * @pdata: fme platform device's pdata
+  */
+-static void dfl_fme_destroy_mgr(struct dfl_feature_platform_data *pdata)
++static void dfl_fme_destroy_mgr(struct dfl_feature_dev_data *fdata)
+ {
+-	struct dfl_fme *priv = dfl_fpga_pdata_get_private(pdata);
++	struct dfl_fme *priv = dfl_fpga_fdata_get_private(fdata);
+ 
+ 	platform_device_unregister(priv->mgr);
+ }
+@@ -221,15 +220,15 @@ static void dfl_fme_destroy_mgr(struct dfl_feature_platform_data *pdata)
+ /**
+  * dfl_fme_create_bridge - create fme fpga bridge platform device as child
+  *
+- * @pdata: fme platform device's pdata
++ * @fdata: fme feature dev data
+  * @port_id: port id for the bridge to be created.
+  *
+  * Return: bridge platform device if successful, and error code otherwise.
+  */
+ static struct dfl_fme_bridge *
+-dfl_fme_create_bridge(struct dfl_feature_platform_data *pdata, int port_id)
++dfl_fme_create_bridge(struct dfl_feature_dev_data *fdata, int port_id)
+ {
+-	struct device *dev = &pdata->dev->dev;
++	struct device *dev = &fdata->dev->dev;
+ 	struct dfl_fme_br_pdata br_pdata;
+ 	struct dfl_fme_bridge *fme_br;
+ 	int ret = -ENOMEM;
+@@ -238,7 +237,7 @@ dfl_fme_create_bridge(struct dfl_feature_platform_data *pdata, int port_id)
+ 	if (!fme_br)
+ 		return ERR_PTR(ret);
+ 
+-	br_pdata.cdev = pdata->dfl_cdev;
++	br_pdata.cdev = fdata->dfl_cdev;
+ 	br_pdata.port_id = port_id;
+ 
+ 	fme_br->br = platform_device_alloc(DFL_FPGA_FME_BRIDGE,
+@@ -274,11 +273,11 @@ static void dfl_fme_destroy_bridge(struct dfl_fme_bridge *fme_br)
+ 
+ /**
+  * dfl_fme_destroy_bridge - destroy all fpga bridge platform device
+- * @pdata: fme platform device's pdata
++ * @fdata: fme feature dev data
+  */
+-static void dfl_fme_destroy_bridges(struct dfl_feature_platform_data *pdata)
++static void dfl_fme_destroy_bridges(struct dfl_feature_dev_data *fdata)
+ {
+-	struct dfl_fme *priv = dfl_fpga_pdata_get_private(pdata);
++	struct dfl_fme *priv = dfl_fpga_fdata_get_private(fdata);
+ 	struct dfl_fme_bridge *fbridge, *tmp;
+ 
+ 	list_for_each_entry_safe(fbridge, tmp, &priv->bridge_list, node) {
+@@ -290,7 +289,7 @@ static void dfl_fme_destroy_bridges(struct dfl_feature_platform_data *pdata)
+ /**
+  * dfl_fme_create_region - create fpga region platform device as child
+  *
+- * @pdata: fme platform device's pdata
++ * @fdata: fme feature dev data
+  * @mgr: mgr platform device needed for region
+  * @br: br platform device needed for region
+  * @port_id: port id
+@@ -298,12 +297,12 @@ static void dfl_fme_destroy_bridges(struct dfl_feature_platform_data *pdata)
+  * Return: fme region if successful, and error code otherwise.
+  */
+ static struct dfl_fme_region *
+-dfl_fme_create_region(struct dfl_feature_platform_data *pdata,
++dfl_fme_create_region(struct dfl_feature_dev_data *fdata,
+ 		      struct platform_device *mgr,
+ 		      struct platform_device *br, int port_id)
+ {
+ 	struct dfl_fme_region_pdata region_pdata;
+-	struct device *dev = &pdata->dev->dev;
++	struct device *dev = &fdata->dev->dev;
+ 	struct dfl_fme_region *fme_region;
+ 	int ret = -ENOMEM;
+ 
+@@ -353,11 +352,11 @@ static void dfl_fme_destroy_region(struct dfl_fme_region *fme_region)
+ 
+ /**
+  * dfl_fme_destroy_regions - destroy all fme regions
+- * @pdata: fme platform device's pdata
++ * @fdata: fme feature dev data
+  */
+-static void dfl_fme_destroy_regions(struct dfl_feature_platform_data *pdata)
++static void dfl_fme_destroy_regions(struct dfl_feature_dev_data *fdata)
+ {
+-	struct dfl_fme *priv = dfl_fpga_pdata_get_private(pdata);
++	struct dfl_fme *priv = dfl_fpga_fdata_get_private(fdata);
+ 	struct dfl_fme_region *fme_region, *tmp;
+ 
+ 	list_for_each_entry_safe(fme_region, tmp, &priv->region_list, node) {
+@@ -369,7 +368,8 @@ static void dfl_fme_destroy_regions(struct dfl_feature_platform_data *pdata)
+ static int pr_mgmt_init(struct platform_device *pdev,
+ 			struct dfl_feature *feature)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata =
++			to_dfl_feature_dev_data(&pdev->dev);
+ 	struct dfl_fme_region *fme_region;
+ 	struct dfl_fme_bridge *fme_br;
+ 	struct platform_device *mgr;
+@@ -378,18 +378,17 @@ static int pr_mgmt_init(struct platform_device *pdev,
+ 	int ret = -ENODEV, i = 0;
+ 	u64 fme_cap, port_offset;
+ 
+-	fme_hdr = dfl_get_feature_ioaddr_by_id(&pdev->dev,
+-					       FME_FEATURE_ID_HEADER);
++	fme_hdr = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
+ 
+-	mutex_lock(&pdata->lock);
+-	priv = dfl_fpga_pdata_get_private(pdata);
++	mutex_lock(&fdata->lock);
++	priv = dfl_fpga_fdata_get_private(fdata);
+ 
+ 	/* Initialize the region and bridge sub device list */
+ 	INIT_LIST_HEAD(&priv->region_list);
+ 	INIT_LIST_HEAD(&priv->bridge_list);
+ 
+ 	/* Create fpga mgr platform device */
+-	mgr = dfl_fme_create_mgr(pdata, feature);
++	mgr = dfl_fme_create_mgr(fdata, feature);
+ 	if (IS_ERR(mgr)) {
+ 		dev_err(&pdev->dev, "fail to create fpga mgr pdev\n");
+ 		goto unlock;
+@@ -405,7 +404,7 @@ static int pr_mgmt_init(struct platform_device *pdev,
+ 			continue;
+ 
+ 		/* Create bridge for each port */
+-		fme_br = dfl_fme_create_bridge(pdata, i);
++		fme_br = dfl_fme_create_bridge(fdata, i);
+ 		if (IS_ERR(fme_br)) {
+ 			ret = PTR_ERR(fme_br);
+ 			goto destroy_region;
+@@ -414,7 +413,7 @@ static int pr_mgmt_init(struct platform_device *pdev,
+ 		list_add(&fme_br->node, &priv->bridge_list);
+ 
+ 		/* Create region for each port */
+-		fme_region = dfl_fme_create_region(pdata, mgr,
++		fme_region = dfl_fme_create_region(fdata, mgr,
+ 						   fme_br->br, i);
+ 		if (IS_ERR(fme_region)) {
+ 			ret = PTR_ERR(fme_region);
+@@ -423,30 +422,31 @@ static int pr_mgmt_init(struct platform_device *pdev,
+ 
+ 		list_add(&fme_region->node, &priv->region_list);
+ 	}
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	return 0;
+ 
+ destroy_region:
+-	dfl_fme_destroy_regions(pdata);
+-	dfl_fme_destroy_bridges(pdata);
+-	dfl_fme_destroy_mgr(pdata);
++	dfl_fme_destroy_regions(fdata);
++	dfl_fme_destroy_bridges(fdata);
++	dfl_fme_destroy_mgr(fdata);
+ unlock:
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 	return ret;
+ }
+ 
+ static void pr_mgmt_uinit(struct platform_device *pdev,
+ 			  struct dfl_feature *feature)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata =
++			to_dfl_feature_dev_data(&pdev->dev);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 
+-	dfl_fme_destroy_regions(pdata);
+-	dfl_fme_destroy_bridges(pdata);
+-	dfl_fme_destroy_mgr(pdata);
+-	mutex_unlock(&pdata->lock);
++	dfl_fme_destroy_regions(fdata);
++	dfl_fme_destroy_bridges(fdata);
++	dfl_fme_destroy_mgr(fdata);
++	mutex_unlock(&fdata->lock);
+ }
+ 
+ static long fme_pr_ioctl(struct platform_device *pdev,
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index 94cd53d5c922..8ead608d1df6 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -118,17 +118,6 @@ static void dfl_id_free(enum dfl_id_type type, int id)
+ 	mutex_unlock(&dfl_id_mutex);
+ }
+ 
+-static enum dfl_id_type feature_dev_id_type(struct platform_device *pdev)
+-{
+-	int i;
+-
+-	for (i = 0; i < ARRAY_SIZE(dfl_devs); i++)
+-		if (!strcmp(dfl_devs[i].name, pdev->name))
+-			return i;
+-
+-	return DFL_ID_MAX;
+-}
+-
+ static enum dfl_id_type dfh_id_to_type(u16 id)
+ {
+ 	int i;
+@@ -160,7 +149,8 @@ static LIST_HEAD(dfl_port_ops_list);
+  *
+  * Please note that must dfl_fpga_port_ops_put after use the port_ops.
+  */
+-struct dfl_fpga_port_ops *dfl_fpga_port_ops_get(struct platform_device *pdev)
++struct dfl_fpga_port_ops *
++dfl_fpga_port_ops_get(struct dfl_feature_dev_data *fdata)
+ {
+ 	struct dfl_fpga_port_ops *ops = NULL;
+ 
+@@ -170,7 +160,7 @@ struct dfl_fpga_port_ops *dfl_fpga_port_ops_get(struct platform_device *pdev)
+ 
+ 	list_for_each_entry(ops, &dfl_port_ops_list, node) {
+ 		/* match port_ops using the name of platform device */
+-		if (!strcmp(pdev->name, ops->name)) {
++		if (!strcmp(fdata->pdev_name, ops->name)) {
+ 			if (!try_module_get(ops->owner))
+ 				ops = NULL;
+ 			goto done;
+@@ -226,22 +216,21 @@ EXPORT_SYMBOL_GPL(dfl_fpga_port_ops_del);
+  *
+  * Return: 1 if port device matches with given port id, otherwise 0.
+  */
+-int dfl_fpga_check_port_id(struct platform_device *pdev, void *pport_id)
++int dfl_fpga_check_port_id(struct dfl_feature_dev_data *fdata, void *pport_id)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
+ 	struct dfl_fpga_port_ops *port_ops;
+ 
+-	if (pdata->id != FEATURE_DEV_ID_UNUSED)
+-		return pdata->id == *(int *)pport_id;
++	if (fdata->id != FEATURE_DEV_ID_UNUSED)
++		return fdata->id == *(int *)pport_id;
+ 
+-	port_ops = dfl_fpga_port_ops_get(pdev);
++	port_ops = dfl_fpga_port_ops_get(fdata);
+ 	if (!port_ops || !port_ops->get_id)
+ 		return 0;
+ 
+-	pdata->id = port_ops->get_id(pdev);
++	fdata->id = port_ops->get_id(fdata);
+ 	dfl_fpga_port_ops_put(port_ops);
+ 
+-	return pdata->id == *(int *)pport_id;
++	return fdata->id == *(int *)pport_id;
+ }
+ EXPORT_SYMBOL_GPL(dfl_fpga_check_port_id);
+ 
+@@ -402,10 +391,10 @@ static void release_dfl_dev(struct device *dev)
+ }
+ 
+ static struct dfl_device *
+-dfl_dev_add(struct dfl_feature_platform_data *pdata,
++dfl_dev_add(struct dfl_feature_dev_data *fdata,
+ 	    struct dfl_feature *feature)
+ {
+-	struct platform_device *pdev = pdata->dev;
++	struct platform_device *pdev = fdata->dev;
+ 	struct resource *parent_res;
+ 	struct dfl_device *ddev;
+ 	int id, i, ret;
+@@ -431,9 +420,9 @@ dfl_dev_add(struct dfl_feature_platform_data *pdata,
+ 	if (ret)
+ 		goto put_dev;
+ 
+-	ddev->type = feature_dev_id_type(pdev);
++	ddev->type = fdata->type;
+ 	ddev->feature_id = feature->id;
+-	ddev->cdev = pdata->dfl_cdev;
++	ddev->cdev = fdata->dfl_cdev;
+ 
+ 	/* add mmio resource */
+ 	parent_res = &pdev->resource[feature->resource_index];
+@@ -476,11 +465,11 @@ dfl_dev_add(struct dfl_feature_platform_data *pdata,
+ 	return ERR_PTR(ret);
+ }
+ 
+-static void dfl_devs_remove(struct dfl_feature_platform_data *pdata)
++static void dfl_devs_remove(struct dfl_feature_dev_data *fdata)
+ {
+ 	struct dfl_feature *feature;
+ 
+-	dfl_fpga_dev_for_each_feature(pdata, feature) {
++	dfl_fpga_dev_for_each_feature(fdata, feature) {
+ 		if (feature->ddev) {
+ 			device_unregister(&feature->ddev->dev);
+ 			feature->ddev = NULL;
+@@ -488,13 +477,13 @@ static void dfl_devs_remove(struct dfl_feature_platform_data *pdata)
+ 	}
+ }
+ 
+-static int dfl_devs_add(struct dfl_feature_platform_data *pdata)
++static int dfl_devs_add(struct dfl_feature_dev_data *fdata)
+ {
+ 	struct dfl_feature *feature;
+ 	struct dfl_device *ddev;
+ 	int ret;
+ 
+-	dfl_fpga_dev_for_each_feature(pdata, feature) {
++	dfl_fpga_dev_for_each_feature(fdata, feature) {
+ 		if (feature->ioaddr)
+ 			continue;
+ 
+@@ -503,7 +492,7 @@ static int dfl_devs_add(struct dfl_feature_platform_data *pdata)
+ 			goto err;
+ 		}
+ 
+-		ddev = dfl_dev_add(pdata, feature);
++		ddev = dfl_dev_add(fdata, feature);
+ 		if (IS_ERR(ddev)) {
+ 			ret = PTR_ERR(ddev);
+ 			goto err;
+@@ -515,7 +504,7 @@ static int dfl_devs_add(struct dfl_feature_platform_data *pdata)
+ 	return 0;
+ 
+ err:
+-	dfl_devs_remove(pdata);
++	dfl_devs_remove(fdata);
+ 	return ret;
+ }
+ 
+@@ -576,11 +565,12 @@ EXPORT_SYMBOL_GPL(dfl_dev_get_base_dev);
+ void dfl_fpga_dev_feature_uinit(struct platform_device *pdev)
+ {
+ 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
+ 	struct dfl_feature *feature;
+ 
+-	dfl_devs_remove(pdata);
++	dfl_devs_remove(fdata);
+ 
+-	dfl_fpga_dev_for_each_feature(pdata, feature) {
++	dfl_fpga_dev_for_each_feature(fdata, feature) {
+ 		if (feature->ops) {
+ 			if (feature->ops->uinit)
+ 				feature->ops->uinit(pdev, feature);
+@@ -651,12 +641,13 @@ int dfl_fpga_dev_feature_init(struct platform_device *pdev,
+ 			      struct dfl_feature_driver *feature_drvs)
+ {
+ 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
+ 	struct dfl_feature_driver *drv = feature_drvs;
+ 	struct dfl_feature *feature;
+ 	int ret;
+ 
+ 	while (drv->ops) {
+-		dfl_fpga_dev_for_each_feature(pdata, feature) {
++		dfl_fpga_dev_for_each_feature(fdata, feature) {
+ 			if (dfl_feature_drv_match(feature, drv)) {
+ 				ret = dfl_feature_instance_init(pdev, pdata,
+ 								feature, drv);
+@@ -667,7 +658,7 @@ int dfl_fpga_dev_feature_init(struct platform_device *pdev,
+ 		drv++;
+ 	}
+ 
+-	ret = dfl_devs_add(pdata);
++	ret = dfl_devs_add(fdata);
+ 	if (ret)
+ 		goto exit;
+ 
+@@ -766,7 +757,7 @@ EXPORT_SYMBOL_GPL(dfl_fpga_dev_ops_unregister);
+  * @nr_irqs: number of irqs for all feature devices.
+  * @irq_table: Linux IRQ numbers for all irqs, indexed by local irq index of
+  *	       this device.
+- * @feature_dev: current feature device.
++ * @type: the current FIU type.
+  * @ioaddr: header register region address of current FIU in enumeration.
+  * @start: register resource start of current FIU.
+  * @len: max register resource length of current FIU.
+@@ -779,7 +770,7 @@ struct build_feature_devs_info {
+ 	unsigned int nr_irqs;
+ 	int *irq_table;
+ 
+-	struct platform_device *feature_dev;
++	enum dfl_id_type type;
+ 	void __iomem *ioaddr;
+ 	resource_size_t start;
+ 	resource_size_t len;
+@@ -806,50 +797,51 @@ struct dfl_feature_info {
+ 	unsigned int nr_irqs;
+ };
+ 
+-static void dfl_fpga_cdev_add_port_dev(struct dfl_fpga_cdev *cdev,
+-				       struct platform_device *port)
++static void dfl_fpga_cdev_add_port_data(struct dfl_fpga_cdev *cdev,
++					struct dfl_feature_dev_data *fdata)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(&port->dev);
+-
+ 	mutex_lock(&cdev->lock);
+-	list_add(&pdata->node, &cdev->port_dev_list);
+-	get_device(&pdata->dev->dev);
++	list_add(&fdata->node, &cdev->port_dev_list);
+ 	mutex_unlock(&cdev->lock);
+ }
+ 
+-/*
+- * register current feature device, it is called when we need to switch to
+- * another feature parsing or we have parsed all features on given device
+- * feature list.
+- */
+-static int build_info_commit_dev(struct build_feature_devs_info *binfo)
++static struct dfl_feature_dev_data *
++binfo_create_feature_dev_data(struct build_feature_devs_info *binfo)
+ {
+-	struct platform_device *fdev = binfo->feature_dev;
+-	struct dfl_feature_platform_data *pdata;
++	enum dfl_id_type type = binfo->type;
+ 	struct dfl_feature_info *finfo, *p;
+-	enum dfl_id_type type;
++	struct dfl_feature_dev_data *fdata;
+ 	int ret, index = 0, res_idx = 0;
+ 
+-	type = feature_dev_id_type(fdev);
+ 	if (WARN_ON_ONCE(type >= DFL_ID_MAX))
+-		return -EINVAL;
++		return ERR_PTR(-EINVAL);
+ 
+-	/*
+-	 * we do not need to care for the memory which is associated with
+-	 * the platform device. After calling platform_device_unregister(),
+-	 * it will be automatically freed by device's release() callback,
+-	 * platform_device_release().
+-	 */
+-	pdata = kzalloc(struct_size(pdata, features, binfo->feature_num), GFP_KERNEL);
+-	if (!pdata)
+-		return -ENOMEM;
++	fdata = devm_kzalloc(binfo->dev, sizeof(*fdata), GFP_KERNEL);
++	if (!fdata)
++		return ERR_PTR(-ENOMEM);
++
++	fdata->features = devm_kcalloc(binfo->dev, binfo->feature_num,
++				       sizeof(*fdata->features), GFP_KERNEL);
++	if (!fdata->features)
++		return ERR_PTR(-ENOMEM);
++
++	fdata->resources = devm_kcalloc(binfo->dev, binfo->feature_num,
++					sizeof(*fdata->resources), GFP_KERNEL);
++	if (!fdata->resources)
++		return ERR_PTR(-ENOMEM);
++
++	fdata->type = type;
++
++	fdata->pdev_id = dfl_id_alloc(type, binfo->dev);
++	if (fdata->pdev_id < 0)
++		return ERR_PTR(fdata->pdev_id);
+ 
+-	pdata->dev = fdev;
+-	pdata->num = binfo->feature_num;
+-	pdata->dfl_cdev = binfo->cdev;
+-	pdata->id = FEATURE_DEV_ID_UNUSED;
+-	mutex_init(&pdata->lock);
+-	lockdep_set_class_and_name(&pdata->lock, &dfl_pdata_keys[type],
++	fdata->pdev_name = dfl_devs[type].name;
++	fdata->num = binfo->feature_num;
++	fdata->dfl_cdev = binfo->cdev;
++	fdata->id = FEATURE_DEV_ID_UNUSED;
++	mutex_init(&fdata->lock);
++	lockdep_set_class_and_name(&fdata->lock, &dfl_pdata_keys[type],
+ 				   dfl_pdata_key_strings[type]);
+ 
+ 	/*
+@@ -858,25 +850,15 @@ static int build_info_commit_dev(struct build_feature_devs_info *binfo)
+ 	 * works properly for port device.
+ 	 * and it should always be 0 for fme device.
+ 	 */
+-	WARN_ON(pdata->disable_count);
+-
+-	fdev->dev.platform_data = pdata;
+-
+-	/* each sub feature has one MMIO resource */
+-	fdev->num_resources = binfo->feature_num;
+-	fdev->resource = kcalloc(binfo->feature_num, sizeof(*fdev->resource),
+-				 GFP_KERNEL);
+-	if (!fdev->resource)
+-		return -ENOMEM;
++	WARN_ON(fdata->disable_count);
+ 
+ 	/* fill features and resource information for feature dev */
+ 	list_for_each_entry_safe(finfo, p, &binfo->sub_features, node) {
+-		struct dfl_feature *feature = &pdata->features[index++];
++		struct dfl_feature *feature = &fdata->features[index++];
+ 		struct dfl_feature_irq_ctx *ctx;
+ 		unsigned int i;
+ 
+ 		/* save resource information for each feature */
+-		feature->dev = fdev;
+ 		feature->id = finfo->fid;
+ 
+ 		/*
+@@ -891,19 +873,22 @@ static int build_info_commit_dev(struct build_feature_devs_info *binfo)
+ 			feature->ioaddr =
+ 				devm_ioremap_resource(binfo->dev,
+ 						      &finfo->mmio_res);
+-			if (IS_ERR(feature->ioaddr))
+-				return PTR_ERR(feature->ioaddr);
++			if (IS_ERR(feature->ioaddr)) {
++				ret = PTR_ERR(feature->ioaddr);
++				goto err_free_id;
++			}
+ 		} else {
+ 			feature->resource_index = res_idx;
+-			fdev->resource[res_idx++] = finfo->mmio_res;
++			fdata->resources[res_idx++] = finfo->mmio_res;
+ 		}
+ 
+ 		if (finfo->nr_irqs) {
+ 			ctx = devm_kcalloc(binfo->dev, finfo->nr_irqs,
+ 					   sizeof(*ctx), GFP_KERNEL);
+-			if (!ctx)
+-				return -ENOMEM;
+-
++			if (!ctx) {
++				ret = -ENOMEM;
++				goto err_free_id;
++			}
+ 			for (i = 0; i < finfo->nr_irqs; i++)
+ 				ctx[i].irq =
+ 					binfo->irq_table[finfo->irq_base + i];
+@@ -916,55 +901,90 @@ static int build_info_commit_dev(struct build_feature_devs_info *binfo)
+ 		kfree(finfo);
+ 	}
+ 
+-	ret = platform_device_add(binfo->feature_dev);
+-	if (!ret) {
+-		if (type == PORT_ID)
+-			dfl_fpga_cdev_add_port_dev(binfo->cdev,
+-						   binfo->feature_dev);
+-		else
+-			binfo->cdev->fme_dev =
+-					get_device(&binfo->feature_dev->dev);
+-		/*
+-		 * reset it to avoid build_info_free() freeing their resource.
+-		 *
+-		 * The resource of successfully registered feature devices
+-		 * will be freed by platform_device_unregister(). See the
+-		 * comments in build_info_create_dev().
+-		 */
+-		binfo->feature_dev = NULL;
+-	}
++	fdata->resource_num = res_idx;
+ 
+-	return ret;
++	return fdata;
++
++err_free_id:
++	dfl_id_free(type, fdata->pdev_id);
++
++	return ERR_PTR(ret);
+ }
+ 
+-static int
+-build_info_create_dev(struct build_feature_devs_info *binfo,
+-		      enum dfl_id_type type)
++/*
++ * register current feature device, it is called when we need to switch to
++ * another feature parsing or we have parsed all features on given device
++ * feature list.
++ */
++static int feature_dev_register(struct dfl_feature_dev_data *fdata)
+ {
++	struct dfl_feature_platform_data pdata = { 0 };
+ 	struct platform_device *fdev;
++	struct dfl_feature *feature;
++	int ret;
+ 
+-	if (type >= DFL_ID_MAX)
+-		return -EINVAL;
+-
+-	/*
+-	 * we use -ENODEV as the initialization indicator which indicates
+-	 * whether the id need to be reclaimed
+-	 */
+-	fdev = platform_device_alloc(dfl_devs[type].name, -ENODEV);
++	fdev = platform_device_alloc(fdata->pdev_name, fdata->pdev_id);
+ 	if (!fdev)
+ 		return -ENOMEM;
+ 
+-	binfo->feature_dev = fdev;
+-	binfo->feature_num = 0;
++	fdata->dev = fdev;
+ 
+-	INIT_LIST_HEAD(&binfo->sub_features);
++	fdev->dev.parent = &fdata->dfl_cdev->region->dev;
++	fdev->dev.devt = dfl_get_devt(dfl_devs[fdata->type].devt_type,
++				      fdev->id);
++
++	dfl_fpga_dev_for_each_feature(fdata, feature)
++		feature->dev = fdev;
++
++	ret = platform_device_add_resources(fdev, fdata->resources,
++					    fdata->resource_num);
++	if (ret)
++		goto err_put_dev;
+ 
+-	fdev->id = dfl_id_alloc(type, &fdev->dev);
+-	if (fdev->id < 0)
+-		return fdev->id;
++	pdata.fdata = fdata;
++	ret = platform_device_add_data(fdev, &pdata, sizeof(pdata));
++	if (ret)
++		goto err_put_dev;
+ 
+-	fdev->dev.parent = &binfo->cdev->region->dev;
+-	fdev->dev.devt = dfl_get_devt(dfl_devs[type].devt_type, fdev->id);
++	ret = platform_device_add(fdev);
++	if (ret)
++		goto err_put_dev;
++
++	return 0;
++
++err_put_dev:
++	platform_device_put(fdev);
++	fdata->dev = NULL;
++
++	return ret;
++}
++
++static void feature_dev_unregister(struct dfl_feature_dev_data *fdata)
++{
++	platform_device_unregister(fdata->dev);
++	fdata->dev = NULL;
++}
++
++static int build_info_commit_dev(struct build_feature_devs_info *binfo)
++{
++	struct dfl_feature_dev_data *fdata;
++	int ret;
++
++	fdata = binfo_create_feature_dev_data(binfo);
++	if (IS_ERR(fdata))
++		return PTR_ERR(fdata);
++
++	ret = feature_dev_register(fdata);
++	if (ret)
++		return ret;
++
++	if (binfo->type == PORT_ID)
++		dfl_fpga_cdev_add_port_data(binfo->cdev, fdata);
++	else
++		binfo->cdev->fme_dev = get_device(&fdata->dev->dev);
++
++	/* reset the binfo for next FIU */
++	binfo->type = DFL_ID_MAX;
+ 
+ 	return 0;
+ }
+@@ -973,22 +993,11 @@ static void build_info_free(struct build_feature_devs_info *binfo)
+ {
+ 	struct dfl_feature_info *finfo, *p;
+ 
+-	/*
+-	 * it is a valid id, free it. See comments in
+-	 * build_info_create_dev()
+-	 */
+-	if (binfo->feature_dev && binfo->feature_dev->id >= 0) {
+-		dfl_id_free(feature_dev_id_type(binfo->feature_dev),
+-			    binfo->feature_dev->id);
+-
+-		list_for_each_entry_safe(finfo, p, &binfo->sub_features, node) {
+-			list_del(&finfo->node);
+-			kfree(finfo);
+-		}
++	list_for_each_entry_safe(finfo, p, &binfo->sub_features, node) {
++		list_del(&finfo->node);
++		kfree(finfo);
+ 	}
+ 
+-	platform_device_put(binfo->feature_dev);
+-
+ 	devm_kfree(binfo->dev, binfo);
+ }
+ 
+@@ -1143,7 +1152,7 @@ static int parse_feature_port_afu(struct build_feature_devs_info *binfo,
+ 	return create_feature_instance(binfo, ofst, size, FEATURE_ID_AFU);
+ }
+ 
+-#define is_feature_dev_detected(binfo) (!!(binfo)->feature_dev)
++#define is_feature_dev_detected(binfo) ((binfo)->type != DFL_ID_MAX)
+ 
+ static int parse_feature_afu(struct build_feature_devs_info *binfo,
+ 			     resource_size_t ofst)
+@@ -1153,12 +1162,11 @@ static int parse_feature_afu(struct build_feature_devs_info *binfo,
+ 		return -EINVAL;
+ 	}
+ 
+-	switch (feature_dev_id_type(binfo->feature_dev)) {
++	switch (binfo->type) {
+ 	case PORT_ID:
+ 		return parse_feature_port_afu(binfo, ofst);
+ 	default:
+-		dev_info(binfo->dev, "AFU belonging to FIU %s is not supported yet.\n",
+-			 binfo->feature_dev->name);
++		dev_info(binfo->dev, "AFU belonging to FIU is not supported yet.\n");
+ 	}
+ 
+ 	return 0;
+@@ -1199,6 +1207,7 @@ static void build_info_complete(struct build_feature_devs_info *binfo)
+ static int parse_feature_fiu(struct build_feature_devs_info *binfo,
+ 			     resource_size_t ofst)
+ {
++	enum dfl_id_type type;
+ 	int ret = 0;
+ 	u32 offset;
+ 	u16 id;
+@@ -1220,10 +1229,13 @@ static int parse_feature_fiu(struct build_feature_devs_info *binfo,
+ 	v = readq(binfo->ioaddr + DFH);
+ 	id = FIELD_GET(DFH_ID, v);
+ 
+-	/* create platform device for dfl feature dev */
+-	ret = build_info_create_dev(binfo, dfh_id_to_type(id));
+-	if (ret)
+-		return ret;
++	type = dfh_id_to_type(id);
++	if (type >= DFL_ID_MAX)
++		return -EINVAL;
++
++	binfo->type = type;
++	binfo->feature_num = 0;
++	INIT_LIST_HEAD(&binfo->sub_features);
+ 
+ 	ret = create_feature_instance(binfo, 0, 0, 0);
+ 	if (ret)
+@@ -1441,13 +1453,10 @@ EXPORT_SYMBOL_GPL(dfl_fpga_enum_info_add_irq);
+ 
+ static int remove_feature_dev(struct device *dev, void *data)
+ {
+-	struct platform_device *pdev = to_platform_device(dev);
+-	enum dfl_id_type type = feature_dev_id_type(pdev);
+-	int id = pdev->id;
+-
+-	platform_device_unregister(pdev);
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 
+-	dfl_id_free(type, id);
++	feature_dev_unregister(fdata);
++	dfl_id_free(fdata->type, fdata->pdev_id);
+ 
+ 	return 0;
+ }
+@@ -1503,6 +1512,7 @@ dfl_fpga_feature_devs_enumerate(struct dfl_fpga_enum_info *info)
+ 		goto unregister_region_exit;
+ 	}
+ 
++	binfo->type = DFL_ID_MAX;
+ 	binfo->dev = info->dev;
+ 	binfo->cdev = cdev;
+ 
+@@ -1544,25 +1554,10 @@ EXPORT_SYMBOL_GPL(dfl_fpga_feature_devs_enumerate);
+  */
+ void dfl_fpga_feature_devs_remove(struct dfl_fpga_cdev *cdev)
+ {
+-	struct dfl_feature_platform_data *pdata, *ptmp;
+-
+ 	mutex_lock(&cdev->lock);
+ 	if (cdev->fme_dev)
+ 		put_device(cdev->fme_dev);
+ 
+-	list_for_each_entry_safe(pdata, ptmp, &cdev->port_dev_list, node) {
+-		struct platform_device *port_dev = pdata->dev;
+-
+-		/* remove released ports */
+-		if (!device_is_registered(&port_dev->dev)) {
+-			dfl_id_free(feature_dev_id_type(port_dev),
+-				    port_dev->id);
+-			platform_device_put(port_dev);
+-		}
+-
+-		list_del(&pdata->node);
+-		put_device(&port_dev->dev);
+-	}
+ 	mutex_unlock(&cdev->lock);
+ 
+ 	remove_feature_devs(cdev);
+@@ -1586,23 +1581,21 @@ EXPORT_SYMBOL_GPL(dfl_fpga_feature_devs_remove);
+  *
+  * NOTE: you will need to drop the device reference with put_device() after use.
+  */
+-struct platform_device *
+-__dfl_fpga_cdev_find_port(struct dfl_fpga_cdev *cdev, void *data,
+-			  int (*match)(struct platform_device *, void *))
++struct dfl_feature_dev_data *
++__dfl_fpga_cdev_find_port_data(struct dfl_fpga_cdev *cdev, void *data,
++			       int (*match)(struct dfl_feature_dev_data *,
++					    void *))
+ {
+-	struct dfl_feature_platform_data *pdata;
+-	struct platform_device *port_dev;
+-
+-	list_for_each_entry(pdata, &cdev->port_dev_list, node) {
+-		port_dev = pdata->dev;
++	struct dfl_feature_dev_data *fdata;
+ 
+-		if (match(port_dev, data) && get_device(&port_dev->dev))
+-			return port_dev;
++	list_for_each_entry(fdata, &cdev->port_dev_list, node) {
++		if (match(fdata, data))
++			return fdata;
+ 	}
+ 
+ 	return NULL;
+ }
+-EXPORT_SYMBOL_GPL(__dfl_fpga_cdev_find_port);
++EXPORT_SYMBOL_GPL(__dfl_fpga_cdev_find_port_data);
+ 
+ static int __init dfl_fpga_init(void)
+ {
+@@ -1636,33 +1629,29 @@ static int __init dfl_fpga_init(void)
+  */
+ int dfl_fpga_cdev_release_port(struct dfl_fpga_cdev *cdev, int port_id)
+ {
+-	struct dfl_feature_platform_data *pdata;
+-	struct platform_device *port_pdev;
++	struct dfl_feature_dev_data *fdata;
+ 	int ret = -ENODEV;
+ 
+ 	mutex_lock(&cdev->lock);
+-	port_pdev = __dfl_fpga_cdev_find_port(cdev, &port_id,
+-					      dfl_fpga_check_port_id);
+-	if (!port_pdev)
++	fdata = __dfl_fpga_cdev_find_port_data(cdev, &port_id,
++					       dfl_fpga_check_port_id);
++	if (!fdata)
+ 		goto unlock_exit;
+ 
+-	if (!device_is_registered(&port_pdev->dev)) {
++	if (!fdata->dev) {
+ 		ret = -EBUSY;
+-		goto put_dev_exit;
++		goto unlock_exit;
+ 	}
+ 
+-	pdata = dev_get_platdata(&port_pdev->dev);
+-
+-	mutex_lock(&pdata->lock);
+-	ret = dfl_feature_dev_use_begin(pdata, true);
+-	mutex_unlock(&pdata->lock);
++	mutex_lock(&fdata->lock);
++	ret = dfl_feature_dev_use_begin(fdata, true);
++	mutex_unlock(&fdata->lock);
+ 	if (ret)
+-		goto put_dev_exit;
++		goto unlock_exit;
+ 
+-	platform_device_del(port_pdev);
++	feature_dev_unregister(fdata);
+ 	cdev->released_port_num++;
+-put_dev_exit:
+-	put_device(&port_pdev->dev);
++
+ unlock_exit:
+ 	mutex_unlock(&cdev->lock);
+ 	return ret;
+@@ -1682,34 +1671,30 @@ EXPORT_SYMBOL_GPL(dfl_fpga_cdev_release_port);
+  */
+ int dfl_fpga_cdev_assign_port(struct dfl_fpga_cdev *cdev, int port_id)
+ {
+-	struct dfl_feature_platform_data *pdata;
+-	struct platform_device *port_pdev;
++	struct dfl_feature_dev_data *fdata;
+ 	int ret = -ENODEV;
+ 
+ 	mutex_lock(&cdev->lock);
+-	port_pdev = __dfl_fpga_cdev_find_port(cdev, &port_id,
+-					      dfl_fpga_check_port_id);
+-	if (!port_pdev)
++	fdata = __dfl_fpga_cdev_find_port_data(cdev, &port_id,
++					       dfl_fpga_check_port_id);
++	if (!fdata)
+ 		goto unlock_exit;
+ 
+-	if (device_is_registered(&port_pdev->dev)) {
++	if (fdata->dev) {
+ 		ret = -EBUSY;
+-		goto put_dev_exit;
++		goto unlock_exit;
+ 	}
+ 
+-	ret = platform_device_add(port_pdev);
++	ret = feature_dev_register(fdata);
+ 	if (ret)
+-		goto put_dev_exit;
+-
+-	pdata = dev_get_platdata(&port_pdev->dev);
++		goto unlock_exit;
+ 
+-	mutex_lock(&pdata->lock);
+-	dfl_feature_dev_use_end(pdata);
+-	mutex_unlock(&pdata->lock);
++	mutex_lock(&fdata->lock);
++	dfl_feature_dev_use_end(fdata);
++	mutex_unlock(&fdata->lock);
+ 
+ 	cdev->released_port_num--;
+-put_dev_exit:
+-	put_device(&port_pdev->dev);
++
+ unlock_exit:
+ 	mutex_unlock(&cdev->lock);
+ 	return ret;
+@@ -1719,10 +1704,11 @@ EXPORT_SYMBOL_GPL(dfl_fpga_cdev_assign_port);
+ static void config_port_access_mode(struct device *fme_dev, int port_id,
+ 				    bool is_vf)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(fme_dev);
+ 	void __iomem *base;
+ 	u64 v;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(fme_dev, FME_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
+ 
+ 	v = readq(base + FME_HDR_PORT_OFST(port_id));
+ 
+@@ -1746,14 +1732,14 @@ static void config_port_access_mode(struct device *fme_dev, int port_id,
+  */
+ void dfl_fpga_cdev_config_ports_pf(struct dfl_fpga_cdev *cdev)
+ {
+-	struct dfl_feature_platform_data *pdata;
++	struct dfl_feature_dev_data *fdata;
+ 
+ 	mutex_lock(&cdev->lock);
+-	list_for_each_entry(pdata, &cdev->port_dev_list, node) {
+-		if (device_is_registered(&pdata->dev->dev))
++	list_for_each_entry(fdata, &cdev->port_dev_list, node) {
++		if (fdata->dev)
+ 			continue;
+ 
+-		config_port_pf_mode(cdev->fme_dev, pdata->id);
++		config_port_pf_mode(cdev->fme_dev, fdata->id);
+ 	}
+ 	mutex_unlock(&cdev->lock);
+ }
+@@ -1772,7 +1758,7 @@ EXPORT_SYMBOL_GPL(dfl_fpga_cdev_config_ports_pf);
+  */
+ int dfl_fpga_cdev_config_ports_vf(struct dfl_fpga_cdev *cdev, int num_vfs)
+ {
+-	struct dfl_feature_platform_data *pdata;
++	struct dfl_feature_dev_data *fdata;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&cdev->lock);
+@@ -1788,11 +1774,11 @@ int dfl_fpga_cdev_config_ports_vf(struct dfl_fpga_cdev *cdev, int num_vfs)
+ 		goto done;
+ 	}
+ 
+-	list_for_each_entry(pdata, &cdev->port_dev_list, node) {
+-		if (device_is_registered(&pdata->dev->dev))
++	list_for_each_entry(fdata, &cdev->port_dev_list, node) {
++		if (fdata->dev)
+ 			continue;
+ 
+-		config_port_vf_mode(cdev->fme_dev, pdata->id);
++		config_port_vf_mode(cdev->fme_dev, fdata->id);
+ 	}
+ done:
+ 	mutex_unlock(&cdev->lock);
+@@ -1926,6 +1912,7 @@ long dfl_feature_ioctl_set_irq(struct platform_device *pdev,
+ 			       unsigned long arg)
+ {
+ 	struct dfl_feature_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	struct dfl_feature_dev_data *fdata = pdata->fdata;
+ 	struct dfl_fpga_irq_set hdr;
+ 	s32 *fds;
+ 	long ret;
+@@ -1945,9 +1932,9 @@ long dfl_feature_ioctl_set_irq(struct platform_device *pdev,
+ 	if (IS_ERR(fds))
+ 		return PTR_ERR(fds);
+ 
+-	mutex_lock(&pdata->lock);
++	mutex_lock(&fdata->lock);
+ 	ret = dfl_fpga_set_irq_triggers(feature, hdr.start, hdr.count, fds);
+-	mutex_unlock(&pdata->lock);
++	mutex_unlock(&fdata->lock);
+ 
+ 	kfree(fds);
+ 	return ret;
+diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
+index 26567b081e59..65b15fb35d82 100644
+--- a/drivers/fpga/dfl.h
++++ b/drivers/fpga/dfl.h
+@@ -147,6 +147,8 @@
+ #define PORT_UINT_CAP_INT_NUM	GENMASK_ULL(11, 0)	/* Interrupts num */
+ #define PORT_UINT_CAP_FST_VECT	GENMASK_ULL(23, 12)	/* First Vector */
+ 
++struct dfl_feature_dev_data;
++
+ /**
+  * struct dfl_fpga_port_ops - port ops
+  *
+@@ -160,15 +162,16 @@ struct dfl_fpga_port_ops {
+ 	const char *name;
+ 	struct module *owner;
+ 	struct list_head node;
+-	int (*get_id)(struct platform_device *pdev);
+-	int (*enable_set)(struct platform_device *pdev, bool enable);
++	int (*get_id)(struct dfl_feature_dev_data *fdata);
++	int (*enable_set)(struct dfl_feature_dev_data *fdata, bool enable);
+ };
+ 
+ void dfl_fpga_port_ops_add(struct dfl_fpga_port_ops *ops);
+ void dfl_fpga_port_ops_del(struct dfl_fpga_port_ops *ops);
+-struct dfl_fpga_port_ops *dfl_fpga_port_ops_get(struct platform_device *pdev);
++struct dfl_fpga_port_ops *
++	dfl_fpga_port_ops_get(struct dfl_feature_dev_data *fdata);
+ void dfl_fpga_port_ops_put(struct dfl_fpga_port_ops *ops);
+-int dfl_fpga_check_port_id(struct platform_device *pdev, void *pport_id);
++int dfl_fpga_check_port_id(struct dfl_feature_dev_data *fdata, void *pport_id);
+ 
+ /**
+  * struct dfl_feature_id - dfl private feature id
+@@ -233,26 +236,32 @@ struct dfl_feature {
+ #define FEATURE_DEV_ID_UNUSED	(-1)
+ 
+ /**
+- * struct dfl_feature_platform_data - platform data for feature devices
++ * struct dfl_feature_dev_data - dfl enumeration data for dfl feature dev.
+  *
+- * @node: node to link feature devs to container device's port_dev_list.
+- * @lock: mutex to protect platform data.
+- * @cdev: cdev of feature dev.
+- * @dev: ptr to platform device linked with this platform data.
++ * @node: node to link the data structure to container device's port_dev_list.
++ * @lock: mutex to protect feature dev data.
++ * @dev: ptr to the feature's platform device linked with this structure.
++ * @type: type of DFL FIU for the feature dev. See enum dfl_id_type.
++ * @pdev_id: platform device id for the feature dev.
++ * @pdev_name: platform device name for the feature dev.
+  * @dfl_cdev: ptr to container device.
+- * @id: id used for this feature device.
++ * @id: id used for the feature device.
+  * @disable_count: count for port disable.
+  * @excl_open: set on feature device exclusive open.
+  * @open_count: count for feature device open.
+  * @num: number for sub features.
+  * @private: ptr to feature dev private data.
+- * @features: sub features of this feature dev.
++ * @features: sub features for the feature dev.
++ * @resource_num: number of resources for the feature dev.
++ * @resources: resources for the feature dev.
+  */
+-struct dfl_feature_platform_data {
++struct dfl_feature_dev_data {
+ 	struct list_head node;
+ 	struct mutex lock;
+-	struct cdev cdev;
+ 	struct platform_device *dev;
++	enum dfl_id_type type;
++	int pdev_id;
++	const char *pdev_name;
+ 	struct dfl_fpga_cdev *dfl_cdev;
+ 	int id;
+ 	unsigned int disable_count;
+@@ -260,55 +269,68 @@ struct dfl_feature_platform_data {
+ 	int open_count;
+ 	void *private;
+ 	int num;
+-	struct dfl_feature features[];
++	struct dfl_feature *features;
++	int resource_num;
++	struct resource *resources;
++};
++
++/**
++ * struct dfl_feature_platform_data - platform data for feature devices
++ *
++ * @fdata: dfl enumeration data for the dfl feature device.
++ * @cdev: cdev of feature dev.
++ */
++struct dfl_feature_platform_data {
++	struct dfl_feature_dev_data *fdata;
++	struct cdev cdev;
+ };
+ 
+ static inline
+-int dfl_feature_dev_use_begin(struct dfl_feature_platform_data *pdata,
++int dfl_feature_dev_use_begin(struct dfl_feature_dev_data *fdata,
+ 			      bool excl)
+ {
+-	if (pdata->excl_open)
++	if (fdata->excl_open)
+ 		return -EBUSY;
+ 
+ 	if (excl) {
+-		if (pdata->open_count)
++		if (fdata->open_count)
+ 			return -EBUSY;
+ 
+-		pdata->excl_open = true;
++		fdata->excl_open = true;
+ 	}
+-	pdata->open_count++;
++	fdata->open_count++;
+ 
+ 	return 0;
+ }
+ 
+ static inline
+-void dfl_feature_dev_use_end(struct dfl_feature_platform_data *pdata)
++void dfl_feature_dev_use_end(struct dfl_feature_dev_data *fdata)
+ {
+-	pdata->excl_open = false;
++	fdata->excl_open = false;
+ 
+-	if (WARN_ON(pdata->open_count <= 0))
++	if (WARN_ON(fdata->open_count <= 0))
+ 		return;
+ 
+-	pdata->open_count--;
++	fdata->open_count--;
+ }
+ 
+ static inline
+-int dfl_feature_dev_use_count(struct dfl_feature_platform_data *pdata)
++int dfl_feature_dev_use_count(struct dfl_feature_dev_data *fdata)
+ {
+-	return pdata->open_count;
++	return fdata->open_count;
+ }
+ 
+ static inline
+-void dfl_fpga_pdata_set_private(struct dfl_feature_platform_data *pdata,
++void dfl_fpga_fdata_set_private(struct dfl_feature_dev_data *fdata,
+ 				void *private)
+ {
+-	pdata->private = private;
++	fdata->private = private;
+ }
+ 
+ static inline
+-void *dfl_fpga_pdata_get_private(struct dfl_feature_platform_data *pdata)
++void *dfl_fpga_fdata_get_private(struct dfl_feature_dev_data *fdata)
+ {
+-	return pdata->private;
++	return fdata->private;
+ }
+ 
+ struct dfl_feature_ops {
+@@ -338,30 +360,29 @@ struct platform_device *dfl_fpga_inode_to_feature_dev(struct inode *inode)
+ 
+ 	pdata = container_of(inode->i_cdev, struct dfl_feature_platform_data,
+ 			     cdev);
+-	return pdata->dev;
++	return pdata->fdata->dev;
+ }
+ 
+-#define dfl_fpga_dev_for_each_feature(pdata, feature)			    \
+-	for ((feature) = (pdata)->features;				    \
+-	   (feature) < (pdata)->features + (pdata)->num; (feature)++)
++#define dfl_fpga_dev_for_each_feature(fdata, feature)			    \
++	for ((feature) = (fdata)->features;				    \
++	   (feature) < (fdata)->features + (fdata)->num; (feature)++)
+ 
+-static inline
+-struct dfl_feature *dfl_get_feature_by_id(struct device *dev, u16 id)
++static inline struct dfl_feature *
++dfl_get_feature_by_id(struct dfl_feature_dev_data *fdata, u16 id)
+ {
+-	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
+ 	struct dfl_feature *feature;
+ 
+-	dfl_fpga_dev_for_each_feature(pdata, feature)
++	dfl_fpga_dev_for_each_feature(fdata, feature)
+ 		if (feature->id == id)
+ 			return feature;
+ 
+ 	return NULL;
+ }
+ 
+-static inline
+-void __iomem *dfl_get_feature_ioaddr_by_id(struct device *dev, u16 id)
++static inline void __iomem *
++dfl_get_feature_ioaddr_by_id(struct dfl_feature_dev_data *fdata, u16 id)
+ {
+-	struct dfl_feature *feature = dfl_get_feature_by_id(dev, id);
++	struct dfl_feature *feature = dfl_get_feature_by_id(fdata, id);
+ 
+ 	if (feature && feature->ioaddr)
+ 		return feature->ioaddr;
+@@ -370,24 +391,29 @@ void __iomem *dfl_get_feature_ioaddr_by_id(struct device *dev, u16 id)
+ 	return NULL;
+ }
+ 
+-static inline bool is_dfl_feature_present(struct device *dev, u16 id)
++static inline struct dfl_feature_dev_data *
++to_dfl_feature_dev_data(struct device *dev)
+ {
+-	return !!dfl_get_feature_ioaddr_by_id(dev, id);
++	struct dfl_feature_platform_data *pdata = dev_get_platdata(dev);
++
++	return pdata->fdata;
+ }
+ 
+ static inline u64 dfl_get_bitstream_id(struct device *dev)
+ {
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
++
+ 	void __iomem *base;
+ 
+-	base = dfl_get_feature_ioaddr_by_id(dev, FME_FEATURE_ID_HEADER);
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
+ 
+ 	return readq(base + FME_HDR_BITSTREAM_ID);
+ }
+ 
+ static inline
+-struct device *dfl_fpga_pdata_to_parent(struct dfl_feature_platform_data *pdata)
++struct device *dfl_fpga_fdata_to_parent(struct dfl_feature_dev_data *fdata)
+ {
+-	return pdata->dev->dev.parent->parent;
++	return fdata->dev->dev.parent->parent;
+ }
+ 
+ /**
+@@ -448,26 +474,23 @@ struct dfl_fpga_cdev *
+ dfl_fpga_feature_devs_enumerate(struct dfl_fpga_enum_info *info);
+ void dfl_fpga_feature_devs_remove(struct dfl_fpga_cdev *cdev);
+ 
+-/*
+- * need to drop the device reference with put_device() after use port platform
+- * device returned by __dfl_fpga_cdev_find_port and dfl_fpga_cdev_find_port
+- * functions.
+- */
+-struct platform_device *
+-__dfl_fpga_cdev_find_port(struct dfl_fpga_cdev *cdev, void *data,
+-			  int (*match)(struct platform_device *, void *));
++struct dfl_feature_dev_data *
++__dfl_fpga_cdev_find_port_data(struct dfl_fpga_cdev *cdev, void *data,
++			       int (*match)(struct dfl_feature_dev_data *,
++					    void *));
+ 
+-static inline struct platform_device *
+-dfl_fpga_cdev_find_port(struct dfl_fpga_cdev *cdev, void *data,
+-			int (*match)(struct platform_device *, void *))
++static inline struct dfl_feature_dev_data *
++dfl_fpga_cdev_find_port_data(struct dfl_fpga_cdev *cdev, void *data,
++			     int (*match)(struct dfl_feature_dev_data *,
++					  void *))
+ {
+-	struct platform_device *pdev;
++	struct dfl_feature_dev_data *fdata;
+ 
+ 	mutex_lock(&cdev->lock);
+-	pdev = __dfl_fpga_cdev_find_port(cdev, data, match);
++	fdata = __dfl_fpga_cdev_find_port_data(cdev, data, match);
+ 	mutex_unlock(&cdev->lock);
+ 
+-	return pdev;
++	return fdata;
+ }
+ 
+ int dfl_fpga_cdev_release_port(struct dfl_fpga_cdev *cdev, int port_id);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0070-Revert-fpga-dfl-add-the-userspace-I-O-device-support.patch new/debian/patches/fpga-ofs/0070-Revert-fpga-dfl-add-the-userspace-I-O-device-support.patch
--- org/debian/patches/fpga-ofs/0070-Revert-fpga-dfl-add-the-userspace-I-O-device-support.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0070-Revert-fpga-dfl-add-the-userspace-I-O-device-support.patch	2021-07-20 06:17:11.440844765 +0200
@@ -0,0 +1,139 @@
+From 4aee1ca0f52d2898f107ed71aa9b714ea3285ad8 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Wed, 3 Mar 2021 14:08:18 -0800
+Subject: [PATCH 070/149] Revert "fpga: dfl: add the userspace I/O device
+ support for DFL devices"
+
+This reverts commit c41be607a04de171790349af88ec44f4d7677e59.
+
+This will be upgraded to the v11 patchset being upstreamed.
+---
+ drivers/fpga/Kconfig        | 10 -----
+ drivers/fpga/Makefile       |  1 -
+ drivers/fpga/dfl-uio-pdev.c | 81 -------------------------------------
+ 3 files changed, 92 deletions(-)
+ delete mode 100644 drivers/fpga/dfl-uio-pdev.c
+
+diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
+index 691c6ae2f5d0..d78f35dd9bc1 100644
+--- a/drivers/fpga/Kconfig
++++ b/drivers/fpga/Kconfig
+@@ -203,16 +203,6 @@ config FPGA_DFL_NIOS_INTEL_PAC_N3000
+ 	  the card. It also instantiates the SPI master (spi-altera) for
+ 	  the card's BMC (Board Management Controller).
+ 
+-config FPGA_DFL_UIO_PDEV
+-	tristate "FPGA DFL Driver for Userspace I/O platform devices"
+-	depends on FPGA_DFL && UIO_PDRV_GENIRQ
+-	help
+-	  Enable this to allow some DFL drivers be written in userspace. It
+-	  adds the uio_pdrv_genirq platform device with the DFL device's
+-	  resources, and lets the generic UIO platform device driver provide
+-	  support to userspace access to kernel interrupts and memory
+-	  locations.
+-
+ config FPGA_DFL_SPI_ALTERA
+ 	tristate "FPGA DFL Altera SPI Master Driver"
+ 	depends on FPGA_DFL
+diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
+index 849a39b6dd74..1a5dfd668ad4 100644
+--- a/drivers/fpga/Makefile
++++ b/drivers/fpga/Makefile
+@@ -51,7 +51,6 @@ dfl-afu-objs := dfl-afu-main.o dfl-afu-region.o dfl-afu-dma-region.o
+ dfl-afu-objs += dfl-afu-error.o
+ 
+ obj-$(CONFIG_FPGA_DFL_NIOS_INTEL_PAC_N3000)	+= dfl-n3000-nios.o
+-obj-$(CONFIG_FPGA_DFL_UIO_PDEV)	+= dfl-uio-pdev.o
+ obj-$(CONFIG_FPGA_DFL_SPI_ALTERA)	+= dfl-spi-altera.o
+ 
+ # Drivers for FPGAs which implement DFL
+diff --git a/drivers/fpga/dfl-uio-pdev.c b/drivers/fpga/dfl-uio-pdev.c
+deleted file mode 100644
+index dcb6bd1c616b..000000000000
+--- a/drivers/fpga/dfl-uio-pdev.c
++++ /dev/null
+@@ -1,81 +0,0 @@
+-// SPDX-License-Identifier: GPL-2.0
+-/*
+- * DFL driver for Userspace I/O platform devices
+- *
+- * Copyright (C) 2020 Intel Corporation, Inc.
+- */
+-#include <linux/dfl.h>
+-#include <linux/errno.h>
+-#include <linux/kernel.h>
+-#include <linux/module.h>
+-#include <linux/platform_device.h>
+-#include <linux/slab.h>
+-#include <linux/uio_driver.h>
+-
+-#define DRIVER_NAME "dfl-uio-pdev"
+-
+-static int dfl_uio_pdev_probe(struct dfl_device *ddev)
+-{
+-	struct device *dev = &ddev->dev;
+-	struct platform_device_info pdevinfo = { 0 };
+-	struct uio_info uio_pdata = { 0 };
+-	struct platform_device *uio_pdev;
+-	struct resource *res;
+-	int i;
+-
+-	pdevinfo.name = "uio_pdrv_genirq";
+-
+-	res = kcalloc(ddev->num_irqs + 1, sizeof(*res), GFP_KERNEL);
+-	if (!res)
+-		return -ENOMEM;
+-
+-	res[0].parent = &ddev->mmio_res;
+-	res[0].flags = IORESOURCE_MEM;
+-	res[0].start = ddev->mmio_res.start;
+-	res[0].end = ddev->mmio_res.end;
+-
+-	/* then add irq resource */
+-	for (i = 0; i < ddev->num_irqs; i++) {
+-		res[i + 1].flags = IORESOURCE_IRQ;
+-		res[i + 1].start = ddev->irqs[i];
+-		res[i + 1].end = ddev->irqs[i];
+-	}
+-
+-	uio_pdata.name = DRIVER_NAME;
+-	uio_pdata.version = "0";
+-
+-	pdevinfo.res = res;
+-	pdevinfo.num_res = ddev->num_irqs + 1;
+-	pdevinfo.parent = &ddev->dev;
+-	pdevinfo.id = PLATFORM_DEVID_AUTO;
+-	pdevinfo.data = &uio_pdata;
+-	pdevinfo.size_data = sizeof(uio_pdata);
+-
+-	uio_pdev = platform_device_register_full(&pdevinfo);
+-	if (!IS_ERR(uio_pdev))
+-		dev_set_drvdata(dev, uio_pdev);
+-
+-	kfree(res);
+-
+-	return PTR_ERR_OR_ZERO(uio_pdev);
+-}
+-
+-static void dfl_uio_pdev_remove(struct dfl_device *ddev)
+-{
+-	struct platform_device *uio_pdev = dev_get_drvdata(&ddev->dev);
+-
+-	platform_device_unregister(uio_pdev);
+-}
+-
+-static struct dfl_driver dfl_uio_pdev_driver = {
+-	.drv	= {
+-		.name       = DRIVER_NAME,
+-	},
+-	.probe	= dfl_uio_pdev_probe,
+-	.remove	= dfl_uio_pdev_remove,
+-};
+-module_dfl_driver(dfl_uio_pdev_driver);
+-
+-MODULE_DESCRIPTION("DFL driver for Userspace I/O platform devices");
+-MODULE_AUTHOR("Intel Corporation");
+-MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0071-Revert-fpga-dfl-add-driver_override-support.patch new/debian/patches/fpga-ofs/0071-Revert-fpga-dfl-add-driver_override-support.patch
--- org/debian/patches/fpga-ofs/0071-Revert-fpga-dfl-add-driver_override-support.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0071-Revert-fpga-dfl-add-driver_override-support.patch	2021-07-20 06:17:11.444844754 +0200
@@ -0,0 +1,152 @@
+From 537becc64920ab661aab9224681ce9a7d45ab439 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Wed, 3 Mar 2021 14:09:34 -0800
+Subject: [PATCH 071/149] Revert "fpga: dfl: add driver_override support"
+
+This reverts commit 8d4b8d6088974c1810b74f9b6c739c690cd7fbfe.
+
+This will be updated to the v11 patchset being upstreamed.
+---
+ Documentation/ABI/testing/sysfs-bus-dfl | 21 ----------
+ drivers/fpga/dfl.c                      | 54 +------------------------
+ include/linux/dfl.h                     |  2 -
+ 3 files changed, 1 insertion(+), 76 deletions(-)
+
+diff --git a/Documentation/ABI/testing/sysfs-bus-dfl b/Documentation/ABI/testing/sysfs-bus-dfl
+index 679981eec897..b0265ab17200 100644
+--- a/Documentation/ABI/testing/sysfs-bus-dfl
++++ b/Documentation/ABI/testing/sysfs-bus-dfl
+@@ -15,24 +15,3 @@ Description:	Read-only. It returns feature identifier local to its DFL FIU
+ 		type.
+ 
+ 		Format: 0x%x
+-
+-What:		/sys/bus/dfl/devices/.../driver_override
+-Date:		Oct 2020
+-KernelVersion:	5.11
+-Contact:	Xu Yilun <yilun.xu@intel.com>
+-Description:	This file allows the driver for a device to be specified which
+-		will override the standard ID table matching. When specified,
+-		only a driver with a name matching the value written to
+-		driver_override will have an opportunity to bind to the device.
+-		The override is specified by writing a string to the
+-		driver_override file (echo dfl-uio-pdev > driver_override) and
+-		may be cleared with an empty string (echo > driver_override).
+-		This returns the device to standard matching rules binding.
+-		Writing to driver_override does not automatically unbind the
+-		device from its current driver or make any attempt to
+-		automatically load the specified driver.  If no driver with a
+-		matching name is currently loaded in the kernel, the device
+-		will not bind to any driver.  This also allows devices to
+-		opt-out of driver binding using a driver_override name such as
+-		"none".  Only a single driver may be specified in the override,
+-		there is no support for parsing delimiters.
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index 8ead608d1df6..d993f4d34754 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -251,10 +251,6 @@ static int dfl_bus_match(struct device *dev, struct device_driver *drv)
+ 	struct dfl_driver *ddrv = to_dfl_drv(drv);
+ 	const struct dfl_device_id *id_entry;
+ 
+-	/* When driver_override is set, only bind to the matching driver */
+-	if (ddev->driver_override)
+-		return !strcmp(ddev->driver_override, drv->name);
+-
+ 	id_entry = ddrv->id_table;
+ 	if (id_entry) {
+ 		while (id_entry->feature_id) {
+@@ -296,53 +292,6 @@ static int dfl_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
+ 			      ddev->type, ddev->feature_id);
+ }
+ 
+-static ssize_t driver_override_show(struct device *dev,
+-				    struct device_attribute *attr, char *buf)
+-{
+-	struct dfl_device *ddev = to_dfl_dev(dev);
+-	ssize_t len;
+-
+-	device_lock(dev);
+-	len = sysfs_emit(buf, "%s\n", ddev->driver_override);
+-	device_unlock(dev);
+-	return len;
+-}
+-
+-static ssize_t driver_override_store(struct device *dev,
+-				     struct device_attribute *attr,
+-				     const char *buf, size_t count)
+-{
+-	struct dfl_device *ddev = to_dfl_dev(dev);
+-	char *driver_override, *old, *cp;
+-
+-	/* We need to keep extra room for a newline */
+-	if (count >= (PAGE_SIZE - 1))
+-		return -EINVAL;
+-
+-	driver_override = kstrndup(buf, count, GFP_KERNEL);
+-	if (!driver_override)
+-		return -ENOMEM;
+-
+-	cp = strchr(driver_override, '\n');
+-	if (cp)
+-		*cp = '\0';
+-
+-	device_lock(dev);
+-	old = ddev->driver_override;
+-	if (strlen(driver_override)) {
+-		ddev->driver_override = driver_override;
+-	} else {
+-		kfree(driver_override);
+-		ddev->driver_override = NULL;
+-	}
+-	device_unlock(dev);
+-
+-	kfree(old);
+-
+-	return count;
+-}
+-static DEVICE_ATTR_RW(driver_override);
+-
+ static ssize_t
+ type_show(struct device *dev, struct device_attribute *attr, char *buf)
+ {
+@@ -364,7 +313,6 @@ static DEVICE_ATTR_RO(feature_id);
+ static struct attribute *dfl_dev_attrs[] = {
+ 	&dev_attr_type.attr,
+ 	&dev_attr_feature_id.attr,
+-	&dev_attr_driver_override.attr,
+ 	NULL,
+ };
+ ATTRIBUTE_GROUPS(dfl_dev);
+@@ -510,7 +458,7 @@ static int dfl_devs_add(struct dfl_feature_dev_data *fdata)
+ 
+ int __dfl_driver_register(struct dfl_driver *dfl_drv, struct module *owner)
+ {
+-	if (!dfl_drv || !dfl_drv->probe)
++	if (!dfl_drv || !dfl_drv->probe || !dfl_drv->id_table)
+ 		return -EINVAL;
+ 
+ 	dfl_drv->drv.owner = owner;
+diff --git a/include/linux/dfl.h b/include/linux/dfl.h
+index b36c2be63bd1..64d36fe5894d 100644
+--- a/include/linux/dfl.h
++++ b/include/linux/dfl.h
+@@ -34,7 +34,6 @@ enum dfl_id_type {
+  * @num_irqs: number of IRQs supported by this dfl device.
+  * @cdev: pointer to DFL FPGA container device this dfl device belongs to.
+  * @id_entry: matched id entry in dfl driver's id table.
+- * @driver_override: driver name to force a match
+  */
+ struct dfl_device {
+ 	struct device dev;
+@@ -46,7 +45,6 @@ struct dfl_device {
+ 	unsigned int num_irqs;
+ 	struct dfl_fpga_cdev *cdev;
+ 	const struct dfl_device_id *id_entry;
+-	char *driver_override;
+ };
+ 
+ /**
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0072-uio-uio_dfl-add-userspace-i-o-driver-for-DFL-bus.patch new/debian/patches/fpga-ofs/0072-uio-uio_dfl-add-userspace-i-o-driver-for-DFL-bus.patch
--- org/debian/patches/fpga-ofs/0072-uio-uio_dfl-add-userspace-i-o-driver-for-DFL-bus.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0072-uio-uio_dfl-add-userspace-i-o-driver-for-DFL-bus.patch	2021-07-20 06:17:11.456844719 +0200
@@ -0,0 +1,143 @@
+From 8249f8b9c30332aa9d9d2286a177826f56715adb Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Sat, 27 Feb 2021 23:27:03 +0800
+Subject: [PATCH 072/149] uio: uio_dfl: add userspace i/o driver for DFL bus
+
+This patch supports the DFL drivers be written in userspace. This is
+realized by exposing the userspace I/O device interfaces.
+
+The driver now only binds the ether group feature, which has no irq. So
+the irq support is not implemented yet.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+---
+ MAINTAINERS           |  1 +
+ drivers/uio/Kconfig   | 17 +++++++++++
+ drivers/uio/Makefile  |  1 +
+ drivers/uio/uio_dfl.c | 66 +++++++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 85 insertions(+)
+ create mode 100644 drivers/uio/uio_dfl.c
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 3eccdcfc7984..2462214cf2fa 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -6895,6 +6895,7 @@ S:	Maintained
+ F:	Documentation/ABI/testing/sysfs-bus-dfl*
+ F:	Documentation/fpga/dfl.rst
+ F:	drivers/fpga/dfl*
++F:	drivers/uio/uio_dfl.c
+ F:	include/linux/dfl.h
+ F:	include/uapi/linux/fpga-dfl.h
+ 
+diff --git a/drivers/uio/Kconfig b/drivers/uio/Kconfig
+index 202ee81cfc2b..5531f3afeb21 100644
+--- a/drivers/uio/Kconfig
++++ b/drivers/uio/Kconfig
+@@ -165,4 +165,21 @@ config UIO_HV_GENERIC
+ 	  to network and storage devices from userspace.
+ 
+ 	  If you compile this as a module, it will be called uio_hv_generic.
++
++config UIO_DFL
++	tristate "Generic driver for DFL (Device Feature List) bus"
++	depends on FPGA_DFL
++	help
++	  Generic DFL (Device Feature List) driver for Userspace I/O devices.
++	  It is useful to provide direct access to DFL devices from userspace.
++	  A sample userspace application using this driver is available for
++	  download in a git repository:
++
++	    git clone https://github.com/OPAE/opae-sdk.git
++
++	  It could be found at:
++
++	    opae-sdk/tools/libopaeuio/
++
++	  If you compile this as a module, it will be called uio_dfl.
+ endif
+diff --git a/drivers/uio/Makefile b/drivers/uio/Makefile
+index c285dd2a4539..f2f416a14228 100644
+--- a/drivers/uio/Makefile
++++ b/drivers/uio/Makefile
+@@ -11,3 +11,4 @@ obj-$(CONFIG_UIO_PRUSS)         += uio_pruss.o
+ obj-$(CONFIG_UIO_MF624)         += uio_mf624.o
+ obj-$(CONFIG_UIO_FSL_ELBC_GPCM)	+= uio_fsl_elbc_gpcm.o
+ obj-$(CONFIG_UIO_HV_GENERIC)	+= uio_hv_generic.o
++obj-$(CONFIG_UIO_DFL)	+= uio_dfl.o
+diff --git a/drivers/uio/uio_dfl.c b/drivers/uio/uio_dfl.c
+new file mode 100644
+index 000000000000..89c0fc7b0cbc
+--- /dev/null
++++ b/drivers/uio/uio_dfl.c
+@@ -0,0 +1,66 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Generic DFL driver for Userspace I/O devicess
++ *
++ * Copyright (C) 2021 Intel Corporation, Inc.
++ */
++#include <linux/dfl.h>
++#include <linux/errno.h>
++#include <linux/module.h>
++#include <linux/uio_driver.h>
++
++#define DRIVER_NAME "uio_dfl"
++
++static int uio_dfl_probe(struct dfl_device *ddev)
++{
++	struct resource *r = &ddev->mmio_res;
++	struct device *dev = &ddev->dev;
++	struct uio_info *uioinfo;
++	struct uio_mem *uiomem;
++	int ret;
++
++	uioinfo = devm_kzalloc(dev, sizeof(struct uio_info), GFP_KERNEL);
++	if (!uioinfo)
++		return -ENOMEM;
++
++	uioinfo->name = DRIVER_NAME;
++	uioinfo->version = "0";
++
++	uiomem = &uioinfo->mem[0];
++	uiomem->memtype = UIO_MEM_PHYS;
++	uiomem->addr = r->start & PAGE_MASK;
++	uiomem->offs = r->start & ~PAGE_MASK;
++	uiomem->size = (uiomem->offs + resource_size(r)
++			+ PAGE_SIZE - 1) & PAGE_MASK;
++	uiomem->name = r->name;
++
++	/* Irq is yet to be supported */
++	uioinfo->irq = UIO_IRQ_NONE;
++
++	ret = devm_uio_register_device(dev, uioinfo);
++	if (ret)
++		dev_err(dev, "unable to register uio device\n");
++
++	return ret;
++}
++
++#define FME_FEATURE_ID_ETH_GROUP	0x10
++
++static const struct dfl_device_id uio_dfl_ids[] = {
++	{ FME_ID, FME_FEATURE_ID_ETH_GROUP },
++	{ }
++};
++MODULE_DEVICE_TABLE(dfl, uio_dfl_ids);
++
++static struct dfl_driver uio_dfl_driver = {
++	.drv = {
++		.name = DRIVER_NAME,
++	},
++	.id_table	= uio_dfl_ids,
++	.probe		= uio_dfl_probe,
++};
++module_dfl_driver(uio_dfl_driver);
++
++MODULE_DESCRIPTION("Generic DFL driver for Userspace I/O devices");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0073-Documentation-fpga-dfl-Add-description-for-DFL-UIO-s.patch new/debian/patches/fpga-ofs/0073-Documentation-fpga-dfl-Add-description-for-DFL-UIO-s.patch
--- org/debian/patches/fpga-ofs/0073-Documentation-fpga-dfl-Add-description-for-DFL-UIO-s.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0073-Documentation-fpga-dfl-Add-description-for-DFL-UIO-s.patch	2021-07-20 06:17:11.456844719 +0200
@@ -0,0 +1,54 @@
+From 128d573947df393b0948155b0680c752c9f8d664 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Sat, 27 Feb 2021 23:27:04 +0800
+Subject: [PATCH 073/149] Documentation: fpga: dfl: Add description for DFL UIO
+ support
+
+This patch adds description for UIO support for dfl devices on DFL
+bus.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+Reviewed-by: Wu Hao <hao.wu@intel.com>
+---
+ Documentation/fpga/dfl.rst | 24 ++++++++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+
+diff --git a/Documentation/fpga/dfl.rst b/Documentation/fpga/dfl.rst
+index 0404fe6ffc74..5cee979417b9 100644
+--- a/Documentation/fpga/dfl.rst
++++ b/Documentation/fpga/dfl.rst
+@@ -502,6 +502,30 @@ FME Partial Reconfiguration Sub Feature driver (see drivers/fpga/dfl-fme-pr.c)
+ could be a reference.
+ 
+ 
++Userspace driver support for DFL devices
++========================================
++The purpose of an FPGA is to be reprogrammed with newly developed hardware
++components. New hardware can instantiate a new private feature in the DFL, and
++then present a DFL device in the system. In some cases users may need a
++userspace driver for the DFL device:
++
++* Users may need to run some diagnostic test for their hardware.
++* Users may prototype the kernel driver in user space.
++* Some hardware is designed for specific purposes and does not fit into one of
++  the standard kernel subsystems.
++
++This requires direct access to MMIO space and interrupt handling from
++userspace. The uio_dfl module exposes the UIO device interfaces for this
++purpose.
++
++Currently the uio_dfl driver only supports the Ether Group sub feature, which
++has no irq in hardware. So the interrupt handling is not added in this driver.
++
++UIO_DFL should be selected to enable the uio_dfl module driver. To support a
++new DFL feature via UIO direct access, its feature id should be added to the
++driver's id_table.
++
++
+ Open discussion
+ ===============
+ FME driver exports one ioctl (DFL_FPGA_FME_PORT_PR) for partial reconfiguration
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0074-dfl-update-UIO-config.patch new/debian/patches/fpga-ofs/0074-dfl-update-UIO-config.patch
--- org/debian/patches/fpga-ofs/0074-dfl-update-UIO-config.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0074-dfl-update-UIO-config.patch	2021-07-20 06:17:11.456844719 +0200
@@ -0,0 +1,30 @@
+From 377ced640500803fa7feeae0fbeaba11f68bd08b Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Wed, 3 Mar 2021 11:30:32 -0800
+Subject: [PATCH 074/149] dfl: update UIO config
+
+The UIO dfl code has been upgraded to the v11 patchset
+being upstreamed.  Keep the config up to date.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ configs/n3000_d5005_defconfig | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+diff --git a/configs/n3000_d5005_defconfig b/configs/n3000_d5005_defconfig
+index 79c66efcca59..159c072ea296 100644
+--- a/configs/n3000_d5005_defconfig
++++ b/configs/n3000_d5005_defconfig
+@@ -17,8 +17,7 @@ CONFIG_FPGA_REGION=m
+ CONFIG_FPGA_SEC_MGR=m
+ CONFIG_IFPGA_M10_BMC_SECURE=m
+ 
+-CONFIG_UIO_PDRV_GENIRQ=m
+-CONFIG_FPGA_DFL_UIO_PDEV=m
++CONFIG_UIO_DFL=m
+ 
+ CONFIG_SENSORS_INTEL_M10_BMC_HWMON=m
+ CONFIG_MFD_INTEL_M10_BMC=m
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0075-dfl-disable-CONFIG_FPGA_DFL_ETH_GROUP.patch new/debian/patches/fpga-ofs/0075-dfl-disable-CONFIG_FPGA_DFL_ETH_GROUP.patch
--- org/debian/patches/fpga-ofs/0075-dfl-disable-CONFIG_FPGA_DFL_ETH_GROUP.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0075-dfl-disable-CONFIG_FPGA_DFL_ETH_GROUP.patch	2021-07-20 06:17:11.456844719 +0200
@@ -0,0 +1,29 @@
+From a4eef39d31f8f9eff2fd72ede33580d4298c590e Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Mon, 8 Mar 2021 13:15:51 -0800
+Subject: [PATCH 075/149] dfl: disable CONFIG_FPGA_DFL_ETH_GROUP
+
+Since the ethernet group was rejected by Linux kernel,
+remove the config variable since it is replaced with CONFIG_DFL_UIO.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ configs/n3000_d5005_defconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/configs/n3000_d5005_defconfig b/configs/n3000_d5005_defconfig
+index 159c072ea296..ffcc122c4101 100644
+--- a/configs/n3000_d5005_defconfig
++++ b/configs/n3000_d5005_defconfig
+@@ -24,7 +24,7 @@ CONFIG_MFD_INTEL_M10_BMC=m
+ 
+ CONFIG_SPI_ALTERA=m
+ 
+-CONFIG_FPGA_DFL_ETH_GROUP=m
++# CONFIG_FPGA_DFL_ETH_GROUP is not set
+ CONFIG_INTEL_S10_PHY=m
+ CONFIG_INTEL_M10_BMC_RETIMER=m
+ CONFIG_S10HSSI=m
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0076-uio-uio_dfl-add-interrupt-support.patch new/debian/patches/fpga-ofs/0076-uio-uio_dfl-add-interrupt-support.patch
--- org/debian/patches/fpga-ofs/0076-uio-uio_dfl-add-interrupt-support.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0076-uio-uio_dfl-add-interrupt-support.patch	2021-07-20 06:17:11.456844719 +0200
@@ -0,0 +1,149 @@
+From 7769f4fe909b9146c0812cabf1a7c5835d4aa235 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Mon, 25 Jan 2021 10:37:03 +0800
+Subject: [PATCH 076/149] uio: uio_dfl: add interrupt support
+
+This patch is now hold internally cause there is no need to add
+interrupt capable DFL features for UIO.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+---
+ drivers/uio/uio_dfl.c | 97 ++++++++++++++++++++++++++++++++++++++++---
+ 1 file changed, 92 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/uio/uio_dfl.c b/drivers/uio/uio_dfl.c
+index 89c0fc7b0cbc..e0fab0c597e6 100644
+--- a/drivers/uio/uio_dfl.c
++++ b/drivers/uio/uio_dfl.c
+@@ -6,27 +6,85 @@
+  */
+ #include <linux/dfl.h>
+ #include <linux/errno.h>
++#include <linux/interrupt.h>
++#include <linux/irq.h>
+ #include <linux/module.h>
++#include <linux/spinlock.h>
+ #include <linux/uio_driver.h>
+ 
+ #define DRIVER_NAME "uio_dfl"
+ 
++struct uio_dfl_dev {
++	struct device *dev;
++	struct uio_info uioinfo;
++	spinlock_t lock;	/* Serializes the irq handler and irqcontrol */
++	unsigned long flags;
++};
++
++static irqreturn_t uio_dfl_handler(int irq, struct uio_info *uioinfo)
++{
++	struct uio_dfl_dev *udd = uioinfo->priv;
++
++	/* Just disable the interrupt in the interrupt controller, and
++	 * remember the state so we can allow user space to enable it later.
++	 */
++
++	spin_lock(&udd->lock);
++	if (!__test_and_set_bit(0, &udd->flags))
++		disable_irq_nosync(irq);
++	spin_unlock(&udd->lock);
++
++	return IRQ_HANDLED;
++}
++
++static int uio_dfl_irqcontrol(struct uio_info *uioinfo, s32 irq_on)
++{
++	struct uio_dfl_dev *udd = uioinfo->priv;
++	unsigned long flags;
++
++	/* Allow user space to enable and disable the interrupt
++	 * in the interrupt controller, but keep track of the
++	 * state to prevent per-irq depth damage.
++	 *
++	 * Serialize this operation to support multiple tasks and concurrency
++	 * with irq handler on SMP systems.
++	 */
++
++	spin_lock_irqsave(&udd->lock, flags);
++	if (irq_on) {
++		if (__test_and_clear_bit(0, &udd->flags))
++			enable_irq(uioinfo->irq);
++	} else {
++		if (!__test_and_set_bit(0, &udd->flags))
++			disable_irq_nosync(uioinfo->irq);
++	}
++	spin_unlock_irqrestore(&udd->lock, flags);
++
++	return 0;
++}
++
+ static int uio_dfl_probe(struct dfl_device *ddev)
+ {
+ 	struct resource *r = &ddev->mmio_res;
+ 	struct device *dev = &ddev->dev;
+ 	struct uio_info *uioinfo;
++	struct uio_dfl_dev *udd;
+ 	struct uio_mem *uiomem;
+ 	int ret;
+ 
+-	uioinfo = devm_kzalloc(dev, sizeof(struct uio_info), GFP_KERNEL);
+-	if (!uioinfo)
++	udd = devm_kzalloc(dev, sizeof(*udd), GFP_KERNEL);
++	if (!udd)
+ 		return -ENOMEM;
+ 
++	spin_lock_init(&udd->lock);
++	udd->flags = 0; /* interrupt is enabled to begin with */
++	udd->dev = &ddev->dev;
++
++	uioinfo = &udd->uioinfo;
+ 	uioinfo->name = DRIVER_NAME;
+ 	uioinfo->version = "0";
+ 
+-	uiomem = &uioinfo->mem[0];
++	uiomem = &udd->uioinfo.mem[0];
+ 	uiomem->memtype = UIO_MEM_PHYS;
+ 	uiomem->addr = r->start & PAGE_MASK;
+ 	uiomem->offs = r->start & ~PAGE_MASK;
+@@ -34,8 +92,37 @@ static int uio_dfl_probe(struct dfl_device *ddev)
+ 			+ PAGE_SIZE - 1) & PAGE_MASK;
+ 	uiomem->name = r->name;
+ 
+-	/* Irq is yet to be supported */
+-	uioinfo->irq = UIO_IRQ_NONE;
++	if (ddev->num_irqs) {
++		if (ddev->num_irqs > 1)
++			dev_warn(dev,
++				 "%d irqs for %s, but UIO only supports the first one\n",
++				 ddev->num_irqs, dev_name(dev));
++
++		uioinfo->irq = ddev->irqs[0];
++	} else {
++		uioinfo->irq = UIO_IRQ_NONE;
++	}
++
++	if (uioinfo->irq) {
++		struct irq_data *irq_data = irq_get_irq_data(uioinfo->irq);
++
++		/*
++		 * If a level interrupt, dont do lazy disable. Otherwise the
++		 * irq will fire again since clearing of the actual cause, on
++		 * device level, is done in userspace
++		 * irqd_is_level_type() isn't used since isn't valid until
++		 * irq is configured.
++		 */
++		if (irq_data &&
++		    irqd_get_trigger_type(irq_data) & IRQ_TYPE_LEVEL_MASK) {
++			dev_dbg(dev, "disable lazy unmask\n");
++			irq_set_status_flags(uioinfo->irq, IRQ_DISABLE_UNLAZY);
++		}
++	}
++
++	uioinfo->handler = uio_dfl_handler;
++	uioinfo->irqcontrol = uio_dfl_irqcontrol;
++	uioinfo->priv = udd;
+ 
+ 	ret = devm_uio_register_device(dev, uioinfo);
+ 	if (ret)
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0077-dfl-Fix-include-guards-for-linux-dfl.h.patch new/debian/patches/fpga-ofs/0077-dfl-Fix-include-guards-for-linux-dfl.h.patch
--- org/debian/patches/fpga-ofs/0077-dfl-Fix-include-guards-for-linux-dfl.h.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0077-dfl-Fix-include-guards-for-linux-dfl.h.patch	2021-07-20 06:17:11.456844719 +0200
@@ -0,0 +1,36 @@
+From 22b958fdcb74e53a1d5f3f494f8a4a8bafa53097 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 16:17:18 -0700
+Subject: [PATCH 077/149] dfl: Fix include guards for linux/dfl.h
+
+Rename include guards from __LINUX_FPGA_DFL_H to __LINUX_DFL_H
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ include/linux/dfl.h | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/include/linux/dfl.h b/include/linux/dfl.h
+index 64d36fe5894d..0593ee85fb13 100644
+--- a/include/linux/dfl.h
++++ b/include/linux/dfl.h
+@@ -5,8 +5,8 @@
+  * Copyright (C) 2020 Intel Corporation, Inc.
+  */
+ 
+-#ifndef __LINUX_FPGA_DFL_H
+-#define __LINUX_FPGA_DFL_H
++#ifndef __LINUX_DFL_H
++#define __LINUX_DFL_H
+ 
+ #include <linux/bitfield.h>
+ #include <linux/device.h>
+@@ -138,4 +138,4 @@ static inline u8 dfl_feature_revision(void __iomem *base)
+ 	return (u8)FIELD_GET(DFH_REVISION, readq(base + DFH));
+ }
+ 
+-#endif /* __LINUX_FPGA_DFL_H */
++#endif /* __LINUX_DFL_H */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0078-fpga-dfl-Fix-retimer-initialization-check.patch new/debian/patches/fpga-ofs/0078-fpga-dfl-Fix-retimer-initialization-check.patch
--- org/debian/patches/fpga-ofs/0078-fpga-dfl-Fix-retimer-initialization-check.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0078-fpga-dfl-Fix-retimer-initialization-check.patch	2021-07-20 06:17:11.456844719 +0200
@@ -0,0 +1,29 @@
+From e1ccc97e496760ec688c8bc78421c62a26ee4d6e Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 16:42:54 -0700
+Subject: [PATCH 078/149] fpga: dfl: Fix retimer initialization check
+
+Change logical or to intended bitwise or in check for retimer
+initialization.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl-n3000-nios.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/dfl-n3000-nios.c b/drivers/fpga/dfl-n3000-nios.c
+index dc0392c00bd4..15e32e290278 100644
+--- a/drivers/fpga/dfl-n3000-nios.c
++++ b/drivers/fpga/dfl-n3000-nios.c
+@@ -342,7 +342,7 @@ static int n3000_nios_init_done_check(struct n3000_nios *nn)
+ 			return ret;
+ 
+ 		/* check if retimers are initialized already */
+-		if (val & (N3000_NIOS_INIT_DONE || N3000_NIOS_INIT_START))
++		if (val & (N3000_NIOS_INIT_DONE | N3000_NIOS_INIT_START))
+ 			goto nios_init_done;
+ 
+ 		/* configure FEC mode per module param */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0079-fpga-sec-mgr-Remove-obsolete-sec-mgr-ops-pointers.patch new/debian/patches/fpga-ofs/0079-fpga-sec-mgr-Remove-obsolete-sec-mgr-ops-pointers.patch
--- org/debian/patches/fpga-ofs/0079-fpga-sec-mgr-Remove-obsolete-sec-mgr-ops-pointers.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0079-fpga-sec-mgr-Remove-obsolete-sec-mgr-ops-pointers.patch	2021-07-20 06:17:11.456844719 +0200
@@ -0,0 +1,82 @@
+From ddf4e2fb6496556d475e55f40d8b6246dac5ed09 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 16:24:40 -0700
+Subject: [PATCH 079/149] fpga: sec-mgr: Remove obsolete sec-mgr ops pointers
+
+Support for printing the security collateral (e.g. root entry hashes)
+has been removed from the class driver and into the parent device
+driver, however, the function pointers remain in the ops structure.
+This change removes the obsolete ops pointers.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ include/linux/fpga/fpga-sec-mgr.h | 41 +------------------------------
+ 1 file changed, 1 insertion(+), 40 deletions(-)
+
+diff --git a/include/linux/fpga/fpga-sec-mgr.h b/include/linux/fpga/fpga-sec-mgr.h
+index 4a979b17ab27..d09ebfe9a170 100644
+--- a/include/linux/fpga/fpga-sec-mgr.h
++++ b/include/linux/fpga/fpga-sec-mgr.h
+@@ -39,26 +39,6 @@ struct image_load {
+ 
+ /**
+  * struct fpga_sec_mgr_ops - device specific operations
+- * @user_flash_count:	    Optional: Return sysfs string output for FPGA
+- *			    image flash count
+- * @sr_root_entry_hash:	    Optional: Return sysfs string output for static
+- *			    region root entry hash
+- * @pr_root_entry_hash:	    Optional: Return sysfs string output for partial
+- *			    reconfiguration root entry hash
+- * @bmc_root_entry_hash:    Optional: Return sysfs string output for BMC
+- *			    root entry hash
+- * @sr_canceled_csks:	    Optional: Return sysfs string output for static
+- *			    region canceled keys
+- * @pr_canceled_csks:	    Optional: Return sysfs string output for partial
+- *			    reconfiguration canceled keys
+- * @bmc_canceled_csks:	    Optional: Return sysfs string output for bmc
+- *			    canceled keys
+- * @bmc_canceled_csk_nbits: Optional: Return BMC canceled csk vector bit count
+- * @sr_canceled_csk_nbits:  Optional: Return SR canceled csk vector bit count
+- * @pr_canceled_csk_nbits:  Optional: Return PR canceled csk vector bit count
+- * @bmc_reh_size:	    Optional: Return byte size for BMC root entry hash
+- * @sr_reh_size:	    Optional: Return byte size for SR root entry hash
+- * @pr_reh_size:	    Optional: Return byte size for PR root entry hash
+  * @prepare:		    Required: Prepare secure update
+  * @write_blk:		    Required: Write a block of data
+  * @poll_complete:	    Required: Check for the completion of the
+@@ -79,31 +59,12 @@ struct image_load {
+  *			    images.
+  */
+ struct fpga_sec_mgr_ops {
+-	int (*user_flash_count)(struct fpga_sec_mgr *smgr);
+-	int (*bmc_root_entry_hash)(struct fpga_sec_mgr *smgr, u8 *hash,
+-				   unsigned int size);
+-	int (*sr_root_entry_hash)(struct fpga_sec_mgr *smgr, u8 *hash,
+-				  unsigned int size);
+-	int (*pr_root_entry_hash)(struct fpga_sec_mgr *smgr, u8 *hash,
+-				  unsigned int size);
+-	int (*bmc_canceled_csks)(struct fpga_sec_mgr *smgr,
+-				 unsigned long *csk_map, unsigned int nbits);
+-	int (*sr_canceled_csks)(struct fpga_sec_mgr *smgr,
+-				unsigned long *csk_map, unsigned int nbits);
+-	int (*pr_canceled_csks)(struct fpga_sec_mgr *smgr,
+-				unsigned long *csk_map, unsigned int nbits);
+-	int (*bmc_reh_size)(struct fpga_sec_mgr *smgr);
+-	int (*sr_reh_size)(struct fpga_sec_mgr *smgr);
+-	int (*pr_reh_size)(struct fpga_sec_mgr *smgr);
+-	int (*bmc_canceled_csk_nbits)(struct fpga_sec_mgr *smgr);
+-	int (*sr_canceled_csk_nbits)(struct fpga_sec_mgr *smgr);
+-	int (*pr_canceled_csk_nbits)(struct fpga_sec_mgr *smgr);
+ 	enum fpga_sec_err (*prepare)(struct fpga_sec_mgr *smgr);
+ 	enum fpga_sec_err (*write_blk)(struct fpga_sec_mgr *smgr,
+ 				       u32 offset, u32 size);
+ 	enum fpga_sec_err (*poll_complete)(struct fpga_sec_mgr *smgr);
+-	void (*cleanup)(struct fpga_sec_mgr *smgr);
+ 	enum fpga_sec_err (*cancel)(struct fpga_sec_mgr *smgr);
++	void (*cleanup)(struct fpga_sec_mgr *smgr);
+ 	u64 (*get_hw_errinfo)(struct fpga_sec_mgr *smgr);
+ 	struct image_load *image_load;	/* terminated with { } member */
+ };
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0080-fpga-sec-mgr-Use-kmemdup_nul-for-sysfs-input.patch new/debian/patches/fpga-ofs/0080-fpga-sec-mgr-Use-kmemdup_nul-for-sysfs-input.patch
--- org/debian/patches/fpga-ofs/0080-fpga-sec-mgr-Use-kmemdup_nul-for-sysfs-input.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0080-fpga-sec-mgr-Use-kmemdup_nul-for-sysfs-input.patch	2021-07-20 06:17:11.456844719 +0200
@@ -0,0 +1,28 @@
+From 89bcf06a17185fbfe6d8c1c1e60ffb0ec4f1aa16 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 17:19:59 -0700
+Subject: [PATCH 080/149] fpga: sec-mgr: Use kmemdup_nul for sysfs input
+
+Switch from kstrndup() to kmemdup_nul() for sysfs input.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/fpga-sec-mgr.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index f2584a63313f..edcbf5185510 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -275,7 +275,7 @@ static ssize_t filename_store(struct device *dev, struct device_attribute *attr,
+ 		goto unlock_exit;
+ 	}
+ 
+-	smgr->filename = kstrndup(buf, count, GFP_KERNEL);
++	smgr->filename = kmemdup_nul(buf, count, GFP_KERNEL);
+ 	if (!smgr->filename) {
+ 		ret = -ENOMEM;
+ 		goto unlock_exit;
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0081-fpga-m10bmc-sec-Reduce-code-with-do-while-loop.patch new/debian/patches/fpga-ofs/0081-fpga-m10bmc-sec-Reduce-code-with-do-while-loop.patch
--- org/debian/patches/fpga-ofs/0081-fpga-m10bmc-sec-Reduce-code-with-do-while-loop.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0081-fpga-m10bmc-sec-Reduce-code-with-do-while-loop.patch	2021-07-20 06:17:11.460844708 +0200
@@ -0,0 +1,40 @@
+From 089fa406c130bd515f26ae32e68791d68d63eb77 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 17:21:52 -0700
+Subject: [PATCH 081/149] fpga: m10bmc-sec: Reduce code with do-while loop
+
+Change while loop to do-while loop in order to eliminate a couple of
+lines of code.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 6 ++----
+ 1 file changed, 2 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 9999bdef6e0e..40ee04d88810 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -444,17 +444,15 @@ static enum fpga_sec_err m10bmc_sec_poll_complete(struct fpga_sec_mgr *smgr)
+ 	if (result != FPGA_SEC_ERR_NONE)
+ 		goto fw_state_exit;
+ 
+-	ret = rsu_check_complete(sec, &doorbell);
+ 	poll_timeout = jiffies + msecs_to_jiffies(RSU_COMPLETE_TIMEOUT_MS);
+-
+-	while (ret == -EAGAIN && !time_after(jiffies, poll_timeout)) {
++	do {
+ 		msleep(RSU_COMPLETE_INTERVAL_MS);
+ 		ret = rsu_check_complete(sec, &doorbell);
+ 		if (smgr->driver_unload) {
+ 			result = FPGA_SEC_ERR_CANCELED;
+ 			goto fw_state_exit;
+ 		}
+-	}
++	} while (ret == -EAGAIN && !time_after(jiffies, poll_timeout));
+ 
+ 	if (ret == -EAGAIN) {
+ 		log_error_regs(sec, doorbell);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0082-fpga-m10bmc-sec-Initialize-variables-with-poison.patch new/debian/patches/fpga-ofs/0082-fpga-m10bmc-sec-Initialize-variables-with-poison.patch
--- org/debian/patches/fpga-ofs/0082-fpga-m10bmc-sec-Initialize-variables-with-poison.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0082-fpga-m10bmc-sec-Initialize-variables-with-poison.patch	2021-07-20 06:17:11.460844708 +0200
@@ -0,0 +1,30 @@
+From 3d0328918fb2351fefb7ef4c3de6d52fa3379ad3 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 17:23:05 -0700
+Subject: [PATCH 082/149] fpga: m10bmc-sec: Initialize variables with poison
+
+Initialize doorbell and auth_result variables with POISON values so
+that uninitialized data is not misinterpreted as valid data.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 40ee04d88810..893f2ea5aa9f 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -494,7 +494,8 @@ static enum fpga_sec_err m10bmc_sec_cancel(struct fpga_sec_mgr *smgr)
+ static u64 m10bmc_sec_hw_errinfo(struct fpga_sec_mgr *smgr)
+ {
+ 	struct m10bmc_sec *sec = smgr->priv;
+-	u32 doorbell, auth_result;
++	u32 auth_result = HW_ERRINFO_POISON;
++	u32 doorbell = HW_ERRINFO_POISON;
+ 
+ 	switch (smgr->err_code) {
+ 	case FPGA_SEC_ERR_HW_ERROR:
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0083-fpga-dfl-refactor-cci_enumerate_feature_devs.patch new/debian/patches/fpga-ofs/0083-fpga-dfl-refactor-cci_enumerate_feature_devs.patch
--- org/debian/patches/fpga-ofs/0083-fpga-dfl-refactor-cci_enumerate_feature_devs.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0083-fpga-dfl-refactor-cci_enumerate_feature_devs.patch	2021-07-20 06:17:11.460844708 +0200
@@ -0,0 +1,135 @@
+From 49bbd50c5bc28823dc80f77c8e9ead9a6354dc5b Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Wed, 6 Jan 2021 20:37:07 -0800
+Subject: [PATCH 083/149] fpga: dfl: refactor cci_enumerate_feature_devs()
+
+In preparation of looking for dfls based on a vendor specific pci
+capability, move the code for the default method of finding the first
+dfl at offset 0 of Bar 0 to its own function.
+
+Acked-by: Wu Hao <hao.wu@intel.com>
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Signed-off-by: Moritz Fischer <mdf@kernel.org>
+Link: https://lore.kernel.org/r/20210107043714.991646-2-mdf@kernel.org
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/fpga/dfl-pci.c | 84 +++++++++++++++++++++++-------------------
+ 1 file changed, 47 insertions(+), 37 deletions(-)
+
+diff --git a/drivers/fpga/dfl-pci.c b/drivers/fpga/dfl-pci.c
+index d844bebb4cd4..eb0fb9b39da5 100644
+--- a/drivers/fpga/dfl-pci.c
++++ b/drivers/fpga/dfl-pci.c
+@@ -125,49 +125,20 @@ static int *cci_pci_create_irq_table(struct pci_dev *pcidev, unsigned int nvec)
+ 	return table;
+ }
+ 
+-/* enumerate feature devices under pci device */
+-static int cci_enumerate_feature_devs(struct pci_dev *pcidev)
++/* default method of finding dfls starting at offset 0 of bar 0 */
++static int find_dfls_by_default(struct pci_dev *pcidev,
++				struct dfl_fpga_enum_info *info)
+ {
+-	struct cci_drvdata *drvdata = pci_get_drvdata(pcidev);
+-	int port_num, bar, i, nvec, ret = 0;
+-	struct dfl_fpga_enum_info *info;
+-	struct dfl_fpga_cdev *cdev;
++	int port_num, bar, i, ret = 0;
+ 	resource_size_t start, len;
+ 	void __iomem *base;
+-	int *irq_table;
+ 	u32 offset;
+ 	u64 v;
+ 
+-	/* allocate enumeration info via pci_dev */
+-	info = dfl_fpga_enum_info_alloc(&pcidev->dev);
+-	if (!info)
+-		return -ENOMEM;
+-
+-	/* add irq info for enumeration if the device support irq */
+-	nvec = cci_pci_alloc_irq(pcidev);
+-	if (nvec < 0) {
+-		dev_err(&pcidev->dev, "Fail to alloc irq %d.\n", nvec);
+-		ret = nvec;
+-		goto enum_info_free_exit;
+-	} else if (nvec) {
+-		irq_table = cci_pci_create_irq_table(pcidev, nvec);
+-		if (!irq_table) {
+-			ret = -ENOMEM;
+-			goto irq_free_exit;
+-		}
+-
+-		ret = dfl_fpga_enum_info_add_irq(info, nvec, irq_table);
+-		kfree(irq_table);
+-		if (ret)
+-			goto irq_free_exit;
+-	}
+-
+-	/* start to find Device Feature List in Bar 0 */
++	/* start to find Device Feature List from Bar 0 */
+ 	base = cci_pci_ioremap_bar0(pcidev);
+-	if (!base) {
+-		ret = -ENOMEM;
+-		goto irq_free_exit;
+-	}
++	if (!base)
++		return -ENOMEM;
+ 
+ 	/*
+ 	 * PF device has FME and Ports/AFUs, and VF device only has one
+@@ -214,12 +185,51 @@ static int cci_enumerate_feature_devs(struct pci_dev *pcidev)
+ 		dfl_fpga_enum_info_add_dfl(info, start, len);
+ 	} else {
+ 		ret = -ENODEV;
+-		goto irq_free_exit;
+ 	}
+ 
+ 	/* release I/O mappings for next step enumeration */
+ 	pcim_iounmap_regions(pcidev, BIT(0));
+ 
++	return ret;
++}
++
++/* enumerate feature devices under pci device */
++static int cci_enumerate_feature_devs(struct pci_dev *pcidev)
++{
++	struct cci_drvdata *drvdata = pci_get_drvdata(pcidev);
++	struct dfl_fpga_enum_info *info;
++	struct dfl_fpga_cdev *cdev;
++	int nvec, ret = 0;
++	int *irq_table;
++
++	/* allocate enumeration info via pci_dev */
++	info = dfl_fpga_enum_info_alloc(&pcidev->dev);
++	if (!info)
++		return -ENOMEM;
++
++	/* add irq info for enumeration if the device support irq */
++	nvec = cci_pci_alloc_irq(pcidev);
++	if (nvec < 0) {
++		dev_err(&pcidev->dev, "Fail to alloc irq %d.\n", nvec);
++		ret = nvec;
++		goto enum_info_free_exit;
++	} else if (nvec) {
++		irq_table = cci_pci_create_irq_table(pcidev, nvec);
++		if (!irq_table) {
++			ret = -ENOMEM;
++			goto irq_free_exit;
++		}
++
++		ret = dfl_fpga_enum_info_add_irq(info, nvec, irq_table);
++		kfree(irq_table);
++		if (ret)
++			goto irq_free_exit;
++	}
++
++	ret = find_dfls_by_default(pcidev, info);
++	if (ret)
++		goto irq_free_exit;
++
+ 	/* start enumeration with prepared enumeration information */
+ 	cdev = dfl_fpga_feature_devs_enumerate(info);
+ 	if (IS_ERR(cdev)) {
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0084-fpga-dfl-pci-locate-DFLs-by-PCIe-vendor-specific-cap.patch new/debian/patches/fpga-ofs/0084-fpga-dfl-pci-locate-DFLs-by-PCIe-vendor-specific-cap.patch
--- org/debian/patches/fpga-ofs/0084-fpga-dfl-pci-locate-DFLs-by-PCIe-vendor-specific-cap.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0084-fpga-dfl-pci-locate-DFLs-by-PCIe-vendor-specific-cap.patch	2021-07-20 06:17:11.460844708 +0200
@@ -0,0 +1,171 @@
+From 486ba53fdf9dd5f5152d5ef54a04d88b304f0a55 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Wed, 6 Jan 2021 20:37:08 -0800
+Subject: [PATCH 084/149] fpga: dfl-pci: locate DFLs by PCIe vendor specific
+ capability
+
+A PCIe vendor specific extended capability is introduced by Intel to
+specify the start of a number of DFLs.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Signed-off-by: Moritz Fischer <mdf@kernel.org>
+Link: https://lore.kernel.org/r/20210107043714.991646-3-mdf@kernel.org
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ Documentation/fpga/dfl.rst | 27 ++++++++++++
+ drivers/fpga/dfl-pci.c     | 87 +++++++++++++++++++++++++++++++++++++-
+ 2 files changed, 113 insertions(+), 1 deletion(-)
+
+diff --git a/Documentation/fpga/dfl.rst b/Documentation/fpga/dfl.rst
+index 5cee979417b9..db92696a5f52 100644
+--- a/Documentation/fpga/dfl.rst
++++ b/Documentation/fpga/dfl.rst
+@@ -501,6 +501,33 @@ Developer only needs to provide a sub feature driver with matched feature id.
+ FME Partial Reconfiguration Sub Feature driver (see drivers/fpga/dfl-fme-pr.c)
+ could be a reference.
+ 
++Location of DFLs on a PCI Device
++===========================
++The original method for finding a DFL on a PCI device assumed the start of the
++first DFL to offset 0 of bar 0.  If the first node of the DFL is an FME,
++then further DFLs in the port(s) are specified in FME header registers.
++Alternatively, a PCIe vendor specific capability structure can be used to
++specify the location of all the DFLs on the device, providing flexibility
++for the type of starting node in the DFL.  Intel has reserved the
++VSEC ID of 0x43 for this purpose.  The vendor specific
++data begins with a 4 byte vendor specific register for the number of DFLs followed 4 byte
++Offset/BIR vendor specific registers for each DFL. Bits 2:0 of Offset/BIR register
++indicates the BAR, and bits 31:3 form the 8 byte aligned offset where bits 2:0 are
++zero.
++
++        +----------------------------+
++        |31     Number of DFLS      0|
++        +----------------------------+
++        |31     Offset     3|2 BIR  0|
++        +----------------------------+
++                      . . .
++        +----------------------------+
++        |31     Offset     3|2 BIR  0|
++        +----------------------------+
++
++Being able to specify more than one DFL per BAR has been considered, but it
++was determined the use case did not provide value.  Specifying a single DFL
++per BAR simplifies the implementation and allows for extra error checking.
+ 
+ Userspace driver support for DFL devices
+ ========================================
+diff --git a/drivers/fpga/dfl-pci.c b/drivers/fpga/dfl-pci.c
+index eb0fb9b39da5..fb279679479a 100644
+--- a/drivers/fpga/dfl-pci.c
++++ b/drivers/fpga/dfl-pci.c
+@@ -27,6 +27,14 @@
+ #define DRV_VERSION	"0.8"
+ #define DRV_NAME	"dfl-pci"
+ 
++#define PCI_VSEC_ID_INTEL_DFLS 0x43
++
++#define PCI_VNDR_DFLS_CNT 0x8
++#define PCI_VNDR_DFLS_RES 0xc
++
++#define PCI_VNDR_DFLS_RES_BAR_MASK GENMASK(2, 0)
++#define PCI_VNDR_DFLS_RES_OFF_MASK GENMASK(31, 3)
++
+ struct cci_drvdata {
+ 	struct dfl_fpga_cdev *cdev;	/* container device */
+ };
+@@ -125,6 +133,80 @@ static int *cci_pci_create_irq_table(struct pci_dev *pcidev, unsigned int nvec)
+ 	return table;
+ }
+ 
++static int find_dfls_by_vsec(struct pci_dev *pcidev, struct dfl_fpga_enum_info *info)
++{
++	u32 bir, offset, vndr_hdr, dfl_cnt, dfl_res;
++	int dfl_res_off, i, bars, voff = 0;
++	resource_size_t start, len;
++
++	while ((voff = pci_find_next_ext_capability(pcidev, voff, PCI_EXT_CAP_ID_VNDR))) {
++		vndr_hdr = 0;
++		pci_read_config_dword(pcidev, voff + PCI_VNDR_HEADER, &vndr_hdr);
++
++		if (PCI_VNDR_HEADER_ID(vndr_hdr) == PCI_VSEC_ID_INTEL_DFLS &&
++		    pcidev->vendor == PCI_VENDOR_ID_INTEL)
++			break;
++	}
++
++	if (!voff) {
++		dev_dbg(&pcidev->dev, "%s no DFL VSEC found\n", __func__);
++		return -ENODEV;
++	}
++
++	dfl_cnt = 0;
++	pci_read_config_dword(pcidev, voff + PCI_VNDR_DFLS_CNT, &dfl_cnt);
++	if (dfl_cnt > PCI_STD_NUM_BARS) {
++		dev_err(&pcidev->dev, "%s too many DFLs %d > %d\n",
++			__func__, dfl_cnt, PCI_STD_NUM_BARS);
++		return -EINVAL;
++	}
++
++	dfl_res_off = voff + PCI_VNDR_DFLS_RES;
++	if (dfl_res_off + (dfl_cnt * sizeof(u32)) > PCI_CFG_SPACE_EXP_SIZE) {
++		dev_err(&pcidev->dev, "%s DFL VSEC too big for PCIe config space\n",
++			__func__);
++		return -EINVAL;
++	}
++
++	for (i = 0, bars = 0; i < dfl_cnt; i++, dfl_res_off += sizeof(u32)) {
++		dfl_res = GENMASK(31, 0);
++		pci_read_config_dword(pcidev, dfl_res_off, &dfl_res);
++
++		bir = dfl_res & PCI_VNDR_DFLS_RES_BAR_MASK;
++		if (bir >= PCI_STD_NUM_BARS) {
++			dev_err(&pcidev->dev, "%s bad bir number %d\n",
++				__func__, bir);
++			return -EINVAL;
++		}
++
++		if (bars & BIT(bir)) {
++			dev_err(&pcidev->dev, "%s DFL for BAR %d already specified\n",
++				__func__, bir);
++			return -EINVAL;
++		}
++
++		bars |= BIT(bir);
++
++		len = pci_resource_len(pcidev, bir);
++		offset = dfl_res & PCI_VNDR_DFLS_RES_OFF_MASK;
++		if (offset >= len) {
++			dev_err(&pcidev->dev, "%s bad offset %u >= %pa\n",
++				__func__, offset, &len);
++			return -EINVAL;
++		}
++
++		dev_dbg(&pcidev->dev, "%s BAR %d offset 0x%x\n", __func__, bir, offset);
++
++		len -= offset;
++
++		start = pci_resource_start(pcidev, bir) + offset;
++
++		dfl_fpga_enum_info_add_dfl(info, start, len);
++	}
++
++	return 0;
++}
++
+ /* default method of finding dfls starting at offset 0 of bar 0 */
+ static int find_dfls_by_default(struct pci_dev *pcidev,
+ 				struct dfl_fpga_enum_info *info)
+@@ -226,7 +308,10 @@ static int cci_enumerate_feature_devs(struct pci_dev *pcidev)
+ 			goto irq_free_exit;
+ 	}
+ 
+-	ret = find_dfls_by_default(pcidev, info);
++	ret = find_dfls_by_vsec(pcidev, info);
++	if (ret == -ENODEV)
++		ret = find_dfls_by_default(pcidev, info);
++
+ 	if (ret)
+ 		goto irq_free_exit;
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0085-Revert-ethernet-dfl-eth-group-add-support-for-the-10.patch new/debian/patches/fpga-ofs/0085-Revert-ethernet-dfl-eth-group-add-support-for-the-10.patch
--- org/debian/patches/fpga-ofs/0085-Revert-ethernet-dfl-eth-group-add-support-for-the-10.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0085-Revert-ethernet-dfl-eth-group-add-support-for-the-10.patch	2021-07-20 06:17:11.460844708 +0200
@@ -0,0 +1,610 @@
+From cb8f86c5a9f25bb7ba0f0ed949287f68ce1c57a2 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 18 Mar 2021 14:24:52 -0700
+Subject: [PATCH 085/149] Revert "ethernet: dfl-eth-group: add support for the
+ 10G configurations"
+
+This reverts commit bfa881a4c23635794aa069ed6d7f9feac50743a8.
+Remove eth-group driver - not accepted by the upstream community.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/net/ethernet/intel/Makefile           |   2 +-
+ .../net/ethernet/intel/dfl-eth-group-10g.c    | 544 ------------------
+ .../net/ethernet/intel/dfl-eth-group-main.c   |   3 -
+ drivers/net/ethernet/intel/dfl-eth-group.h    |   1 -
+ 4 files changed, 1 insertion(+), 549 deletions(-)
+ delete mode 100644 drivers/net/ethernet/intel/dfl-eth-group-10g.c
+
+diff --git a/drivers/net/ethernet/intel/Makefile b/drivers/net/ethernet/intel/Makefile
+index 12c1d7a66d18..1d09708e31a6 100644
+--- a/drivers/net/ethernet/intel/Makefile
++++ b/drivers/net/ethernet/intel/Makefile
+@@ -17,7 +17,7 @@ obj-$(CONFIG_IAVF) += iavf/
+ obj-$(CONFIG_FM10K) += fm10k/
+ obj-$(CONFIG_ICE) += ice/
+ 
+-dfl-eth-group-objs := dfl-eth-group-main.o dfl-eth-group-10g.o dfl-eth-group-25g.o
++dfl-eth-group-objs := dfl-eth-group-main.o dfl-eth-group-25g.o
+ obj-$(CONFIG_FPGA_DFL_ETH_GROUP) += dfl-eth-group.o
+ obj-$(CONFIG_INTEL_M10_BMC_RETIMER) += intel-m10-bmc-retimer.o
+ obj-$(CONFIG_INTEL_M10_BMC_PKVL) += intel-m10-bmc-pkvl.o
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group-10g.c b/drivers/net/ethernet/intel/dfl-eth-group-10g.c
+deleted file mode 100644
+index 36f9dfcbbe4f..000000000000
+--- a/drivers/net/ethernet/intel/dfl-eth-group-10g.c
++++ /dev/null
+@@ -1,544 +0,0 @@
+-// SPDX-License-Identifier: GPL-2.0
+-/* Driver for 10G Ether Group private feature on Intel PAC (Programmable
+- * Acceleration Card) N3000
+- *
+- * Copyright (C) 2019-2020 Intel Corporation, Inc.
+- *
+- * Authors:
+- *   Wu Hao <hao.wu@intel.com>
+- *   Xu Yilun <yilun.xu@intel.com>
+- */
+-#include <linux/netdevice.h>
+-
+-#include "dfl-eth-group.h"
+-
+-/* 10G PHY Register */
+-#define PHY_LOOPBACK		0x2e1
+-#define PHY_LOOPBACK_SERIAL	BIT(0)
+-
+-/* 10G MAC Register */
+-#define TX_FRAME_MAXLENGTH	0x2c
+-#define TX_PAUSE_FRAME_QUANTA	0x42
+-#define TX_PAUSE_FRAME_HOLDOFF	0x43
+-#define TX_PAUSE_FRAME_EN	0x44
+-#define TX_PAUSE_FRAME_EN_CFG	BIT(0)
+-#define RX_FRAME_MAXLENGTH	0xae
+-
+-/* Additional Feature Register */
+-#define ADD_PHY_CTRL		0x0
+-#define PHY_RESET		BIT(0)
+-
+-static int edev10g_reset(struct eth_dev *edev, bool en)
+-{
+-	struct eth_com *phy = edev->phy;
+-	struct device *dev = edev->dev;
+-	u32 val;
+-	int ret;
+-
+-	/* 10G eth group supports PHY reset. It uses external reset. */
+-	ret = eth_com_add_feat_read_reg(phy, ADD_PHY_CTRL, &val);
+-	if (ret) {
+-		dev_err(dev, "fail to read ADD_PHY_CTRL reg: %d\n", ret);
+-		return ret;
+-	}
+-
+-	/* return if PHY is already in expected state */
+-	if ((val & PHY_RESET && en) || (!(val & PHY_RESET) && !en))
+-		return 0;
+-
+-	if (en)
+-		val |= PHY_RESET;
+-	else
+-		val &= ~PHY_RESET;
+-
+-	ret = eth_com_add_feat_write_reg(phy, ADD_PHY_CTRL, val);
+-	if (ret)
+-		dev_err(dev, "fail to write ADD_PHY_CTRL reg: %d\n", ret);
+-
+-	return ret;
+-}
+-
+-static ssize_t tx_pause_frame_quanta_show(struct device *d,
+-					  struct device_attribute *attr,
+-					  char *buf)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(to_net_dev(d));
+-	u32 data;
+-	int ret;
+-
+-	ret = eth_com_read_reg(edev->mac, TX_PAUSE_FRAME_QUANTA, &data);
+-
+-	return ret ? : sprintf(buf, "0x%x\n", data);
+-}
+-
+-static ssize_t tx_pause_frame_quanta_store(struct device *d,
+-					   struct device_attribute *attr,
+-					   const char *buf, size_t len)
+-{
+-	struct net_device *netdev = to_net_dev(d);
+-	struct eth_dev *edev;
+-	u32 data;
+-	int ret;
+-
+-	if (kstrtou32(buf, 0, &data))
+-		return -EINVAL;
+-
+-	edev = net_device_to_eth_dev(netdev);
+-
+-	rtnl_lock();
+-
+-	if (netif_running(netdev)) {
+-		netdev_err(netdev, "must be stopped to change pause param\n");
+-		ret = -EBUSY;
+-		goto out;
+-	}
+-
+-	ret = eth_com_write_reg(edev->mac, TX_PAUSE_FRAME_QUANTA, data);
+-
+-out:
+-	rtnl_unlock();
+-
+-	return ret ? : len;
+-}
+-static DEVICE_ATTR_RW(tx_pause_frame_quanta);
+-
+-static ssize_t tx_pause_frame_holdoff_show(struct device *d,
+-					   struct device_attribute *attr,
+-					   char *buf)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(to_net_dev(d));
+-	u32 data;
+-	int ret;
+-
+-	ret = eth_com_read_reg(edev->mac, TX_PAUSE_FRAME_HOLDOFF, &data);
+-
+-	return ret ? : sprintf(buf, "0x%x\n", data);
+-}
+-
+-static ssize_t tx_pause_frame_holdoff_store(struct device *d,
+-					    struct device_attribute *attr,
+-					    const char *buf, size_t len)
+-{
+-	struct net_device *netdev = to_net_dev(d);
+-	struct eth_dev *edev;
+-	u32 data;
+-	int ret;
+-
+-	if (kstrtou32(buf, 0, &data))
+-		return -EINVAL;
+-
+-	edev = net_device_to_eth_dev(netdev);
+-
+-	rtnl_lock();
+-
+-	if (netif_running(netdev)) {
+-		netdev_err(netdev, "must be stopped to change pause param\n");
+-		ret = -EBUSY;
+-		goto out;
+-	}
+-
+-	ret = eth_com_write_reg(edev->mac, TX_PAUSE_FRAME_HOLDOFF, data);
+-
+-out:
+-	rtnl_unlock();
+-
+-	return ret ? : len;
+-}
+-static DEVICE_ATTR_RW(tx_pause_frame_holdoff);
+-
+-static struct attribute *edev10g_dev_attrs[] = {
+-	&dev_attr_tx_pause_frame_quanta.attr,
+-	&dev_attr_tx_pause_frame_holdoff.attr,
+-	NULL
+-};
+-
+-/* device attributes */
+-static const struct attribute_group edev10g_attr_group = {
+-	.attrs = edev10g_dev_attrs,
+-};
+-
+-/* ethtool ops */
+-static struct stat_info stats_10g[] = {
+-	/* TX Statistics */
+-	{STAT_INFO(0x142, "tx_frame_ok")},
+-	{STAT_INFO(0x144, "tx_frame_err")},
+-	{STAT_INFO(0x146, "tx_frame_crc_err")},
+-	{STAT_INFO(0x148, "tx_octets_ok")},
+-	{STAT_INFO(0x14a, "tx_pause_mac_ctrl_frames")},
+-	{STAT_INFO(0x14c, "tx_if_err")},
+-	{STAT_INFO(0x14e, "tx_unicast_frame_ok")},
+-	{STAT_INFO(0x150, "tx_unicast_frame_err")},
+-	{STAT_INFO(0x152, "tx_multicast_frame_ok")},
+-	{STAT_INFO(0x154, "tx_multicast_frame_err")},
+-	{STAT_INFO(0x156, "tx_broadcast_frame_ok")},
+-	{STAT_INFO(0x158, "tx_broadcast_frame_err")},
+-	{STAT_INFO(0x15a, "tx_ether_octets")},
+-	{STAT_INFO(0x15c, "tx_ether_pkts")},
+-	{STAT_INFO(0x15e, "tx_ether_undersize_pkts")},
+-	{STAT_INFO(0x160, "tx_ether_oversize_pkts")},
+-	{STAT_INFO(0x162, "tx_ether_pkts_64_octets")},
+-	{STAT_INFO(0x164, "tx_ether_pkts_65_127_octets")},
+-	{STAT_INFO(0x166, "tx_ether_pkts_128_255_octets")},
+-	{STAT_INFO(0x168, "tx_ether_pkts_256_511_octets")},
+-	{STAT_INFO(0x16a, "tx_ether_pkts_512_1023_octets")},
+-	{STAT_INFO(0x16c, "tx_ether_pkts_1024_1518_octets")},
+-	{STAT_INFO(0x16e, "tx_ether_pkts_1519_x_octets")},
+-	{STAT_INFO(0x176, "tx_unicast_mac_ctrl_frames")},
+-	{STAT_INFO(0x178, "tx_multicast_mac_ctrl_frames")},
+-	{STAT_INFO(0x17a, "tx_broadcast_mac_ctrl_frames")},
+-	{STAT_INFO(0x17c, "tx_pfc_mac_ctrl_frames")},
+-
+-	/* RX Statistics */
+-	{STAT_INFO(0x1c2, "rx_frame_ok")},
+-	{STAT_INFO(0x1c4, "rx_frame_err")},
+-	{STAT_INFO(0x1c6, "rx_frame_crc_err")},
+-	{STAT_INFO(0x1c8, "rx_octets_ok")},
+-	{STAT_INFO(0x1ca, "rx_pause_mac_ctrl_frames")},
+-	{STAT_INFO(0x1cc, "rx_if_err")},
+-	{STAT_INFO(0x1ce, "rx_unicast_frame_ok")},
+-	{STAT_INFO(0x1d0, "rx_unicast_frame_err")},
+-	{STAT_INFO(0x1d2, "rx_multicast_frame_ok")},
+-	{STAT_INFO(0x1d4, "rx_multicast_frame_err")},
+-	{STAT_INFO(0x1d6, "rx_broadcast_frame_ok")},
+-	{STAT_INFO(0x1d8, "rx_broadcast_frame_err")},
+-	{STAT_INFO(0x1da, "rx_ether_octets")},
+-	{STAT_INFO(0x1dc, "rx_ether_pkts")},
+-	{STAT_INFO(0x1de, "rx_ether_undersize_pkts")},
+-	{STAT_INFO(0x1e0, "rx_ether_oversize_pkts")},
+-	{STAT_INFO(0x1e2, "rx_ether_pkts_64_octets")},
+-	{STAT_INFO(0x1e4, "rx_ether_pkts_65_127_octets")},
+-	{STAT_INFO(0x1e6, "rx_ether_pkts_128_255_octets")},
+-	{STAT_INFO(0x1e8, "rx_ether_pkts_256_511_octets")},
+-	{STAT_INFO(0x1ea, "rx_ether_pkts_512_1023_octets")},
+-	{STAT_INFO(0x1ec, "rx_ether_pkts_1024_1518_octets")},
+-	{STAT_INFO(0x1ee, "rx_ether_pkts_1519_x_octets")},
+-	{STAT_INFO(0x1f0, "rx_ether_fragments")},
+-	{STAT_INFO(0x1f2, "rx_ether_jabbers")},
+-	{STAT_INFO(0x1f4, "rx_ether_crc_err")},
+-	{STAT_INFO(0x1f6, "rx_unicast_mac_ctrl_frames")},
+-	{STAT_INFO(0x1f8, "rx_multicast_mac_ctrl_frames")},
+-	{STAT_INFO(0x1fa, "rx_broadcast_mac_ctrl_frames")},
+-	{STAT_INFO(0x1fc, "rx_pfc_mac_ctrl_frames")},
+-};
+-
+-static void edev10g_get_strings(struct net_device *netdev, u32 stringset, u8 *s)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	unsigned int i;
+-
+-	if (stringset != ETH_SS_STATS || edev->lw_mac)
+-		return;
+-
+-	for (i = 0; i < ARRAY_SIZE(stats_10g); i++, s += ETH_GSTRING_LEN)
+-		memcpy(s, stats_10g[i].string, ETH_GSTRING_LEN);
+-}
+-
+-static int edev10g_get_sset_count(struct net_device *netdev, int stringset)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-
+-	if (stringset != ETH_SS_STATS || edev->lw_mac)
+-		return -EOPNOTSUPP;
+-
+-	return (int)ARRAY_SIZE(stats_10g);
+-}
+-
+-static void edev10g_get_stats(struct net_device *netdev,
+-			      struct ethtool_stats *stats, u64 *data)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	unsigned int i;
+-
+-	if (edev->lw_mac || !netif_running(netdev))
+-		return;
+-
+-	for (i = 0; i < ARRAY_SIZE(stats_10g); i++)
+-		data[i] = read_mac_stats(edev->mac, stats_10g[i].addr);
+-}
+-
+-static int edev10g_get_link_ksettings(struct net_device *netdev,
+-				      struct ethtool_link_ksettings *cmd)
+-{
+-	if (!netdev->phydev)
+-		return -ENODEV;
+-
+-	phy_ethtool_ksettings_get(netdev->phydev, cmd);
+-
+-	return 0;
+-}
+-
+-static void edev10g_get_pauseparam(struct net_device *netdev,
+-				   struct ethtool_pauseparam *pause)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	u32 data;
+-	int ret;
+-
+-	pause->autoneg = 0;
+-	pause->rx_pause = 0;
+-
+-	ret = eth_com_read_reg(edev->mac, TX_PAUSE_FRAME_EN, &data);
+-	if (ret) {
+-		pause->tx_pause = 0;
+-		return;
+-	}
+-
+-	pause->tx_pause = (data & TX_PAUSE_FRAME_EN_CFG) ? 0x1 : 0;
+-}
+-
+-static int edev10g_set_pauseparam(struct net_device *netdev,
+-				  struct ethtool_pauseparam *pause)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	struct eth_com *mac = edev->mac;
+-	bool enable = pause->tx_pause;
+-	u32 data;
+-	int ret;
+-
+-	if (pause->autoneg || pause->rx_pause)
+-		return -EOPNOTSUPP;
+-
+-	if (netif_running(netdev)) {
+-		netdev_err(netdev, "must be stopped to change pause param\n");
+-		return -EBUSY;
+-	}
+-
+-	ret = eth_com_read_reg(mac, TX_PAUSE_FRAME_EN, &data);
+-	if (ret)
+-		return ret;
+-
+-	if (enable)
+-		data |= TX_PAUSE_FRAME_EN_CFG;
+-	else
+-		data &= ~TX_PAUSE_FRAME_EN_CFG;
+-
+-	return eth_com_write_reg(mac, TX_PAUSE_FRAME_EN, data);
+-}
+-
+-static const struct ethtool_ops edev10g_ethtool_ops = {
+-	.get_link = ethtool_op_get_link,
+-	.get_strings = edev10g_get_strings,
+-	.get_sset_count = edev10g_get_sset_count,
+-	.get_ethtool_stats = edev10g_get_stats,
+-	.get_link_ksettings = edev10g_get_link_ksettings,
+-	.get_pauseparam = edev10g_get_pauseparam,
+-	.set_pauseparam = edev10g_set_pauseparam,
+-};
+-
+-/* netdev ops */
+-static int edev10g_netdev_open(struct net_device *netdev)
+-{
+-	struct n3000_net_priv *priv = netdev_priv(netdev);
+-	struct eth_dev *edev = priv->edev;
+-	int ret;
+-
+-	ret = edev10g_reset(edev, false);
+-	if (ret)
+-		return ret;
+-
+-	if (netdev->phydev)
+-		phy_start(netdev->phydev);
+-
+-	return 0;
+-}
+-
+-static int edev10g_netdev_stop(struct net_device *netdev)
+-{
+-	struct n3000_net_priv *priv = netdev_priv(netdev);
+-	struct eth_dev *edev = priv->edev;
+-	int ret;
+-
+-	ret = edev10g_reset(edev, true);
+-	if (ret)
+-		return ret;
+-
+-	if (netdev->phydev)
+-		phy_stop(netdev->phydev);
+-
+-	return 0;
+-}
+-
+-static int edev10g_mtu_init(struct net_device *netdev)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	struct eth_com *mac = edev->mac;
+-	u32 tx = 0, rx = 0, mtu;
+-	int ret;
+-
+-	ret = eth_com_read_reg(mac, TX_FRAME_MAXLENGTH, &tx);
+-	if (ret)
+-		return ret;
+-
+-	ret = eth_com_read_reg(mac, RX_FRAME_MAXLENGTH, &rx);
+-	if (ret)
+-		return ret;
+-
+-	mtu = min(min(tx, rx), netdev->max_mtu);
+-
+-	ret = eth_com_write_reg(mac, TX_FRAME_MAXLENGTH, rx);
+-	if (ret)
+-		return ret;
+-
+-	ret = eth_com_write_reg(mac, RX_FRAME_MAXLENGTH, tx);
+-	if (ret)
+-		return ret;
+-
+-	netdev->mtu = mtu;
+-
+-	return 0;
+-}
+-
+-static int edev10g_change_mtu(struct net_device *netdev, int new_mtu)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	struct eth_com *mac = edev->mac;
+-	int ret;
+-
+-	if (netif_running(netdev)) {
+-		netdev_err(netdev, "must be stopped to change mtu\n");
+-		return -EBUSY;
+-	}
+-
+-	ret = eth_com_write_reg(mac, TX_FRAME_MAXLENGTH, new_mtu);
+-	if (ret)
+-		return ret;
+-
+-	ret = eth_com_write_reg(mac, RX_FRAME_MAXLENGTH, new_mtu);
+-	if (ret)
+-		return ret;
+-
+-	netdev->mtu = new_mtu;
+-
+-	return 0;
+-}
+-
+-static int edev10g_set_loopback(struct net_device *netdev, bool en)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	struct eth_com *phy = edev->phy;
+-	u32 data;
+-	int ret;
+-
+-	ret = eth_com_read_reg(phy, PHY_LOOPBACK, &data);
+-	if (ret)
+-		return ret;
+-
+-	if (en)
+-		data |= PHY_LOOPBACK_SERIAL;
+-	else
+-		data &= ~PHY_LOOPBACK_SERIAL;
+-
+-	return eth_com_write_reg(phy, PHY_LOOPBACK, data);
+-}
+-
+-static int edev10g_set_features(struct net_device *netdev,
+-				netdev_features_t features)
+-{
+-	netdev_features_t changed = netdev->features ^ features;
+-
+-	if (changed & NETIF_F_LOOPBACK)
+-		return edev10g_set_loopback(netdev,
+-					    !!(features & NETIF_F_LOOPBACK));
+-
+-	return 0;
+-}
+-
+-static const struct net_device_ops edev10g_netdev_ops = {
+-	.ndo_open = edev10g_netdev_open,
+-	.ndo_stop = edev10g_netdev_stop,
+-	.ndo_change_mtu = edev10g_change_mtu,
+-	.ndo_set_features = edev10g_set_features,
+-	.ndo_start_xmit = n3000_dummy_netdev_xmit,
+-};
+-
+-static void edev10g_adjust_link(struct net_device *netdev)
+-{}
+-
+-static int edev10g_netdev_init(struct net_device *netdev)
+-{
+-	int ret;
+-
+-	ret = edev10g_mtu_init(netdev);
+-	if (ret)
+-		return ret;
+-
+-	return edev10g_set_loopback(netdev,
+-				   !!(netdev->features & NETIF_F_LOOPBACK));
+-}
+-
+-static int dfl_eth_dev_10g_init(struct eth_dev *edev)
+-{
+-	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+-	struct device *dev = edev->dev;
+-	struct phy_device *phydev;
+-	struct net_device *netdev;
+-	int ret;
+-
+-	netdev = n3000_netdev_create(edev);
+-	if (!netdev)
+-		return -ENOMEM;
+-
+-	netdev->hw_features |= NETIF_F_LOOPBACK;
+-	netdev->netdev_ops = &edev10g_netdev_ops;
+-	netdev->ethtool_ops = &edev10g_ethtool_ops;
+-
+-	phydev = phy_connect(netdev, edev->phy_id, edev10g_adjust_link,
+-			     PHY_INTERFACE_MODE_NA);
+-	if (IS_ERR(phydev)) {
+-		dev_err(dev, "PHY connection failed\n");
+-		ret = PTR_ERR(phydev);
+-		goto err_free_netdev;
+-	}
+-
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, mask);
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseSR_Full_BIT, mask);
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseLR_Full_BIT, mask);
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, mask);
+-	linkmode_and(phydev->supported, phydev->supported, mask);
+-	linkmode_copy(phydev->advertising, phydev->supported);
+-
+-	phy_attached_info(phydev);
+-
+-	ret = edev10g_netdev_init(netdev);
+-	if (ret) {
+-		dev_err(dev, "fail to init netdev %s\n", netdev->name);
+-		goto err_phy_disconnect;
+-	}
+-
+-	netdev->sysfs_groups[0] = &edev10g_attr_group;
+-
+-	netif_carrier_off(netdev);
+-	ret = register_netdev(netdev);
+-	if (ret) {
+-		dev_err(dev, "fail to register netdev %s\n", netdev->name);
+-		goto err_phy_disconnect;
+-	}
+-
+-	edev->netdev = netdev;
+-
+-	return 0;
+-
+-err_phy_disconnect:
+-	if (netdev->phydev)
+-		phy_disconnect(phydev);
+-err_free_netdev:
+-	free_netdev(netdev);
+-
+-	return ret;
+-}
+-
+-static void dfl_eth_dev_10g_remove(struct eth_dev *edev)
+-{
+-	struct net_device *netdev = edev->netdev;
+-
+-	if (netdev->phydev)
+-		phy_disconnect(netdev->phydev);
+-
+-	unregister_netdev(netdev);
+-}
+-
+-struct eth_dev_ops dfl_eth_dev_10g_ops = {
+-	.lineside_init = dfl_eth_dev_10g_init,
+-	.lineside_remove = dfl_eth_dev_10g_remove,
+-	.reset = edev10g_reset,
+-};
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group-main.c b/drivers/net/ethernet/intel/dfl-eth-group-main.c
+index 89b4450a1c87..a29b8b16bdbf 100644
+--- a/drivers/net/ethernet/intel/dfl-eth-group-main.c
++++ b/drivers/net/ethernet/intel/dfl-eth-group-main.c
+@@ -481,9 +481,6 @@ static int eth_group_setup(struct dfl_eth_group *egroup)
+ 		return ret;
+ 
+ 	switch (egroup->speed) {
+-	case 10:
+-		egroup->ops = &dfl_eth_dev_10g_ops;
+-		break;
+ 	case 25:
+ 		egroup->ops = &dfl_eth_dev_25g_ops;
+ 		break;
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group.h b/drivers/net/ethernet/intel/dfl-eth-group.h
+index 63f49a039cf2..2e90f86defe2 100644
+--- a/drivers/net/ethernet/intel/dfl-eth-group.h
++++ b/drivers/net/ethernet/intel/dfl-eth-group.h
+@@ -77,7 +77,6 @@ struct net_device *n3000_netdev_create(struct eth_dev *edev);
+ netdev_tx_t n3000_dummy_netdev_xmit(struct sk_buff *skb,
+ 				    struct net_device *dev);
+ 
+-extern struct eth_dev_ops dfl_eth_dev_10g_ops;
+ extern struct eth_dev_ops dfl_eth_dev_25g_ops;
+ extern struct eth_dev_ops dfl_eth_dev_40g_ops;
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0086-Revert-ethernet-dfl-eth-group-add-DFL-eth-group-priv.patch new/debian/patches/fpga-ofs/0086-Revert-ethernet-dfl-eth-group-add-DFL-eth-group-priv.patch
--- org/debian/patches/fpga-ofs/0086-Revert-ethernet-dfl-eth-group-add-DFL-eth-group-priv.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0086-Revert-ethernet-dfl-eth-group-add-DFL-eth-group-priv.patch	2021-07-20 06:17:11.464844696 +0200
@@ -0,0 +1,1374 @@
+From 5d8d9d1ff11cf98a0ede01a451535d74700ca266 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 18 Mar 2021 14:25:11 -0700
+Subject: [PATCH 086/149] Revert "ethernet: dfl-eth-group: add DFL eth group
+ private feature driver"
+
+This reverts commit 2bd81b3327c17a65bab1cbd391c8b0c86fe4eb75.
+Remove eth-group driver - not accepted by the upstream community.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ .../ABI/testing/sysfs-class-net-dfl-eth-group |  19 -
+ drivers/net/ethernet/intel/Kconfig            |  18 -
+ drivers/net/ethernet/intel/Makefile           |   2 -
+ .../net/ethernet/intel/dfl-eth-group-25g.c    | 525 ---------------
+ .../net/ethernet/intel/dfl-eth-group-main.c   | 632 ------------------
+ drivers/net/ethernet/intel/dfl-eth-group.h    |  83 ---
+ .../ethernet/intel/intel-m10-bmc-retimer.c    |   4 +-
+ 7 files changed, 1 insertion(+), 1282 deletions(-)
+ delete mode 100644 Documentation/ABI/testing/sysfs-class-net-dfl-eth-group
+ delete mode 100644 drivers/net/ethernet/intel/dfl-eth-group-25g.c
+ delete mode 100644 drivers/net/ethernet/intel/dfl-eth-group-main.c
+ delete mode 100644 drivers/net/ethernet/intel/dfl-eth-group.h
+
+diff --git a/Documentation/ABI/testing/sysfs-class-net-dfl-eth-group b/Documentation/ABI/testing/sysfs-class-net-dfl-eth-group
+deleted file mode 100644
+index ad528f244a2c..000000000000
+--- a/Documentation/ABI/testing/sysfs-class-net-dfl-eth-group
++++ /dev/null
+@@ -1,19 +0,0 @@
+-What:		/sys/class/net/<iface>/tx_pause_frame_quanta
+-Date:		Oct 2020
+-KernelVersion:	5.11
+-Contact:	Xu Yilun <yilun.xu@intel.com>
+-Description:
+-		Read-Write. Value representing the tx pause quanta of Pause
+-		flow control frames to be sent to remote partner. Read the file
+-		for the actual tx pause quanta value. Write the file to set
+-		value of the tx pause quanta.
+-
+-What:		/sys/class/net/<iface>/tx_pause_frame_holdoff
+-Date:		Oct 2020
+-KernelVersion:	5.11
+-Contact:	Xu Yilun <yilun.xu@intel.com>
+-Description:
+-		Read-Write. Value representing the separation between 2
+-		consecutive XOFF flow control frames. Read the file for the
+-		actual separation value. Write the file to set value of the
+-		separation.
+diff --git a/drivers/net/ethernet/intel/Kconfig b/drivers/net/ethernet/intel/Kconfig
+index d0e023a73485..f3acf9295600 100644
+--- a/drivers/net/ethernet/intel/Kconfig
++++ b/drivers/net/ethernet/intel/Kconfig
+@@ -343,24 +343,6 @@ config IGC
+ 	  To compile this driver as a module, choose M here. The module
+ 	  will be called igc.
+ 
+-config FPGA_DFL_ETH_GROUP
+-        tristate "DFL Ether Group private feature support"
+-        depends on FPGA_DFL && HAS_IOMEM
+-        help
+-          This driver supports DFL Ether Group private feature for
+-	  Intel(R) PAC N3000 FPGA Smart NIC.
+-
+-	  The DFL Ether Group private feature contains several ether
+-	  interfaces, each of them contains an Ether Wrapper and several
+-	  ports (phy-mac pairs). There are two types of interfaces, Line
+-	  side & CPU side. These 2 types of interfaces, together with FPGA
+-	  internal logic, act as several independent pipes between the
+-	  host Ethernet Controller and the front-panel cages. The FPGA
+-	  logic between 2 interfaces implements user defined mac layer
+-	  offloading.
+-
+-	  This driver implements each active port as a netdev.
+-
+ config INTEL_M10_BMC_RETIMER
+ 	tristate "Intel(R) MAX 10 BMC ethernet retimer support"
+ 	depends on MFD_INTEL_M10_BMC
+diff --git a/drivers/net/ethernet/intel/Makefile b/drivers/net/ethernet/intel/Makefile
+index 1d09708e31a6..6ef8d8b39c82 100644
+--- a/drivers/net/ethernet/intel/Makefile
++++ b/drivers/net/ethernet/intel/Makefile
+@@ -17,8 +17,6 @@ obj-$(CONFIG_IAVF) += iavf/
+ obj-$(CONFIG_FM10K) += fm10k/
+ obj-$(CONFIG_ICE) += ice/
+ 
+-dfl-eth-group-objs := dfl-eth-group-main.o dfl-eth-group-25g.o
+-obj-$(CONFIG_FPGA_DFL_ETH_GROUP) += dfl-eth-group.o
+ obj-$(CONFIG_INTEL_M10_BMC_RETIMER) += intel-m10-bmc-retimer.o
+ obj-$(CONFIG_INTEL_M10_BMC_PKVL) += intel-m10-bmc-pkvl.o
+ obj-$(CONFIG_S10HSSI) += s10hssi.o
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group-25g.c b/drivers/net/ethernet/intel/dfl-eth-group-25g.c
+deleted file mode 100644
+index a6903640191f..000000000000
+--- a/drivers/net/ethernet/intel/dfl-eth-group-25g.c
++++ /dev/null
+@@ -1,525 +0,0 @@
+-// SPDX-License-Identifier: GPL-2.0
+-/* Driver for 25G Ether Group private feature on Intel PAC (Programmable
+- * Acceleration Card) N3000
+- *
+- * Copyright (C) 2019-2020 Intel Corporation, Inc.
+- *
+- * Authors:
+- *   Wu Hao <hao.wu@intel.com>
+- *   Xu Yilun <yilun.xu@intel.com>
+- */
+-#include <linux/netdevice.h>
+-
+-#include "dfl-eth-group.h"
+-
+-/* 25G PHY/MAC Register */
+-#define PHY_CONFIG	0x310
+-#define PHY_MAC_RESET_MASK	GENMASK(2, 0)
+-#define PHY_PMA_SLOOP		0x313
+-#define MAX_TX_SIZE_CONFIG	0x407
+-#define MAX_RX_SIZE_CONFIG	0x506
+-#define TX_FLOW_CTRL_EN		0x605
+-#define TX_FLOW_CTRL_EN_PAUSE	BIT(0)
+-#define TX_FLOW_CTRL_QUANTA	0x620
+-#define TX_FLOW_CTRL_HOLDOFF	0x628
+-#define TX_FLOW_CTRL_SEL	0x640
+-#define TX_FLOW_CTRL_SEL_PAUSE	0x0
+-#define TX_FLOW_CTRL_SEL_PFC	0x1
+-
+-static int edev25g40g_reset(struct eth_dev *edev, bool en)
+-{
+-	struct eth_com *mac = edev->mac;
+-	struct device *dev = edev->dev;
+-	u32 val;
+-	int ret;
+-
+-	ret = eth_com_read_reg(mac, PHY_CONFIG, &val);
+-	if (ret) {
+-		dev_err(dev, "fail to read PHY_CONFIG: %d\n", ret);
+-		return ret;
+-	}
+-
+-	/* skip if config is in expected state already */
+-	if ((((val & PHY_MAC_RESET_MASK) == PHY_MAC_RESET_MASK) && en) ||
+-	    (((val & PHY_MAC_RESET_MASK) == 0) && !en))
+-		return 0;
+-
+-	if (en)
+-		val |= PHY_MAC_RESET_MASK;
+-	else
+-		val &= ~PHY_MAC_RESET_MASK;
+-
+-	ret = eth_com_write_reg(mac, PHY_CONFIG, val);
+-	if (ret)
+-		dev_err(dev, "fail to write PHY_CONFIG: %d\n", ret);
+-
+-	return ret;
+-}
+-
+-static ssize_t tx_pause_frame_quanta_show(struct device *d,
+-					  struct device_attribute *attr,
+-					  char *buf)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(to_net_dev(d));
+-	u32 data;
+-	int ret;
+-
+-	ret = eth_com_read_reg(edev->mac, TX_FLOW_CTRL_QUANTA, &data);
+-
+-	return ret ? : sprintf(buf, "0x%x\n", data);
+-}
+-
+-static ssize_t tx_pause_frame_quanta_store(struct device *d,
+-					   struct device_attribute *attr,
+-					   const char *buf, size_t len)
+-{
+-	struct net_device *netdev = to_net_dev(d);
+-	struct eth_dev *edev;
+-	u32 data;
+-	int ret;
+-
+-	if (kstrtou32(buf, 0, &data))
+-		return -EINVAL;
+-
+-	edev = net_device_to_eth_dev(netdev);
+-
+-	rtnl_lock();
+-
+-	if (netif_running(netdev)) {
+-		netdev_err(netdev, "must be stopped to change pause param\n");
+-		ret = -EBUSY;
+-		goto out;
+-	}
+-
+-	ret = eth_com_write_reg(edev->mac, TX_FLOW_CTRL_QUANTA, data);
+-
+-out:
+-	rtnl_unlock();
+-
+-	return ret ? : len;
+-}
+-static DEVICE_ATTR_RW(tx_pause_frame_quanta);
+-
+-static ssize_t tx_pause_frame_holdoff_show(struct device *d,
+-					   struct device_attribute *attr,
+-					   char *buf)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(to_net_dev(d));
+-	u32 data;
+-	int ret;
+-
+-	ret = eth_com_read_reg(edev->mac, TX_FLOW_CTRL_HOLDOFF, &data);
+-
+-	return ret ? : sprintf(buf, "0x%x\n", data);
+-}
+-
+-static ssize_t tx_pause_frame_holdoff_store(struct device *d,
+-					    struct device_attribute *attr,
+-					    const char *buf, size_t len)
+-{
+-	struct net_device *netdev = to_net_dev(d);
+-	struct eth_dev *edev;
+-	u32 data;
+-	int ret;
+-
+-	if (kstrtou32(buf, 0, &data))
+-		return -EINVAL;
+-
+-	edev = net_device_to_eth_dev(netdev);
+-
+-	rtnl_lock();
+-
+-	if (netif_running(netdev)) {
+-		netdev_err(netdev, "must be stopped to change pause param\n");
+-		ret = -EBUSY;
+-		goto out;
+-	}
+-
+-	ret = eth_com_write_reg(edev->mac, TX_FLOW_CTRL_HOLDOFF, data);
+-
+-out:
+-	rtnl_unlock();
+-
+-	return ret ? : len;
+-}
+-static DEVICE_ATTR_RW(tx_pause_frame_holdoff);
+-
+-static struct attribute *edev25g_dev_attrs[] = {
+-	&dev_attr_tx_pause_frame_quanta.attr,
+-	&dev_attr_tx_pause_frame_holdoff.attr,
+-	NULL
+-};
+-
+-/* device attributes */
+-static const struct attribute_group edev25g_attr_group = {
+-	.attrs = edev25g_dev_attrs,
+-};
+-
+-/* ethtool ops */
+-static struct stat_info stats_25g[] = {
+-	/* TX Statistics */
+-	{STAT_INFO(0x800, "tx_fragments")},
+-	{STAT_INFO(0x802, "tx_jabbers")},
+-	{STAT_INFO(0x804, "tx_fcs")},
+-	{STAT_INFO(0x806, "tx_crc_err")},
+-	{STAT_INFO(0x808, "tx_mcast_data_err")},
+-	{STAT_INFO(0x80a, "tx_bcast_data_err")},
+-	{STAT_INFO(0x80c, "tx_ucast_data_err")},
+-	{STAT_INFO(0x80e, "tx_mcast_ctrl_err")},
+-	{STAT_INFO(0x810, "tx_bcast_ctrl_err")},
+-	{STAT_INFO(0x812, "tx_ucast_ctrl_err")},
+-	{STAT_INFO(0x814, "tx_pause_err")},
+-	{STAT_INFO(0x816, "tx_64_byte")},
+-	{STAT_INFO(0x818, "tx_65_127_byte")},
+-	{STAT_INFO(0x81a, "tx_128_255_byte")},
+-	{STAT_INFO(0x81c, "tx_256_511_byte")},
+-	{STAT_INFO(0x81e, "tx_512_1023_byte")},
+-	{STAT_INFO(0x820, "tx_1024_1518_byte")},
+-	{STAT_INFO(0x822, "tx_1519_max_byte")},
+-	{STAT_INFO(0x824, "tx_oversize")},
+-	{STAT_INFO(0x826, "tx_mcast_data_ok")},
+-	{STAT_INFO(0x828, "tx_bcast_data_ok")},
+-	{STAT_INFO(0x82a, "tx_ucast_data_ok")},
+-	{STAT_INFO(0x82c, "tx_mcast_ctrl_ok")},
+-	{STAT_INFO(0x82e, "tx_bcast_ctrl_ok")},
+-	{STAT_INFO(0x830, "tx_ucast_ctrl_ok")},
+-	{STAT_INFO(0x832, "tx_pause")},
+-	{STAT_INFO(0x834, "tx_runt")},
+-	{STAT_INFO(0x860, "tx_payload_octets_ok")},
+-	{STAT_INFO(0x862, "tx_frame_octets_ok")},
+-
+-	/* RX Statistics */
+-	{STAT_INFO(0x900, "rx_fragments")},
+-	{STAT_INFO(0x902, "rx_jabbers")},
+-	{STAT_INFO(0x904, "rx_fcs")},
+-	{STAT_INFO(0x906, "rx_crc_err")},
+-	{STAT_INFO(0x908, "rx_mcast_data_err")},
+-	{STAT_INFO(0x90a, "rx_bcast_data_err")},
+-	{STAT_INFO(0x90c, "rx_ucast_data_err")},
+-	{STAT_INFO(0x90e, "rx_mcast_ctrl_err")},
+-	{STAT_INFO(0x910, "rx_bcast_ctrl_err")},
+-	{STAT_INFO(0x912, "rx_ucast_ctrl_err")},
+-	{STAT_INFO(0x914, "rx_pause_err")},
+-	{STAT_INFO(0x916, "rx_64_byte")},
+-	{STAT_INFO(0x918, "rx_65_127_byte")},
+-	{STAT_INFO(0x91a, "rx_128_255_byte")},
+-	{STAT_INFO(0x91c, "rx_256_511_byte")},
+-	{STAT_INFO(0x91e, "rx_512_1023_byte")},
+-	{STAT_INFO(0x920, "rx_1024_1518_byte")},
+-	{STAT_INFO(0x922, "rx_1519_max_byte")},
+-	{STAT_INFO(0x924, "rx_oversize")},
+-	{STAT_INFO(0x926, "rx_mcast_data_ok")},
+-	{STAT_INFO(0x928, "rx_bcast_data_ok")},
+-	{STAT_INFO(0x92a, "rx_ucast_data_ok")},
+-	{STAT_INFO(0x92c, "rx_mcast_ctrl_ok")},
+-	{STAT_INFO(0x92e, "rx_bcast_ctrl_ok")},
+-	{STAT_INFO(0x930, "rx_ucast_ctrl_ok")},
+-	{STAT_INFO(0x932, "rx_pause")},
+-	{STAT_INFO(0x934, "rx_runt")},
+-	{STAT_INFO(0x960, "rx_payload_octets_ok")},
+-	{STAT_INFO(0x962, "rx_frame_octets_ok")},
+-};
+-
+-static void edev25g_get_strings(struct net_device *netdev, u32 stringset, u8 *s)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	unsigned int i;
+-
+-	if (stringset != ETH_SS_STATS || edev->lw_mac)
+-		return;
+-
+-	for (i = 0; i < ARRAY_SIZE(stats_25g); i++, s += ETH_GSTRING_LEN)
+-		memcpy(s, stats_25g[i].string, ETH_GSTRING_LEN);
+-}
+-
+-static int edev25g_get_sset_count(struct net_device *netdev, int stringset)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-
+-	if (stringset != ETH_SS_STATS || edev->lw_mac)
+-		return -EOPNOTSUPP;
+-
+-	return (int)ARRAY_SIZE(stats_25g);
+-}
+-
+-static void edev25g_get_stats(struct net_device *netdev,
+-			      struct ethtool_stats *stats, u64 *data)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	unsigned int i;
+-
+-	if (edev->lw_mac || !netif_running(netdev))
+-		return;
+-
+-	for (i = 0; i < ARRAY_SIZE(stats_25g); i++)
+-		data[i] = read_mac_stats(edev->mac, stats_25g[i].addr);
+-}
+-
+-static int edev25g_get_link_ksettings(struct net_device *netdev,
+-				      struct ethtool_link_ksettings *cmd)
+-{
+-	if (!netdev->phydev)
+-		return -ENODEV;
+-
+-	phy_ethtool_ksettings_get(netdev->phydev, cmd);
+-
+-	return 0;
+-}
+-
+-static int edev25g_pause_init(struct net_device *netdev)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-
+-	return eth_com_write_reg(edev->mac, TX_FLOW_CTRL_SEL,
+-				 TX_FLOW_CTRL_SEL_PAUSE);
+-}
+-
+-static void edev25g_get_pauseparam(struct net_device *netdev,
+-				   struct ethtool_pauseparam *pause)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	u32 data;
+-	int ret;
+-
+-	pause->autoneg = 0;
+-	pause->rx_pause = 0;
+-
+-	ret = eth_com_read_reg(edev->mac, TX_FLOW_CTRL_EN, &data);
+-	if (ret) {
+-		pause->tx_pause = 0;
+-		return;
+-	}
+-
+-	pause->tx_pause = (data & TX_FLOW_CTRL_EN_PAUSE) ? 0x1 : 0;
+-}
+-
+-static int edev25g_set_pauseparam(struct net_device *netdev,
+-				  struct ethtool_pauseparam *pause)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	bool enable = pause->tx_pause;
+-
+-	if (pause->autoneg || pause->rx_pause)
+-		return -EOPNOTSUPP;
+-
+-	return eth_com_write_reg(edev->mac, TX_FLOW_CTRL_EN,
+-				 enable ? TX_FLOW_CTRL_EN_PAUSE : 0);
+-}
+-
+-static const struct ethtool_ops edev25g_ethtool_ops = {
+-	.get_link = ethtool_op_get_link,
+-	.get_strings = edev25g_get_strings,
+-	.get_sset_count = edev25g_get_sset_count,
+-	.get_ethtool_stats = edev25g_get_stats,
+-	.get_link_ksettings = edev25g_get_link_ksettings,
+-	.get_pauseparam = edev25g_get_pauseparam,
+-	.set_pauseparam = edev25g_set_pauseparam,
+-};
+-
+-/* netdev ops */
+-static int edev25g_netdev_open(struct net_device *netdev)
+-{
+-	struct n3000_net_priv *priv = netdev_priv(netdev);
+-	struct eth_dev *edev = priv->edev;
+-	int ret;
+-
+-	ret = edev25g40g_reset(edev, false);
+-	if (ret)
+-		return ret;
+-
+-	if (netdev->phydev)
+-		phy_start(netdev->phydev);
+-
+-	return 0;
+-}
+-
+-static int edev25g_netdev_stop(struct net_device *netdev)
+-{
+-	struct n3000_net_priv *priv = netdev_priv(netdev);
+-	struct eth_dev *edev = priv->edev;
+-	int ret;
+-
+-	ret = edev25g40g_reset(edev, true);
+-	if (ret)
+-		return ret;
+-
+-	if (netdev->phydev)
+-		phy_stop(netdev->phydev);
+-
+-	return 0;
+-}
+-
+-static int edev25g_mtu_init(struct net_device *netdev)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	struct eth_com *mac = edev->mac;
+-	u32 tx = 0, rx = 0, mtu;
+-	int ret;
+-
+-	ret = eth_com_read_reg(mac, MAX_TX_SIZE_CONFIG, &tx);
+-	if (ret)
+-		return ret;
+-
+-	ret = eth_com_read_reg(mac, MAX_RX_SIZE_CONFIG, &rx);
+-	if (ret)
+-		return ret;
+-
+-	mtu = min(min(tx, rx), netdev->max_mtu);
+-
+-	ret = eth_com_write_reg(mac, MAX_TX_SIZE_CONFIG, rx);
+-	if (ret)
+-		return ret;
+-
+-	ret = eth_com_write_reg(mac, MAX_RX_SIZE_CONFIG, tx);
+-	if (ret)
+-		return ret;
+-
+-	netdev->mtu = mtu;
+-
+-	return 0;
+-}
+-
+-static int edev25g_change_mtu(struct net_device *netdev, int new_mtu)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-	struct eth_com *mac = edev->mac;
+-	int ret;
+-
+-	ret = eth_com_write_reg(mac, MAX_TX_SIZE_CONFIG, new_mtu);
+-	if (ret)
+-		return ret;
+-
+-	ret = eth_com_write_reg(mac, MAX_RX_SIZE_CONFIG, new_mtu);
+-	if (ret)
+-		return ret;
+-
+-	netdev->mtu = new_mtu;
+-
+-	return 0;
+-}
+-
+-static int edev25g_set_loopback(struct net_device *netdev, bool en)
+-{
+-	struct eth_dev *edev = net_device_to_eth_dev(netdev);
+-
+-	return eth_com_write_reg(edev->mac, PHY_PMA_SLOOP, en);
+-}
+-
+-static int edev25g_set_features(struct net_device *netdev,
+-				netdev_features_t features)
+-{
+-	netdev_features_t changed = netdev->features ^ features;
+-
+-	if (changed & NETIF_F_LOOPBACK)
+-		return edev25g_set_loopback(netdev,
+-					    !!(features & NETIF_F_LOOPBACK));
+-
+-	return 0;
+-}
+-
+-static const struct net_device_ops edev25g_netdev_ops = {
+-	.ndo_open = edev25g_netdev_open,
+-	.ndo_stop = edev25g_netdev_stop,
+-	.ndo_change_mtu = edev25g_change_mtu,
+-	.ndo_set_features = edev25g_set_features,
+-	.ndo_start_xmit = n3000_dummy_netdev_xmit,
+-};
+-
+-static void edev25g_adjust_link(struct net_device *netdev)
+-{}
+-
+-static int edev25g_netdev_init(struct net_device *netdev)
+-{
+-	int ret;
+-
+-	ret = edev25g_pause_init(netdev);
+-	if (ret)
+-		return ret;
+-
+-	ret = edev25g_mtu_init(netdev);
+-	if (ret)
+-		return ret;
+-
+-	return edev25g_set_loopback(netdev,
+-				    !!(netdev->features & NETIF_F_LOOPBACK));
+-}
+-
+-static int dfl_eth_dev_25g_init(struct eth_dev *edev)
+-{
+-	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+-	struct device *dev = edev->dev;
+-	struct phy_device *phydev;
+-	struct net_device *netdev;
+-	int ret;
+-
+-	netdev = n3000_netdev_create(edev);
+-	if (!netdev)
+-		return -ENOMEM;
+-
+-	netdev->hw_features |= NETIF_F_LOOPBACK;
+-	netdev->netdev_ops = &edev25g_netdev_ops;
+-	netdev->ethtool_ops = &edev25g_ethtool_ops;
+-
+-	phydev = phy_connect(netdev, edev->phy_id, edev25g_adjust_link,
+-			     PHY_INTERFACE_MODE_NA);
+-	if (IS_ERR(phydev)) {
+-		dev_err(dev, "PHY connection failed\n");
+-		ret = PTR_ERR(phydev);
+-		goto err_free_netdev;
+-	}
+-
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_25000baseCR_Full_BIT, mask);
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_25000baseSR_Full_BIT, mask);
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, mask);
+-	linkmode_and(phydev->supported, phydev->supported, mask);
+-	linkmode_copy(phydev->advertising, phydev->supported);
+-
+-	phy_attached_info(phydev);
+-
+-	ret = edev25g_netdev_init(netdev);
+-	if (ret) {
+-		dev_err(dev, "fail to init netdev %s\n", netdev->name);
+-		goto err_phy_disconnect;
+-	}
+-
+-	netdev->sysfs_groups[0] = &edev25g_attr_group;
+-
+-	netif_carrier_off(netdev);
+-	ret = register_netdev(netdev);
+-	if (ret) {
+-		dev_err(dev, "fail to register netdev %s\n", netdev->name);
+-		goto err_phy_disconnect;
+-	}
+-
+-	edev->netdev = netdev;
+-
+-	return 0;
+-
+-err_phy_disconnect:
+-	if (netdev->phydev)
+-		phy_disconnect(phydev);
+-err_free_netdev:
+-	free_netdev(netdev);
+-
+-	return ret;
+-}
+-
+-static void dfl_eth_dev_25g_remove(struct eth_dev *edev)
+-{
+-	struct net_device *netdev = edev->netdev;
+-
+-	if (netdev->phydev)
+-		phy_disconnect(netdev->phydev);
+-
+-	unregister_netdev(netdev);
+-}
+-
+-struct eth_dev_ops dfl_eth_dev_25g_ops = {
+-	.lineside_init = dfl_eth_dev_25g_init,
+-	.lineside_remove = dfl_eth_dev_25g_remove,
+-	.reset = edev25g40g_reset,
+-};
+-
+-struct eth_dev_ops dfl_eth_dev_40g_ops = {
+-	.reset = edev25g40g_reset,
+-};
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group-main.c b/drivers/net/ethernet/intel/dfl-eth-group-main.c
+deleted file mode 100644
+index a29b8b16bdbf..000000000000
+--- a/drivers/net/ethernet/intel/dfl-eth-group-main.c
++++ /dev/null
+@@ -1,632 +0,0 @@
+-// SPDX-License-Identifier: GPL-2.0
+-/* DFL device driver for Ether Group private feature on Intel PAC (Programmable
+- * Acceleration Card) N3000
+- *
+- * Copyright (C) 2019-2020 Intel Corporation, Inc.
+- *
+- * Authors:
+- *   Wu Hao <hao.wu@intel.com>
+- *   Xu Yilun <yilun.xu@intel.com>
+- */
+-#include <linux/bitfield.h>
+-#include <linux/dfl.h>
+-#include <linux/errno.h>
+-#include <linux/ethtool.h>
+-#include <linux/io.h>
+-#include <linux/iopoll.h>
+-#include <linux/io-64-nonatomic-lo-hi.h>
+-#include <linux/kernel.h>
+-#include <linux/module.h>
+-#include <linux/netdevice.h>
+-#include <linux/rtnetlink.h>
+-#include <linux/stddef.h>
+-#include <linux/types.h>
+-
+-#include "dfl-eth-group.h"
+-
+-struct dfl_eth_group {
+-	char name[32];
+-	struct device *dev;
+-	void __iomem *base;
+-	/* lock to protect register access of the ether group */
+-	struct mutex reg_lock;
+-	struct dfl_device *dfl_dev;
+-	unsigned int config;
+-	unsigned int direction;
+-	unsigned int group_id;
+-	unsigned int speed;
+-	unsigned int lw_mac;
+-	unsigned int num_edevs;
+-	struct eth_dev *edevs;
+-	struct eth_dev_ops *ops;
+-};
+-
+-u64 read_mac_stats(struct eth_com *ecom, unsigned int addr)
+-{
+-	u32 data_l, data_h;
+-
+-	if (eth_com_read_reg(ecom, addr, &data_l) ||
+-	    eth_com_read_reg(ecom, addr + 1, &data_h))
+-		return 0xffffffffffffffffULL;
+-
+-	return data_l + ((u64)data_h << 32);
+-}
+-
+-netdev_tx_t n3000_dummy_netdev_xmit(struct sk_buff *skb,
+-				    struct net_device *dev)
+-{
+-	kfree_skb(skb);
+-	net_warn_ratelimited("%s(): Dropping skb.\n", __func__);
+-	return NETDEV_TX_OK;
+-}
+-
+-static void n3000_netdev_setup(struct net_device *netdev)
+-{
+-	netdev->features = 0;
+-	netdev->hard_header_len = 0;
+-	netdev->priv_flags |= IFF_NO_QUEUE;
+-	netdev->needs_free_netdev = true;
+-	netdev->min_mtu = 0;
+-	netdev->max_mtu = ETH_MAX_MTU;
+-}
+-
+-struct net_device *n3000_netdev_create(struct eth_dev *edev)
+-{
+-	struct dfl_eth_group *egroup = edev->egroup;
+-	struct n3000_net_priv *priv;
+-	struct net_device *netdev;
+-	char name[IFNAMSIZ];
+-
+-	/* The name of n3000 network device is using this format "npacAgBlC"
+-	 *
+-	 * A is the unique ethdev index
+-	 * B is the group id of this ETH Group.
+-	 * C is the PHY/MAC link index for Line side ethernet group.
+-	 */
+-	snprintf(name, IFNAMSIZ, "npac%%dg%ul%u",
+-		 egroup->group_id, edev->index);
+-
+-	netdev = alloc_netdev(sizeof(*priv), name, NET_NAME_UNKNOWN,
+-			      n3000_netdev_setup);
+-	if (!netdev)
+-		return NULL;
+-
+-	priv = netdev_priv(netdev);
+-	priv->edev = edev;
+-	SET_NETDEV_DEV(netdev, egroup->dev);
+-
+-	return netdev;
+-}
+-
+-enum n3000_eth_cfg {
+-	ETH_CONFIG_8x10G,
+-	ETH_CONFIG_4x25G,
+-	ETH_CONFIG_2x1x25G,
+-	ETH_CONFIG_4x25G_2x25G,
+-	ETH_CONFIG_2x2x25G,
+-	ETH_CONFIG_MAX
+-};
+-
+-#define N3000_EDEV_MAX 8
+-
+-static int phy_addr_table[ETH_CONFIG_MAX][N3000_EDEV_MAX] = {
+-	/* 8x10G configuration
+-	 *
+-	 *    [retimer_dev]   <------->   [eth_dev]
+-	 *	  0			   0
+-	 *	  1			   1
+-	 *	  2			   2
+-	 *	  3			   3
+-	 *	  4			   4
+-	 *	  5			   5
+-	 *	  6			   6
+-	 *	  7			   7
+-	 */
+-	[ETH_CONFIG_8x10G] = {0, 1, 2, 3, 4, 5, 6, 7},
+-
+-	/* 4x25G and 4x25G_2x25G configuration
+-	 *
+-	 *    [retimer_dev]   <------->   [eth_dev]
+-	 *	  0			   0
+-	 *	  1			   1
+-	 *	  2			   2
+-	 *	  3			   3
+-	 *	  4
+-	 *	  5
+-	 *	  6
+-	 *	  7
+-	 */
+-	[ETH_CONFIG_4x25G] = {0, 1, 2, 3, -1, -1, -1, -1},
+-	[ETH_CONFIG_4x25G_2x25G] = {0, 1, 2, 3, -1, -1, -1, -1},
+-
+-	/* 2x1x25G configuration
+-	 *
+-	 *    [retimer_dev]   <------->   [eth_dev]
+-	 *        0                      0
+-	 *        1
+-	 *        2
+-	 *        3
+-	 *        4                      1
+-	 *        5
+-	 *        6
+-	 *        7
+-	 */
+-	[ETH_CONFIG_2x1x25G] = {0, 4, -1, -1, -1, -1, -1, -1},
+-
+-	/* 2x2x25G configuration
+-	 *
+-	 *    [retimer_dev]   <------->   [eth_dev]
+-	 *	  0			   0
+-	 *	  1			   1
+-	 *	  2
+-	 *	  3
+-	 *	  4			   2
+-	 *	  5			   3
+-	 *	  6
+-	 *	  7
+-	 */
+-	[ETH_CONFIG_2x2x25G] = {0, 1, 4, 5, -1, -1, -1, -1},
+-};
+-
+-#define eth_group_for_each_dev(edev, egp) \
+-	for ((edev) = (egp)->edevs; (edev) < (egp)->edevs + (egp)->num_edevs; \
+-	     (edev)++)
+-
+-#define eth_group_reverse_each_dev(edev, egp) \
+-	for ((edev)--; (edev) >= (egp)->edevs; (edev)--)
+-
+-static struct mii_bus *eth_group_get_phy_bus(struct dfl_eth_group *egroup)
+-{
+-	char mii_name[MII_BUS_ID_SIZE];
+-	struct device *base_dev;
+-	struct mii_bus *bus;
+-
+-	base_dev = dfl_dev_get_base_dev(egroup->dfl_dev);
+-	if (!base_dev)
+-		return ERR_PTR(-ENODEV);
+-
+-	snprintf(mii_name, MII_BUS_ID_SIZE, DFL_ETH_MII_ID_FMT,
+-		 dev_name(base_dev));
+-
+-	bus = mdio_find_bus(mii_name);
+-	if (!bus)
+-		return ERR_PTR(-EPROBE_DEFER);
+-
+-	return bus;
+-}
+-
+-static int eth_dev_get_phy_id(struct eth_dev *edev, struct mii_bus *bus)
+-{
+-	struct dfl_eth_group *egroup = edev->egroup;
+-	struct phy_device *phydev;
+-	int phyaddr;
+-
+-	phyaddr = phy_addr_table[egroup->config][edev->index];
+-	if (phyaddr < 0)
+-		return -ENODEV;
+-
+-	phydev = mdiobus_get_phy(bus, phyaddr);
+-	if (!phydev) {
+-		dev_err(egroup->dev, "fail to get phydev\n");
+-		return -EPROBE_DEFER;
+-	}
+-
+-	strncpy(edev->phy_id, phydev_name(phydev), MII_BUS_ID_SIZE + 3);
+-	edev->phy_id[MII_BUS_ID_SIZE + 2] = '\0';
+-
+-	return 0;
+-}
+-
+-static int init_lineside_eth_devs(struct dfl_eth_group *egroup,
+-				  struct mii_bus *phy_bus)
+-{
+-	struct eth_dev *edev;
+-	int ret = 0;
+-
+-	if (!egroup->ops->lineside_init)
+-		return -ENODEV;
+-
+-	eth_group_for_each_dev(edev, egroup) {
+-		ret = eth_dev_get_phy_id(edev, phy_bus);
+-		if (ret)
+-			break;
+-
+-		ret = egroup->ops->lineside_init(edev);
+-		if (ret)
+-			break;
+-	}
+-
+-	if (!ret)
+-		return 0;
+-
+-	dev_err(egroup->dev, "failed to init lineside edev %d", edev->index);
+-
+-	if (egroup->ops->lineside_remove)
+-		eth_group_reverse_each_dev(edev, egroup)
+-			egroup->ops->lineside_remove(edev);
+-
+-	return ret;
+-}
+-
+-static void remove_lineside_eth_devs(struct dfl_eth_group *egroup)
+-{
+-	struct eth_dev *edev;
+-
+-	if (!egroup->ops->lineside_remove)
+-		return;
+-
+-	eth_group_for_each_dev(edev, egroup)
+-		egroup->ops->lineside_remove(edev);
+-}
+-
+-#define ETH_GROUP_INFO		0x8
+-#define LIGHT_WEIGHT_MAC	BIT_ULL(25)
+-#define INFO_DIRECTION		BIT_ULL(24)
+-#define INFO_SPEED		GENMASK_ULL(23, 16)
+-#define INFO_PHY_NUM		GENMASK_ULL(15, 8)
+-#define INFO_GROUP_ID		GENMASK_ULL(7, 0)
+-
+-#define ETH_GROUP_CTRL		0x10
+-#define CTRL_CMD		GENMASK_ULL(63, 62)
+-#define CMD_NOP			0
+-#define CMD_RD			1
+-#define CMD_WR			2
+-#define CTRL_DEV_SELECT		GENMASK_ULL(53, 49)
+-#define CTRL_FEAT_SELECT	BIT_ULL(48)
+-#define SELECT_IP		0
+-#define SELECT_FEAT		1
+-#define CTRL_ADDR		GENMASK_ULL(47, 32)
+-#define CTRL_WR_DATA		GENMASK_ULL(31, 0)
+-
+-#define ETH_GROUP_STAT		0x18
+-#define STAT_RW_VAL		BIT_ULL(32)
+-#define STAT_RD_DATA		GENMASK_ULL(31, 0)
+-
+-enum ecom_type {
+-	ETH_GROUP_PHY	= 1,
+-	ETH_GROUP_MAC,
+-	ETH_GROUP_ETHER
+-};
+-
+-struct eth_com {
+-	struct dfl_eth_group *egroup;
+-	unsigned int type;
+-	u8 select;
+-};
+-
+-static const char *eth_com_type_string(enum ecom_type type)
+-{
+-	switch (type) {
+-	case ETH_GROUP_PHY:
+-		return "phy";
+-	case ETH_GROUP_MAC:
+-		return "mac";
+-	case ETH_GROUP_ETHER:
+-		return "ethernet wrapper";
+-	default:
+-		return "unknown";
+-	}
+-}
+-
+-#define eth_com_base(com)	((com)->egroup->base)
+-#define eth_com_dev(com)	((com)->egroup->dev)
+-
+-#define RW_VAL_INVL		1 /* us */
+-#define RW_VAL_POLL_TIMEOUT	10 /* us */
+-
+-static int __do_eth_com_write_reg(struct eth_com *ecom, bool add_feature,
+-				  u16 addr, u32 data)
+-{
+-	void __iomem *base = eth_com_base(ecom);
+-	struct device *dev = eth_com_dev(ecom);
+-	u64 v = 0;
+-
+-	dev_dbg(dev, "%s [%s] select 0x%x add_feat %d addr 0x%x data 0x%x\n",
+-		__func__, eth_com_type_string(ecom->type),
+-		ecom->select, add_feature, addr, data);
+-
+-	/* only PHY has additional feature registers */
+-	if (add_feature && ecom->type != ETH_GROUP_PHY)
+-		return -EINVAL;
+-
+-	v |= FIELD_PREP(CTRL_CMD, CMD_WR);
+-	v |= FIELD_PREP(CTRL_DEV_SELECT, ecom->select);
+-	v |= FIELD_PREP(CTRL_ADDR, addr);
+-	v |= FIELD_PREP(CTRL_WR_DATA, data);
+-	v |= FIELD_PREP(CTRL_FEAT_SELECT, !!add_feature);
+-
+-	writeq(v, base + ETH_GROUP_CTRL);
+-
+-	if (readq_poll_timeout(base + ETH_GROUP_STAT, v, v & STAT_RW_VAL,
+-			       RW_VAL_INVL, RW_VAL_POLL_TIMEOUT))
+-		return -ETIMEDOUT;
+-
+-	return 0;
+-}
+-
+-static int __do_eth_com_read_reg(struct eth_com *ecom, bool add_feature,
+-				 u16 addr, u32 *data)
+-{
+-	void __iomem *base = eth_com_base(ecom);
+-	struct device *dev = eth_com_dev(ecom);
+-	u64 v = 0;
+-
+-	dev_dbg(dev, "%s [%s] select %x add_feat %d addr %x\n",
+-		__func__, eth_com_type_string(ecom->type),
+-		ecom->select, add_feature, addr);
+-
+-	/* only PHY has additional feature registers */
+-	if (add_feature && ecom->type != ETH_GROUP_PHY)
+-		return -EINVAL;
+-
+-	v |= FIELD_PREP(CTRL_CMD, CMD_RD);
+-	v |= FIELD_PREP(CTRL_DEV_SELECT, ecom->select);
+-	v |= FIELD_PREP(CTRL_ADDR, addr);
+-	v |= FIELD_PREP(CTRL_FEAT_SELECT, !!add_feature);
+-
+-	writeq(v, base + ETH_GROUP_CTRL);
+-
+-	if (readq_poll_timeout(base + ETH_GROUP_STAT, v, v & STAT_RW_VAL,
+-			       RW_VAL_INVL, RW_VAL_POLL_TIMEOUT))
+-		return -ETIMEDOUT;
+-
+-	*data = FIELD_GET(STAT_RD_DATA, v);
+-
+-	return 0;
+-}
+-
+-int do_eth_com_write_reg(struct eth_com *ecom, bool add_feature,
+-			 u16 addr, u32 data)
+-{
+-	int ret;
+-
+-	mutex_lock(&ecom->egroup->reg_lock);
+-	ret = __do_eth_com_write_reg(ecom, add_feature, addr, data);
+-	mutex_unlock(&ecom->egroup->reg_lock);
+-	return ret;
+-}
+-
+-int do_eth_com_read_reg(struct eth_com *ecom, bool add_feature,
+-			u16 addr, u32 *data)
+-{
+-	int ret;
+-
+-	mutex_lock(&ecom->egroup->reg_lock);
+-	ret = __do_eth_com_read_reg(ecom, add_feature, addr, data);
+-	mutex_unlock(&ecom->egroup->reg_lock);
+-	return ret;
+-}
+-
+-static struct eth_com *
+-eth_com_create(struct dfl_eth_group *egroup, enum ecom_type type,
+-	       unsigned int link_idx)
+-{
+-	struct eth_com *ecom;
+-
+-	ecom = devm_kzalloc(egroup->dev, sizeof(*ecom), GFP_KERNEL);
+-	if (!ecom)
+-		return ERR_PTR(-ENOMEM);
+-
+-	ecom->egroup = egroup;
+-	ecom->type = type;
+-
+-	if (type == ETH_GROUP_PHY)
+-		ecom->select = link_idx * 2 + 2;
+-	else if (type == ETH_GROUP_MAC)
+-		ecom->select = link_idx * 2 + 3;
+-	else if (type == ETH_GROUP_ETHER)
+-		ecom->select = 0;
+-
+-	return ecom;
+-}
+-
+-static int init_eth_dev(struct eth_dev *edev, struct dfl_eth_group *egroup,
+-			unsigned int link_idx)
+-{
+-	edev->egroup = egroup;
+-	edev->dev = egroup->dev;
+-	edev->index = link_idx;
+-	edev->lw_mac = !!egroup->lw_mac;
+-	edev->phy = eth_com_create(egroup, ETH_GROUP_PHY, link_idx);
+-	if (IS_ERR(edev->phy))
+-		return PTR_ERR(edev->phy);
+-
+-	edev->mac = eth_com_create(egroup, ETH_GROUP_MAC, link_idx);
+-	if (IS_ERR(edev->mac))
+-		return PTR_ERR(edev->mac);
+-
+-	return 0;
+-}
+-
+-static int eth_devs_init(struct dfl_eth_group *egroup)
+-{
+-	int ret, i;
+-
+-	egroup->edevs = devm_kcalloc(egroup->dev, egroup->num_edevs,
+-				     sizeof(*egroup->edevs), GFP_KERNEL);
+-	if (!egroup->edevs)
+-		return -ENOMEM;
+-
+-	for (i = 0; i < egroup->num_edevs; i++) {
+-		ret = init_eth_dev(&egroup->edevs[i], egroup, i);
+-		if (ret)
+-			return ret;
+-	}
+-
+-	return 0;
+-}
+-
+-static int eth_group_setup(struct dfl_eth_group *egroup)
+-{
+-	int net_cfg, ret;
+-	u64 v;
+-
+-	/* read parameters of this ethernet components group */
+-	v = readq(egroup->base + ETH_GROUP_INFO);
+-
+-	egroup->direction = FIELD_GET(INFO_DIRECTION, v);
+-	egroup->speed = FIELD_GET(INFO_SPEED, v);
+-	egroup->num_edevs = FIELD_GET(INFO_PHY_NUM, v);
+-	egroup->group_id = FIELD_GET(INFO_GROUP_ID, v);
+-	egroup->lw_mac = FIELD_GET(LIGHT_WEIGHT_MAC, v);
+-
+-	net_cfg = dfl_dev_get_vendor_net_cfg(egroup->dfl_dev);
+-	if (net_cfg < 0)
+-		return -EINVAL;
+-
+-	egroup->config = (unsigned int)net_cfg;
+-
+-	ret = eth_devs_init(egroup);
+-	if (ret)
+-		return ret;
+-
+-	switch (egroup->speed) {
+-	case 25:
+-		egroup->ops = &dfl_eth_dev_25g_ops;
+-		break;
+-	case 40:
+-		egroup->ops = &dfl_eth_dev_40g_ops;
+-		break;
+-	}
+-
+-	mutex_init(&egroup->reg_lock);
+-
+-	return 0;
+-}
+-
+-static void eth_group_destroy(struct dfl_eth_group *egroup)
+-{
+-	mutex_destroy(&egroup->reg_lock);
+-}
+-
+-static void eth_group_devs_disable(struct dfl_eth_group *egroup)
+-{
+-	struct eth_dev *edev;
+-
+-	eth_group_for_each_dev(edev, egroup)
+-		egroup->ops->reset(edev, true);
+-}
+-
+-static int eth_group_devs_enable(struct dfl_eth_group *egroup)
+-{
+-	struct eth_dev *edev;
+-	int ret;
+-
+-	eth_group_for_each_dev(edev, egroup) {
+-		ret = egroup->ops->reset(edev, false);
+-		if (ret) {
+-			dev_err(egroup->dev, "fail to enable edev%d\n",
+-				edev->index);
+-			eth_group_devs_disable(egroup);
+-			return ret;
+-		}
+-	}
+-
+-	return 0;
+-}
+-
+-static int dfl_eth_group_line_side_init(struct dfl_eth_group *egroup)
+-{
+-	struct mii_bus *phy_bus;
+-	int ret;
+-
+-	if (!egroup->ops || !egroup->ops->reset ||
+-	    !egroup->ops->lineside_init || !egroup->ops->lineside_remove)
+-		return -EINVAL;
+-
+-	eth_group_devs_disable(egroup);
+-
+-	phy_bus = eth_group_get_phy_bus(egroup);
+-	if (IS_ERR(phy_bus))
+-		return PTR_ERR(phy_bus);
+-
+-	ret = init_lineside_eth_devs(egroup, phy_bus);
+-	put_device(&phy_bus->dev);
+-
+-	return ret;
+-}
+-
+-static void dfl_eth_group_line_side_uinit(struct dfl_eth_group *egroup)
+-{
+-	remove_lineside_eth_devs(egroup);
+-}
+-
+-static int dfl_eth_group_host_side_init(struct dfl_eth_group *egroup)
+-{
+-	if (!egroup->ops || !egroup->ops->reset)
+-		return -EINVAL;
+-
+-	return eth_group_devs_enable(egroup);
+-}
+-
+-static int dfl_eth_group_probe(struct dfl_device *dfl_dev)
+-{
+-	struct device *dev = &dfl_dev->dev;
+-	struct dfl_eth_group *egroup;
+-	int ret;
+-
+-	egroup = devm_kzalloc(dev, sizeof(*egroup), GFP_KERNEL);
+-	if (!egroup)
+-		return -ENOMEM;
+-
+-	dev_set_drvdata(&dfl_dev->dev, egroup);
+-
+-	egroup->dev = dev;
+-	egroup->dfl_dev = dfl_dev;
+-
+-	egroup->base = devm_ioremap_resource(dev, &dfl_dev->mmio_res);
+-	if (IS_ERR(egroup->base)) {
+-		dev_err(dev, "get mem resource fail!\n");
+-		return PTR_ERR(egroup->base);
+-	}
+-
+-	ret = eth_group_setup(egroup);
+-	if (ret)
+-		return ret;
+-
+-	if (egroup->direction == 1)
+-		ret = dfl_eth_group_line_side_init(egroup);
+-	else
+-		ret = dfl_eth_group_host_side_init(egroup);
+-
+-	if (!ret)
+-		return 0;
+-
+-	eth_group_destroy(egroup);
+-
+-	return ret;
+-}
+-
+-static void dfl_eth_group_remove(struct dfl_device *dfl_dev)
+-{
+-	struct dfl_eth_group *egroup = dev_get_drvdata(&dfl_dev->dev);
+-
+-	if (egroup->direction == 1)
+-		dfl_eth_group_line_side_uinit(egroup);
+-
+-	eth_group_devs_disable(egroup);
+-	eth_group_destroy(egroup);
+-}
+-
+-#define FME_FEATURE_ID_ETH_GROUP	0x10
+-
+-static const struct dfl_device_id dfl_eth_group_ids[] = {
+-	{ FME_ID, FME_FEATURE_ID_ETH_GROUP },
+-	{ }
+-};
+-
+-static struct dfl_driver dfl_eth_group_driver = {
+-	.drv	= {
+-		.name       = "dfl-eth-group",
+-	},
+-	.id_table = dfl_eth_group_ids,
+-	.probe   = dfl_eth_group_probe,
+-	.remove  = dfl_eth_group_remove,
+-};
+-
+-module_dfl_driver(dfl_eth_group_driver);
+-
+-MODULE_DEVICE_TABLE(dfl, dfl_eth_group_ids);
+-MODULE_DESCRIPTION("DFL ether group driver");
+-MODULE_AUTHOR("Intel Corporation");
+-MODULE_LICENSE("GPL v2");
+diff --git a/drivers/net/ethernet/intel/dfl-eth-group.h b/drivers/net/ethernet/intel/dfl-eth-group.h
+deleted file mode 100644
+index 2e90f86defe2..000000000000
+--- a/drivers/net/ethernet/intel/dfl-eth-group.h
++++ /dev/null
+@@ -1,83 +0,0 @@
+-/* SPDX-License-Identifier: GPL-2.0 */
+-
+-/* Internal header file for FPGA DFL Ether Group Driver
+- *
+- * Copyright (C) 2020 Intel Corporation. All rights reserved.
+- */
+-
+-#ifndef __DFL_ETH_GROUP_H__
+-#define __DFL_ETH_GROUP_H__
+-
+-#include <linux/netdevice.h>
+-#include <linux/phy.h>
+-#include <linux/rtnetlink.h>
+-
+-/* Used when trying to find a virtual mii bus on a specific dfl device.
+- * dev_name(dfl base device)-mii
+- */
+-#define DFL_ETH_MII_ID_FMT "%s-mii"
+-
+-struct eth_dev {
+-	struct dfl_eth_group *egroup;
+-	struct device *dev;
+-	int index;
+-	bool lw_mac;
+-	struct eth_com *phy;
+-	struct eth_com *mac;
+-	struct net_device *netdev;
+-
+-	char phy_id[MII_BUS_ID_SIZE + 3];
+-};
+-
+-struct eth_dev_ops {
+-	int (*lineside_init)(struct eth_dev *edev);
+-	void (*lineside_remove)(struct eth_dev *edev);
+-	int (*reset)(struct eth_dev *edev, bool en);
+-};
+-
+-struct n3000_net_priv {
+-	struct eth_dev *edev;
+-};
+-
+-static inline struct eth_dev *net_device_to_eth_dev(struct net_device *netdev)
+-{
+-	struct n3000_net_priv *priv = netdev_priv(netdev);
+-
+-	return priv->edev;
+-}
+-
+-struct stat_info {
+-	unsigned int addr;
+-	char string[ETH_GSTRING_LEN];
+-};
+-
+-#define STAT_INFO(_addr, _string) \
+-	.addr = _addr, .string = _string,
+-
+-int do_eth_com_write_reg(struct eth_com *ecom, bool add_feature,
+-			 u16 addr, u32 data);
+-int do_eth_com_read_reg(struct eth_com *ecom, bool add_feature,
+-			u16 addr, u32 *data);
+-
+-#define eth_com_write_reg(ecom, addr, data)	\
+-	do_eth_com_write_reg(ecom, false, addr, data)
+-
+-#define eth_com_read_reg(ecom, addr, data)	\
+-	do_eth_com_read_reg(ecom, false, addr, data)
+-
+-#define eth_com_add_feat_write_reg(ecom, addr, data)	\
+-	do_eth_com_write_reg(ecom, true, addr, data)
+-
+-#define eth_com_add_feat_read_reg(ecom, addr, data)	\
+-	do_eth_com_read_reg(ecom, true, addr, data)
+-
+-u64 read_mac_stats(struct eth_com *ecom, unsigned int addr);
+-
+-struct net_device *n3000_netdev_create(struct eth_dev *edev);
+-netdev_tx_t n3000_dummy_netdev_xmit(struct sk_buff *skb,
+-				    struct net_device *dev);
+-
+-extern struct eth_dev_ops dfl_eth_dev_25g_ops;
+-extern struct eth_dev_ops dfl_eth_dev_40g_ops;
+-
+-#endif /* __DFL_ETH_GROUP_H__ */
+diff --git a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+index d20776a96600..066f2014c079 100644
+--- a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
++++ b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+@@ -11,8 +11,6 @@
+ #include <linux/phy.h>
+ #include <linux/platform_device.h>
+ 
+-#include "dfl-eth-group.h"
+-
+ #define NUM_CHIP	2
+ #define MAX_LINK	4
+ 
+@@ -182,7 +180,7 @@ static int m10bmc_retimer_mii_bus_init(struct m10bmc_retimer *retimer)
+ 	bus->name = M10BMC_RETIMER_MII_NAME;
+ 	bus->read = m10bmc_retimer_read;
+ 	bus->write = m10bmc_retimer_write;
+-	snprintf(bus->id, MII_BUS_ID_SIZE, DFL_ETH_MII_ID_FMT,
++	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii",
+ 		 dev_name(retimer->base_dev));
+ 	bus->parent = retimer->dev;
+ 	bus->phy_mask = ~(BITS_MASK(retimer->num_devs));
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0087-Revert-docs-networking-add-the-document-for-DFL-Ethe.patch new/debian/patches/fpga-ofs/0087-Revert-docs-networking-add-the-document-for-DFL-Ethe.patch
--- org/debian/patches/fpga-ofs/0087-Revert-docs-networking-add-the-document-for-DFL-Ethe.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0087-Revert-docs-networking-add-the-document-for-DFL-Ethe.patch	2021-07-20 06:17:11.464844696 +0200
@@ -0,0 +1,140 @@
+From cf525f0269c70a342aac237b9976a6627e0d43d9 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 12:08:47 -0700
+Subject: [PATCH 087/149] Revert "docs: networking: add the document for DFL
+ Ether Group driver"
+
+This reverts commit ca1493167c79d7c498b173d3f0e53e86d3b13617.
+Reverting the DFL Ether Group driver. It was not accepted in
+the upstream kernel.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ .../device_drivers/ethernet/index.rst         |   1 -
+ .../ethernet/intel/dfl-eth-group.rst          | 102 ------------------
+ 2 files changed, 103 deletions(-)
+ delete mode 100644 Documentation/networking/device_drivers/ethernet/intel/dfl-eth-group.rst
+
+diff --git a/Documentation/networking/device_drivers/ethernet/index.rst b/Documentation/networking/device_drivers/ethernet/index.rst
+index eb7c44347a6f..cbb75a1818c0 100644
+--- a/Documentation/networking/device_drivers/ethernet/index.rst
++++ b/Documentation/networking/device_drivers/ethernet/index.rst
+@@ -26,7 +26,6 @@ Contents:
+    freescale/gianfar
+    google/gve
+    huawei/hinic
+-   intel/dfl-eth-group
+    intel/e100
+    intel/e1000
+    intel/e1000e
+diff --git a/Documentation/networking/device_drivers/ethernet/intel/dfl-eth-group.rst b/Documentation/networking/device_drivers/ethernet/intel/dfl-eth-group.rst
+deleted file mode 100644
+index 525807e9d0dc..000000000000
+--- a/Documentation/networking/device_drivers/ethernet/intel/dfl-eth-group.rst
++++ /dev/null
+@@ -1,102 +0,0 @@
+-.. SPDX-License-Identifier: GPL-2.0+
+-
+-=======================================================================
+-DFL device driver for Ether Group private feature on Intel(R) PAC N3000
+-=======================================================================
+-
+-This is the driver for Ether Group private feature on Intel(R)
+-PAC (Programmable Acceleration Card) N3000.
+-
+-The Intel(R) PAC N3000 is a FPGA based SmartNIC platform for multi-workload
+-networking application acceleration. A simple diagram below to for the board:
+-
+-                     +----------------------------------------+
+-                     |                  FPGA                  |
+-+----+   +-------+   +-----------+  +----------+  +-----------+   +----------+
+-|QSFP|---|retimer|---|Line Side  |--|User logic|--|Host Side  |---|XL710     |
+-+----+   +-------+   |Ether Group|  |          |  |Ether Group|   |Ethernet  |
+-                     |(PHY + MAC)|  |wiring &  |  |(MAC + PHY)|   |Controller|
+-                     +-----------+  |offloading|  +-----------+   +----------+
+-                     |              +----------+              |
+-                     |                                        |
+-                     +----------------------------------------+
+-
+-The FPGA is composed of FPGA Interface Module (FIM) and Accelerated Function
+-Unit (AFU). The FIM implements the basic functionalities for FPGA access,
+-management and reprograming, while the AFU is the FPGA reprogramable region for
+-users.
+-
+-The Line Side & Host Side Ether Groups are soft IP blocks embedded in FIM. They
+-are internally wire connected to AFU and communicate with AFU with MAC packets.
+-The user logic is developed by the FPGA users and re-programmed to AFU,
+-providing the user defined wire connections between line side & host side data
+-interfaces, as well as the MAC layer offloading.
+-
+-There are 2 types of interfaces for the Ether Groups:
+-
+-1. The data interfaces connects the Ether Groups and the AFU, host has no
+-ability to control the data stream . So the FPGA is like a pipe between the
+-host ethernet controller and the retimer chip.
+-
+-2. The management interfaces connects the Ether Groups to the host, so host
+-could access the Ether Group registers for configuration and statistics
+-reading.
+-
+-The Intel(R) PAC N3000 could be programmed to various configurations (with
+-different link numbers and speeds, e.g. 8x10G, 4x25G ...). It is done by
+-programing different variants of the Ether Group IP blocks, and doing
+-corresponding configuration to the retimer chips.
+-
+-The DFL Ether Group driver registers netdev for each line side link. Users
+-could use standard commands (ethtool, ip, ifconfig) for configuration and
+-link state/statistics reading. For host side links, they are always connected
+-to the host ethernet controller, so they should always have same features as
+-the host ethernet controller. There is no need to register netdevs for them.
+-The driver just enables these links on probe.
+-
+-The retimer chips are managed by onboard BMC (Board Management Controller)
+-firmware, host driver is not capable to access them directly. So it is mostly
+-like an external fixed PHY. However the link states detected by the retimer
+-chips can not be propagated to the Ether Groups for hardware limitation, in
+-order to manage the link state, a PHY driver (intel-m10-bmc-retimer) is
+-introduced to query the BMC for the retimer's link state. The Ether Group
+-driver would connect to the PHY devices and get the link states. The
+-intel-m10-bmc-retimer driver creates a peseudo MDIO bus for each board, so
+-that the Ether Group driver could find the PHY devices by their peseudo PHY
+-addresses.
+-
+-
+-2. Features supported
+-=====================
+-
+-Data Path
+----------
+-Since the driver can't control the data stream, the Ether Group driver
+-doesn't implement the valid tx/rx functions. Any transmit attempt on these
+-links from host will be dropped, and no data could be received to host from
+-these links. Users should operate on the netdev of host ethernet controller
+-for networking data traffic.
+-
+-
+-Speed/Duplex
+-------------
+-The Ether Group doesn't support auto-negotiation. The link speed is fixed to
+-10G, 25G or 40G full duplex according to which Ether Group IP is programmed.
+-
+-Statistics
+-----------
+-The Ether Group IP has the statistics counters for ethernet traffic and errors.
+-The user can obtain these MAC-level statistics using "ethtool -S" option.
+-
+-MTU
+----
+-The Ether Group IP is capable of detecting oversized packets. It will not drop
+-the packet but pass it up and increment the tx/rx oversize counters. The MTU
+-could be changed via ip or ifconfig commands.
+-
+-Flow Control
+-------------
+-Ethernet Flow Control (IEEE 802.3x) can be configured with ethtool to enable
+-transmitting pause frames. Receiving pause request from outside to Ether Group
+-MAC is not supported. The flow control auto-negotiation is not supported. The
+-user can enable or disable Tx Flow Control using "ethtool -A eth? tx <on|off>"
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0088-dfl-remove-CONFIG_FPGA_DFL_ETH_GROUP.patch new/debian/patches/fpga-ofs/0088-dfl-remove-CONFIG_FPGA_DFL_ETH_GROUP.patch
--- org/debian/patches/fpga-ofs/0088-dfl-remove-CONFIG_FPGA_DFL_ETH_GROUP.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0088-dfl-remove-CONFIG_FPGA_DFL_ETH_GROUP.patch	2021-07-20 06:17:11.464844696 +0200
@@ -0,0 +1,27 @@
+From 8a1797479605da3bde31eadd2cba5ca0afc35f5d Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 18 Mar 2021 14:13:51 -0700
+Subject: [PATCH 088/149] dfl: remove CONFIG_FPGA_DFL_ETH_GROUP
+
+Remove eth-group driver - not accepted by the upstream community.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ configs/n3000_d5005_defconfig | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/configs/n3000_d5005_defconfig b/configs/n3000_d5005_defconfig
+index ffcc122c4101..294b39baedd7 100644
+--- a/configs/n3000_d5005_defconfig
++++ b/configs/n3000_d5005_defconfig
+@@ -24,7 +24,6 @@ CONFIG_MFD_INTEL_M10_BMC=m
+ 
+ CONFIG_SPI_ALTERA=m
+ 
+-# CONFIG_FPGA_DFL_ETH_GROUP is not set
+ CONFIG_INTEL_S10_PHY=m
+ CONFIG_INTEL_M10_BMC_RETIMER=m
+ CONFIG_S10HSSI=m
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0089-Revert-ethernet-m10-retimer-expose-the-retimer-firmw.patch new/debian/patches/fpga-ofs/0089-Revert-ethernet-m10-retimer-expose-the-retimer-firmw.patch
--- org/debian/patches/fpga-ofs/0089-Revert-ethernet-m10-retimer-expose-the-retimer-firmw.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0089-Revert-ethernet-m10-retimer-expose-the-retimer-firmw.patch	2021-07-20 06:17:11.464844696 +0200
@@ -0,0 +1,130 @@
+From b6db7ce30be1b492567b26ff27de694da03e8174 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 18 Mar 2021 14:27:47 -0700
+Subject: [PATCH 089/149] Revert "ethernet: m10-retimer: expose the retimer
+ firmware version information"
+
+This reverts commit 68ef6ca286083e217ac9242a907605eabfc7766e.
+Remove m10-retimer driver - not accepted by the upstream community.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ .../sysfs-driver-intel-m10-bmc-retimer        | 31 -----------------
+ .../ethernet/intel/intel-m10-bmc-retimer.c    | 33 -------------------
+ include/linux/mfd/intel-m10-bmc.h             |  4 ---
+ 3 files changed, 68 deletions(-)
+ delete mode 100644 Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-retimer
+
+diff --git a/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-retimer b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-retimer
+deleted file mode 100644
+index a84db188233e..000000000000
+--- a/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc-retimer
++++ /dev/null
+@@ -1,31 +0,0 @@
+-What:		/sys/bus/platform/devices/n3000bmc-retimer.*.auto/A_sbus_version
+-Date:		Sep 2020
+-KernelVersion:	5.10
+-Contact:	Xu Yilun <yilun.xu@intel.com>
+-Description:	Read only. Returns the Transceiver bus firmware version of
+-		retimer chip A.
+-		Format: "0x%04x".
+-
+-What:		/sys/bus/platform/devices/n3000bmc-retimer.*.auto/A_serdes_version
+-Date:		Sep 2020
+-KernelVersion:	5.10
+-Contact:	Xu Yilun <yilun.xu@intel.com>
+-Description:	Read only. Returns the SERDES firmware version of retimer
+-		chip A.
+-		Format: "0x%04x".
+-
+-What:		/sys/bus/platform/devices/n3000bmc-retimer.*.auto/B_sbus_version
+-Date:		Sep 2020
+-KernelVersion:  5.10
+-Contact:	Xu Yilun <yilun.xu@intel.com>
+-Description:	Read only. Returns the Transceiver bus firmware version of
+-		retimer chip B.
+-		Format: "0x%04x".
+-
+-What:		/sys/bus/platform/devices/n3000bmc-retimer.*.auto/B_serdes_version
+-Date:		Sep 2020
+-KernelVersion:  5.10
+-Contact:	Xu Yilun <yilun.xu@intel.com>
+-Description:	Read only. Returns the SERDES firmware version of retimer
+-		chip B.
+-		Format: "0x%04x".
+diff --git a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+index 066f2014c079..c7b05581e546 100644
+--- a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
++++ b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+@@ -4,7 +4,6 @@
+  * Copyright (C) 2018-2020 Intel Corporation. All rights reserved.
+  *
+  */
+-#include <linux/bitfield.h>
+ #include <linux/device.h>
+ #include <linux/mfd/intel-m10-bmc.h>
+ #include <linux/module.h>
+@@ -27,37 +26,6 @@ struct m10bmc_retimer {
+ 	struct mii_bus *retimer_mii_bus;
+ };
+ 
+-#define retimer_version_attr(chip, type, reg, field)			\
+-static ssize_t								\
+-chip##_##type##_version_show(struct device *dev,				\
+-			     struct device_attribute *attr, char *buf)	\
+-{									\
+-	struct m10bmc_retimer *retimer = dev_get_drvdata(dev);		\
+-	unsigned int val;						\
+-	int ret;							\
+-									\
+-	ret = m10bmc_sys_read(retimer->m10bmc, reg, &val);		\
+-	if (ret)							\
+-		return ret;						\
+-									\
+-	return sprintf(buf, "0x%04x\n", (u16)FIELD_GET(field, val));	\
+-}									\
+-static DEVICE_ATTR_RO(chip##_##type##_version)
+-
+-retimer_version_attr(A, sbus, PKVL_A_VERSION, SBUS_VERSION);
+-retimer_version_attr(A, serdes, PKVL_A_VERSION, SERDES_VERSION);
+-retimer_version_attr(B, sbus, PKVL_B_VERSION, SBUS_VERSION);
+-retimer_version_attr(B, serdes, PKVL_B_VERSION, SERDES_VERSION);
+-
+-static struct attribute *m10bmc_retimer_attrs[] = {
+-	&dev_attr_A_sbus_version.attr,
+-	&dev_attr_A_serdes_version.attr,
+-	&dev_attr_B_sbus_version.attr,
+-	&dev_attr_B_serdes_version.attr,
+-	NULL,
+-};
+-ATTRIBUTE_GROUPS(m10bmc_retimer);
+-
+ #define RETIMER_LINK_STAT_BIT(retimer_id, link_id) \
+ 	BIT(((retimer_id) << 2) + (link_id))
+ 
+@@ -233,7 +201,6 @@ static struct platform_driver intel_m10bmc_retimer_driver = {
+ 	.remove = intel_m10bmc_retimer_remove,
+ 	.driver = {
+ 		.name = N3000BMC_RETIMER_DEV_NAME,
+-		.dev_groups = m10bmc_retimer_groups,
+ 	},
+ };
+ 
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 5d8edd5bcd2d..2648e2d25a1c 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -55,10 +55,6 @@ enum m10bmc_type {
+ #define PKVL_B_HDR_CHECKSUM		BIT(28)
+ #define PKVL_EEPROM_UPG_STATUS		GENMASK(31, 16)
+ #define PKVL_LINK_STATUS		0x164
+-#define PKVL_A_VERSION			0x254
+-#define PKVL_B_VERSION			0x258
+-#define SERDES_VERSION			GENMASK(15, 0)
+-#define SBUS_VERSION			GENMASK(31, 16)
+ 
+ #define PKVL_PRELOAD			(PKVL_A_PRELOAD | PKVL_B_PRELOAD)
+ #define PKVL_PRELOAD_TIMEOUT		(PKVL_A_PRELOAD_TIMEOUT | \
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0090-Revert-ethernet-m10-retimer-add-support-for-retimers.patch new/debian/patches/fpga-ofs/0090-Revert-ethernet-m10-retimer-add-support-for-retimers.patch
--- org/debian/patches/fpga-ofs/0090-Revert-ethernet-m10-retimer-add-support-for-retimers.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0090-Revert-ethernet-m10-retimer-add-support-for-retimers.patch	2021-07-20 06:17:11.468844685 +0200
@@ -0,0 +1,415 @@
+From 16ea111571582118be08938d72d94c5bcfd66df5 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 18 Mar 2021 14:39:30 -0700
+Subject: [PATCH 090/149] Revert "ethernet: m10-retimer: add support for
+ retimers on Intel MAX 10 BMC"
+
+This reverts commit 3a42989c5287f8e860758f77ea1a1ee827a639f9.
+Remove m10-retimer driver - not accepted by the upstream community.
+---
+ drivers/fpga/dfl-n3000-nios.c                 |  11 +-
+ drivers/mfd/intel-m10-bmc.c                   |  18 --
+ drivers/net/ethernet/intel/Kconfig            |  12 -
+ drivers/net/ethernet/intel/Makefile           |   1 -
+ .../ethernet/intel/intel-m10-bmc-retimer.c    | 229 ------------------
+ include/linux/mfd/intel-m10-bmc.h             |  14 --
+ 6 files changed, 2 insertions(+), 283 deletions(-)
+ delete mode 100644 drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+
+diff --git a/drivers/fpga/dfl-n3000-nios.c b/drivers/fpga/dfl-n3000-nios.c
+index 15e32e290278..6d3c4123b374 100644
+--- a/drivers/fpga/dfl-n3000-nios.c
++++ b/drivers/fpga/dfl-n3000-nios.c
+@@ -16,7 +16,6 @@
+ #include <linux/io-64-nonatomic-lo-hi.h>
+ #include <linux/kernel.h>
+ #include <linux/module.h>
+-#include <linux/mfd/intel-m10-bmc.h>
+ #include <linux/platform_device.h>
+ #include <linux/regmap.h>
+ #include <linux/stddef.h>
+@@ -164,8 +163,6 @@ struct n3000_nios {
+ 	struct regmap *regmap;
+ 	struct device *dev;
+ 	struct platform_device *altera_spi;
+-	struct intel_m10bmc_platdata m10bmc_pdata;
+-	struct intel_m10bmc_retimer_pdata m10bmc_retimer_pdata;
+ };
+ 
+ static ssize_t nios_fw_version_show(struct device *dev,
+@@ -423,8 +420,7 @@ static struct spi_board_info m10_n3000_info = {
+ 	.chip_select = 0,
+ };
+ 
+-static int create_altera_spi_controller(struct n3000_nios *nn,
+-					struct device *retimer_master)
++static int create_altera_spi_controller(struct n3000_nios *nn)
+ {
+ 	struct altera_spi_platform_data pdata = { 0 };
+ 	struct platform_device_info pdevinfo = { 0 };
+@@ -443,9 +439,6 @@ static int create_altera_spi_controller(struct n3000_nios *nn,
+ 	pdata.bits_per_word_mask =
+ 		SPI_BPW_RANGE_MASK(1, FIELD_GET(N3000_NS_PARAM_DATA_WIDTH, v));
+ 
+-	nn->m10bmc_retimer_pdata.retimer_master = retimer_master;
+-	nn->m10bmc_pdata.retimer = &nn->m10bmc_retimer_pdata;
+-	m10_n3000_info.platform_data = &nn->m10bmc_pdata;
+ 	pdata.num_devices = 1;
+ 	pdata.devices = &m10_n3000_info;
+ 
+@@ -564,7 +557,7 @@ static int n3000_nios_probe(struct dfl_device *ddev)
+ 	if (ret)
+ 		return ret;
+ 
+-	ret = create_altera_spi_controller(nn, dfl_dev_get_base_dev(ddev));
++	ret = create_altera_spi_controller(nn);
+ 	if (ret)
+ 		dev_err(dev, "altera spi controller create failed: %d\n", ret);
+ 
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index 555e98c2e723..d2714d9ecef2 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -28,21 +28,6 @@ static struct mfd_cell m10bmc_pacn3000_subdevs[] = {
+ 	{ .name = "n3000bmc-secure" },
+ };
+ 
+-static void
+-m10bmc_init_cells_platdata(struct intel_m10bmc_platdata *pdata,
+-			   struct mfd_cell *cells, int n_cell)
+-{
+-	int i;
+-
+-	for (i = 0; i < n_cell; i++) {
+-		if (!strcmp(cells[i].name, "n3000bmc-retimer")) {
+-			cells[i].platform_data = pdata->retimer;
+-			cells[i].pdata_size =
+-				pdata->retimer ? sizeof(*pdata->retimer) : 0;
+-		}
+-	}
+-}
+-
+ static const struct regmap_range n3000_fw_handshake_regs[] = {
+ 	regmap_reg_range(M10BMC_N3000_TELEM_START, M10BMC_N3000_TELEM_END),
+ };
+@@ -258,7 +243,6 @@ static int check_m10bmc_version(struct intel_m10bmc *ddata)
+ 
+ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ {
+-	struct intel_m10bmc_platdata *pdata = dev_get_platdata(&spi->dev);
+ 	const struct spi_device_id *id = spi_get_device_id(spi);
+ 	struct device *dev = &spi->dev;
+ 	struct mfd_cell *cells;
+@@ -307,8 +291,6 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ 		return -ENODEV;
+ 	}
+ 
+-	m10bmc_init_cells_platdata(pdata, cells, n_cell);
+-
+ 	ret = devm_mfd_add_devices(dev, PLATFORM_DEVID_AUTO, cells, n_cell,
+ 				   NULL, 0, NULL);
+ 	if (ret)
+diff --git a/drivers/net/ethernet/intel/Kconfig b/drivers/net/ethernet/intel/Kconfig
+index f3acf9295600..fdebe11fcc77 100644
+--- a/drivers/net/ethernet/intel/Kconfig
++++ b/drivers/net/ethernet/intel/Kconfig
+@@ -343,18 +343,6 @@ config IGC
+ 	  To compile this driver as a module, choose M here. The module
+ 	  will be called igc.
+ 
+-config INTEL_M10_BMC_RETIMER
+-	tristate "Intel(R) MAX 10 BMC ethernet retimer support"
+-	depends on MFD_INTEL_M10_BMC
+-	select PHYLIB
+-        help
+-          This driver supports the ethernet retimer (Parkvale) on
+-	  Intel(R) MAX 10 BMC, which is used by Intel PAC N3000 FPGA based
+-	  Smart NIC.
+-
+-	  To compile this driver as a module, choose M here. The module
+-	  will be called intel-m10-bmc-retimer.
+-
+ config S10HSSI
+ 	tristate "Control Plane Driver for Stratix 10 HSSI"
+ 	select REGMAP_INDIRECT_REGISTER
+diff --git a/drivers/net/ethernet/intel/Makefile b/drivers/net/ethernet/intel/Makefile
+index 6ef8d8b39c82..0927da1652fd 100644
+--- a/drivers/net/ethernet/intel/Makefile
++++ b/drivers/net/ethernet/intel/Makefile
+@@ -17,6 +17,5 @@ obj-$(CONFIG_IAVF) += iavf/
+ obj-$(CONFIG_FM10K) += fm10k/
+ obj-$(CONFIG_ICE) += ice/
+ 
+-obj-$(CONFIG_INTEL_M10_BMC_RETIMER) += intel-m10-bmc-retimer.o
+ obj-$(CONFIG_INTEL_M10_BMC_PKVL) += intel-m10-bmc-pkvl.o
+ obj-$(CONFIG_S10HSSI) += s10hssi.o
+diff --git a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
+deleted file mode 100644
+index c7b05581e546..000000000000
+--- a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
++++ /dev/null
+@@ -1,229 +0,0 @@
+-// SPDX-License-Identifier: GPL-2.0
+-/* Intel Max10 BMC Retimer Interface Driver
+- *
+- * Copyright (C) 2018-2020 Intel Corporation. All rights reserved.
+- *
+- */
+-#include <linux/device.h>
+-#include <linux/mfd/intel-m10-bmc.h>
+-#include <linux/module.h>
+-#include <linux/phy.h>
+-#include <linux/platform_device.h>
+-
+-#define NUM_CHIP	2
+-#define MAX_LINK	4
+-
+-#define BITS_MASK(nbits)	((1 << (nbits)) - 1)
+-
+-#define N3000BMC_RETIMER_DEV_NAME "n3000bmc-retimer"
+-#define M10BMC_RETIMER_MII_NAME "m10bmc retimer mii"
+-
+-struct m10bmc_retimer {
+-	struct device *dev;
+-	struct intel_m10bmc *m10bmc;
+-	int num_devs;
+-	struct device *base_dev;
+-	struct mii_bus *retimer_mii_bus;
+-};
+-
+-#define RETIMER_LINK_STAT_BIT(retimer_id, link_id) \
+-	BIT(((retimer_id) << 2) + (link_id))
+-
+-static u32 retimer_get_link(struct m10bmc_retimer *retimer, int index)
+-{
+-	unsigned int val;
+-
+-	if (m10bmc_sys_read(retimer->m10bmc, PKVL_LINK_STATUS, &val)) {
+-		dev_err(retimer->dev, "fail to read PKVL_LINK_STATUS\n");
+-		return 0;
+-	}
+-
+-	if (val & BIT(index))
+-		return 1;
+-
+-	return 0;
+-}
+-
+-static int m10bmc_retimer_phy_match(struct phy_device *phydev)
+-{
+-	if (phydev->mdio.bus->name &&
+-	    !strcmp(phydev->mdio.bus->name, M10BMC_RETIMER_MII_NAME)) {
+-		return 1;
+-	}
+-
+-	return 0;
+-}
+-
+-static int m10bmc_retimer_phy_probe(struct phy_device *phydev)
+-{
+-	struct m10bmc_retimer *retimer = phydev->mdio.bus->priv;
+-
+-	phydev->priv = retimer;
+-
+-	return 0;
+-}
+-
+-static void m10bmc_retimer_phy_remove(struct phy_device *phydev)
+-{
+-	if (phydev->attached_dev)
+-		phy_disconnect(phydev);
+-}
+-
+-static int m10bmc_retimer_read_status(struct phy_device *phydev)
+-{
+-	struct m10bmc_retimer *retimer = phydev->priv;
+-
+-	phydev->link = retimer_get_link(retimer, phydev->mdio.addr);
+-
+-	phydev->duplex = DUPLEX_FULL;
+-
+-	return 0;
+-}
+-
+-static int m10bmc_retimer_get_features(struct phy_device *phydev)
+-{
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+-			 phydev->supported);
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseSR_Full_BIT,
+-			 phydev->supported);
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseLR_Full_BIT,
+-			 phydev->supported);
+-
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_25000baseCR_Full_BIT,
+-			 phydev->supported);
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_25000baseSR_Full_BIT,
+-			 phydev->supported);
+-
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT,
+-			 phydev->supported);
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT,
+-			 phydev->supported);
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT,
+-			 phydev->supported);
+-
+-	linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->supported);
+-
+-	return 0;
+-}
+-
+-static struct phy_driver m10bmc_retimer_phy_driver = {
+-	.phy_id			= 0xffffffff,
+-	.phy_id_mask		= 0xffffffff,
+-	.name			= "m10bmc retimer PHY",
+-	.match_phy_device	= m10bmc_retimer_phy_match,
+-	.probe			= m10bmc_retimer_phy_probe,
+-	.remove			= m10bmc_retimer_phy_remove,
+-	.read_status		= m10bmc_retimer_read_status,
+-	.get_features		= m10bmc_retimer_get_features,
+-	.read_mmd		= genphy_read_mmd_unsupported,
+-	.write_mmd		= genphy_write_mmd_unsupported,
+-};
+-
+-static int m10bmc_retimer_read(struct mii_bus *bus, int addr, int regnum)
+-{
+-	struct m10bmc_retimer *retimer = bus->priv;
+-
+-	if (addr < retimer->num_devs &&
+-	    (regnum == MII_PHYSID1 || regnum == MII_PHYSID2))
+-		return 0;
+-
+-	return 0xffff;
+-}
+-
+-static int m10bmc_retimer_write(struct mii_bus *bus, int addr, int regnum, u16 val)
+-{
+-	return 0;
+-}
+-
+-static int m10bmc_retimer_mii_bus_init(struct m10bmc_retimer *retimer)
+-{
+-	struct mii_bus *bus;
+-	int ret;
+-
+-	bus = devm_mdiobus_alloc(retimer->dev);
+-	if (!bus)
+-		return -ENOMEM;
+-
+-	bus->priv = (void *)retimer;
+-	bus->name = M10BMC_RETIMER_MII_NAME;
+-	bus->read = m10bmc_retimer_read;
+-	bus->write = m10bmc_retimer_write;
+-	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii",
+-		 dev_name(retimer->base_dev));
+-	bus->parent = retimer->dev;
+-	bus->phy_mask = ~(BITS_MASK(retimer->num_devs));
+-
+-	ret = mdiobus_register(bus);
+-	if (ret)
+-		return ret;
+-
+-	retimer->retimer_mii_bus = bus;
+-
+-	return 0;
+-}
+-
+-static void m10bmc_retimer_mii_bus_uinit(struct m10bmc_retimer *retimer)
+-{
+-	mdiobus_unregister(retimer->retimer_mii_bus);
+-}
+-
+-static int intel_m10bmc_retimer_probe(struct platform_device *pdev)
+-{
+-	struct intel_m10bmc_retimer_pdata *pdata = dev_get_platdata(&pdev->dev);
+-	struct intel_m10bmc *m10bmc = dev_get_drvdata(pdev->dev.parent);
+-	struct m10bmc_retimer *retimer;
+-
+-	retimer = devm_kzalloc(&pdev->dev, sizeof(*retimer), GFP_KERNEL);
+-	if (!retimer)
+-		return -ENOMEM;
+-
+-	dev_set_drvdata(&pdev->dev, retimer);
+-
+-	retimer->dev = &pdev->dev;
+-	retimer->m10bmc = m10bmc;
+-	retimer->base_dev = pdata->retimer_master;
+-	retimer->num_devs = NUM_CHIP * MAX_LINK;
+-
+-	return m10bmc_retimer_mii_bus_init(retimer);
+-}
+-
+-static int intel_m10bmc_retimer_remove(struct platform_device *pdev)
+-{
+-	struct m10bmc_retimer *retimer = dev_get_drvdata(&pdev->dev);
+-
+-	m10bmc_retimer_mii_bus_uinit(retimer);
+-
+-	return 0;
+-}
+-
+-static struct platform_driver intel_m10bmc_retimer_driver = {
+-	.probe = intel_m10bmc_retimer_probe,
+-	.remove = intel_m10bmc_retimer_remove,
+-	.driver = {
+-		.name = N3000BMC_RETIMER_DEV_NAME,
+-	},
+-};
+-
+-static int __init intel_m10bmc_retimer_init(void)
+-{
+-	int ret;
+-
+-	ret = phy_driver_register(&m10bmc_retimer_phy_driver, THIS_MODULE);
+-	if (ret)
+-		return ret;
+-
+-	return platform_driver_register(&intel_m10bmc_retimer_driver);
+-}
+-module_init(intel_m10bmc_retimer_init);
+-
+-static void __exit intel_m10bmc_retimer_exit(void)
+-{
+-	platform_driver_unregister(&intel_m10bmc_retimer_driver);
+-	phy_driver_unregister(&m10bmc_retimer_phy_driver);
+-}
+-module_exit(intel_m10bmc_retimer_exit);
+-
+-MODULE_ALIAS("platform:" N3000BMC_RETIMER_DEV_NAME);
+-MODULE_AUTHOR("Intel Corporation");
+-MODULE_DESCRIPTION("Intel MAX 10 BMC retimer driver");
+-MODULE_LICENSE("GPL");
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 2648e2d25a1c..b3294ba7ae3e 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -54,7 +54,6 @@ enum m10bmc_type {
+ #define PKVL_B_DATA_TOO_BIG		BIT(26)
+ #define PKVL_B_HDR_CHECKSUM		BIT(28)
+ #define PKVL_EEPROM_UPG_STATUS		GENMASK(31, 16)
+-#define PKVL_LINK_STATUS		0x164
+ 
+ #define PKVL_PRELOAD			(PKVL_A_PRELOAD | PKVL_B_PRELOAD)
+ #define PKVL_PRELOAD_TIMEOUT		(PKVL_A_PRELOAD_TIMEOUT | \
+@@ -164,19 +163,6 @@ enum m10bmc_type {
+ /* Address of 4KB inverted bit vector containing staging area FLASH count */
+ #define STAGING_FLASH_COUNT	0x17ffb000
+ 
+-/**
+- * struct intel_m10bmc_retimer_pdata - subdev retimer platform data
+- *
+- * @retimer_master: the NIC device which connects to the retimers on m10bmc
+- */
+-struct intel_m10bmc_retimer_pdata {
+-	struct device *retimer_master;
+-};
+-
+-struct intel_m10bmc_platdata {
+-	struct intel_m10bmc_retimer_pdata *retimer;
+-};
+-
+ enum m10bmc_fw_state {
+ 	M10BMC_FW_STATE_NORMAL,
+ 	M10BMC_FW_STATE_SEC_UPDATE,
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0091-dfl-remove-config-parameter-INTEL_M10_BMC_RETIMER.patch new/debian/patches/fpga-ofs/0091-dfl-remove-config-parameter-INTEL_M10_BMC_RETIMER.patch
--- org/debian/patches/fpga-ofs/0091-dfl-remove-config-parameter-INTEL_M10_BMC_RETIMER.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0091-dfl-remove-config-parameter-INTEL_M10_BMC_RETIMER.patch	2021-07-20 06:17:11.468844685 +0200
@@ -0,0 +1,28 @@
+From c4b85d8a1684d9e6ce972153f710eb83baa34e43 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 18 Mar 2021 10:38:37 -0700
+Subject: [PATCH 091/149] dfl: remove config parameter INTEL_M10_BMC_RETIMER
+
+The driver associated with the INTEL_M10_BMC_RETIMER config has been
+removed.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ configs/n3000_d5005_defconfig | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/configs/n3000_d5005_defconfig b/configs/n3000_d5005_defconfig
+index 294b39baedd7..dda5069bb46f 100644
+--- a/configs/n3000_d5005_defconfig
++++ b/configs/n3000_d5005_defconfig
+@@ -25,7 +25,6 @@ CONFIG_MFD_INTEL_M10_BMC=m
+ CONFIG_SPI_ALTERA=m
+ 
+ CONFIG_INTEL_S10_PHY=m
+-CONFIG_INTEL_M10_BMC_RETIMER=m
+ CONFIG_S10HSSI=m
+ 
+ CONFIG_REGMAP_MMIO=m
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0092-mfd-intel-m10-bmc-Add-M10BMC-prefix-to-PKVL-constant.patch new/debian/patches/fpga-ofs/0092-mfd-intel-m10-bmc-Add-M10BMC-prefix-to-PKVL-constant.patch
--- org/debian/patches/fpga-ofs/0092-mfd-intel-m10-bmc-Add-M10BMC-prefix-to-PKVL-constant.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0092-mfd-intel-m10-bmc-Add-M10BMC-prefix-to-PKVL-constant.patch	2021-07-20 06:17:11.468844685 +0200
@@ -0,0 +1,138 @@
+From e658149655d354c26adc248acbc26e481080238e Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 16:49:06 -0700
+Subject: [PATCH 092/149] mfd: intel-m10-bmc: Add M10BMC prefix to PKVL
+ constants
+
+Change the PKVL_ constants in the MAX10 BMC driver to incude a M10BMC
+prefix. This will elmininate some of the differences with the
+upstreaming version of the code and simplify future cherry-picking.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 20 +++++------
+ include/linux/mfd/intel-m10-bmc.h   | 54 ++++++++++++++---------------
+ 2 files changed, 36 insertions(+), 38 deletions(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 893f2ea5aa9f..e1850af8e39c 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -592,8 +592,8 @@ static int trigger_retimer_eeprom_load(struct m10bmc_sec *sec)
+ 				       M10BMC_SYS_BASE + M10BMC_DOORBELL,
+ 				       val,
+ 				       (!(val & DRBL_PKVL_EEPROM_LOAD_SEC)),
+-				       PKVL_EEPROM_LOAD_INTERVAL_US,
+-				       PKVL_EEPROM_LOAD_TIMEOUT_US);
++				       M10BMC_PKVL_LOAD_INTERVAL_US,
++				       M10BMC_PKVL_LOAD_TIMEOUT_US);
+ 	if (ret == -ETIMEDOUT) {
+ 		dev_err(sec->dev, "%s PKVL_EEPROM_LOAD clear timedout\n",
+ 			__func__);
+@@ -627,8 +627,8 @@ static int poll_retimer_eeprom_load_done(struct m10bmc_sec *sec)
+ 					 RSU_PROG_PKVL_PROM_DONE) ||
+ 					(rsu_stat(doorbell) ==
+ 					 RSU_STAT_PKVL_REJECT)),
+-				       PKVL_PRELOAD_INTERVAL_US,
+-				       PKVL_PRELOAD_TIMEOUT_US);
++				       M10BMC_PKVL_PRELOAD_INTERVAL_US,
++				       M10BMC_PKVL_PRELOAD_TIMEOUT_US);
+ 	if (ret) {
+ 		if (ret == -ETIMEDOUT)
+ 			dev_err(sec->dev,
+@@ -659,17 +659,17 @@ static int poll_retimer_preload_done(struct m10bmc_sec *sec)
+ 	 * and confirm that the updated firmware is operational
+ 	 */
+ 	ret = regmap_read_poll_timeout(m10bmc->regmap,
+-				       M10BMC_SYS_BASE + PKVL_POLLING_CTRL, val,
+-				       ((val & PKVL_PRELOAD) == PKVL_PRELOAD),
+-				       PKVL_PRELOAD_INTERVAL_US,
+-				       PKVL_PRELOAD_TIMEOUT_US);
++				       M10BMC_SYS_BASE + M10BMC_PKVL_POLL_CTRL, val,
++				       ((val & M10BMC_PKVL_PRELOAD) == M10BMC_PKVL_PRELOAD),
++				       M10BMC_PKVL_PRELOAD_INTERVAL_US,
++				       M10BMC_PKVL_PRELOAD_TIMEOUT_US);
+ 	if (ret) {
+-		dev_err(sec->dev, "%s poll PKVL_PRELOAD error %d\n",
++		dev_err(sec->dev, "%s poll M10BMC_PKVL_PRELOAD error %d\n",
+ 			__func__, ret);
+ 		return ret;
+ 	}
+ 
+-	if ((val & PKVL_UPG_STATUS_MASK) != PKVL_UPG_STATUS_GOOD) {
++	if ((val & M10BMC_PKVL_UPG_STATUS_MASK) != M10BMC_PKVL_UPG_STATUS_GOOD) {
+ 		dev_err(sec->dev, "%s error detected during upgrade\n",
+ 			__func__);
+ 		return -EIO;
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index b3294ba7ae3e..c3e65bbfdee7 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -42,38 +42,36 @@ enum m10bmc_type {
+ #define M10BMC_VER_PCB_INFO_MSK		GENMASK(31, 24)
+ #define M10BMC_VER_LEGACY_INVALID	0xffffffff
+ 
+-/* PKVL related registers, in system register region */
+-#define PKVL_POLLING_CTRL		0x80
+-#define POLLING_MODE			GENMASK(15, 0)
+-#define PKVL_A_PRELOAD			BIT(16)
+-#define PKVL_A_PRELOAD_TIMEOUT		BIT(17)
+-#define PKVL_A_DATA_TOO_BIG		BIT(18)
+-#define PKVL_A_HDR_CHECKSUM		BIT(20)
+-#define PKVL_B_PRELOAD			BIT(24)
+-#define PKVL_B_PRELOAD_TIMEOUT		BIT(25)
+-#define PKVL_B_DATA_TOO_BIG		BIT(26)
+-#define PKVL_B_HDR_CHECKSUM		BIT(28)
+-#define PKVL_EEPROM_UPG_STATUS		GENMASK(31, 16)
+-
+-#define PKVL_PRELOAD			(PKVL_A_PRELOAD | PKVL_B_PRELOAD)
+-#define PKVL_PRELOAD_TIMEOUT		(PKVL_A_PRELOAD_TIMEOUT | \
+-					 PKVL_B_PRELOAD_TIMEOUT)
+-#define PKVL_DATA_TOO_BIG		(PKVL_A_DATA_TOO_BIG | \
+-					 PKVL_B_DATA_TOO_BIG)
+-#define PKVL_HDR_CHECKSUM		(PKVL_A_HDR_CHECKSUM | \
+-					 PKVL_B_HDR_CHECKSUM)
+-
+-#define PKVL_UPG_STATUS_MASK		(PKVL_PRELOAD | PKVL_PRELOAD_TIMEOUT |\
+-					 PKVL_DATA_TOO_BIG | PKVL_HDR_CHECKSUM)
+-#define PKVL_UPG_STATUS_GOOD		(PKVL_PRELOAD | PKVL_HDR_CHECKSUM)
++/* Retimer related registers, in system register region */
++#define M10BMC_PKVL_POLL_CTRL		0x80
++#define M10BMC_PKVL_A_PRELOAD		BIT(16)
++#define M10BMC_PKVL_A_PRELOAD_TO	BIT(17)
++#define M10BMC_PKVL_A_DATA_TOO_BIG	BIT(18)
++#define M10BMC_PKVL_A_HDR_CKSUM	BIT(20)
++#define M10BMC_PKVL_B_PRELOAD		BIT(24)
++#define M10BMC_PKVL_B_PRELOAD_TO	BIT(25)
++#define M10BMC_PKVL_B_DATA_TOO_BIG	BIT(26)
++#define M10BMC_PKVL_B_HDR_CKSUM	BIT(28)
++
++#define M10BMC_PKVL_PRELOAD		(M10BMC_PKVL_A_PRELOAD | M10BMC_PKVL_B_PRELOAD)
++#define M10BMC_PKVL_PRELOAD_TIMEOUT	(M10BMC_PKVL_A_PRELOAD_TO | \
++					 M10BMC_PKVL_B_PRELOAD_TO)
++#define M10BMC_PKVL_DATA_TOO_BIG	(M10BMC_PKVL_A_DATA_TOO_BIG | \
++					 M10BMC_PKVL_B_DATA_TOO_BIG)
++#define M10BMC_PKVL_HDR_CHECKSUM	(M10BMC_PKVL_A_HDR_CKSUM | \
++					 M10BMC_PKVL_B_HDR_CKSUM)
++
++#define M10BMC_PKVL_UPG_STATUS_MASK	(M10BMC_PKVL_PRELOAD | M10BMC_PKVL_PRELOAD_TIMEOUT |\
++					 M10BMC_PKVL_DATA_TOO_BIG | M10BMC_PKVL_HDR_CHECKSUM)
++#define M10BMC_PKVL_UPG_STATUS_GOOD	(M10BMC_PKVL_PRELOAD | M10BMC_PKVL_HDR_CHECKSUM)
+ 
+ /* interval 100ms and timeout 2s */
+-#define PKVL_EEPROM_LOAD_INTERVAL_US	(100 * 1000)
+-#define PKVL_EEPROM_LOAD_TIMEOUT_US	(2 * 1000 * 1000)
++#define M10BMC_PKVL_LOAD_INTERVAL_US	(100 * 1000)
++#define M10BMC_PKVL_LOAD_TIMEOUT_US	(2 * 1000 * 1000)
+ 
+ /* interval 100ms and timeout 30s */
+-#define PKVL_PRELOAD_INTERVAL_US	(100 * 1000)
+-#define PKVL_PRELOAD_TIMEOUT_US		(30 * 1000 * 1000)
++#define M10BMC_PKVL_PRELOAD_INTERVAL_US	(100 * 1000)
++#define M10BMC_PKVL_PRELOAD_TIMEOUT_US	(30 * 1000 * 1000)
+ 
+ /* Telemetry registers */
+ #define M10BMC_N3000_TELEM_START	0x100
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0093-Revert-fpga-dfl-export-network-configuration-info-fo.patch new/debian/patches/fpga-ofs/0093-Revert-fpga-dfl-export-network-configuration-info-fo.patch
--- org/debian/patches/fpga-ofs/0093-Revert-fpga-dfl-export-network-configuration-info-fo.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0093-Revert-fpga-dfl-export-network-configuration-info-fo.patch	2021-07-20 06:17:11.472844674 +0200
@@ -0,0 +1,129 @@
+From a872b3481848fc5673bfd860e60d0490e71067bb Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 14:11:36 -0700
+Subject: [PATCH 093/149] Revert "fpga: dfl: export network configuration info
+ for DFL based FPGA"
+
+This reverts commit 06d847d8e36e3e2c0513390a68b66d067cf1b696.
+Reverting driver code that was not accepted for the upstream kernel.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl-fme-main.c | 11 +++++++++--
+ drivers/fpga/dfl.c          | 30 ------------------------------
+ drivers/fpga/dfl.h          | 14 --------------
+ include/linux/dfl.h         |  3 ---
+ 4 files changed, 9 insertions(+), 49 deletions(-)
+
+diff --git a/drivers/fpga/dfl-fme-main.c b/drivers/fpga/dfl-fme-main.c
+index 687b7bd6e581..967c40debfdb 100644
+--- a/drivers/fpga/dfl-fme-main.c
++++ b/drivers/fpga/dfl-fme-main.c
+@@ -47,8 +47,15 @@ static DEVICE_ATTR_RO(ports_num);
+ static ssize_t bitstream_id_show(struct device *dev,
+ 				 struct device_attribute *attr, char *buf)
+ {
+-	return scnprintf(buf, PAGE_SIZE, "0x%llx\n",
+-			 (unsigned long long)dfl_get_bitstream_id(dev));
++	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
++	void __iomem *base;
++	u64 v;
++
++	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
++
++	v = readq(base + FME_HDR_BITSTREAM_ID);
++
++	return scnprintf(buf, PAGE_SIZE, "0x%llx\n", (unsigned long long)v);
+ }
+ static DEVICE_ATTR_RO(bitstream_id);
+ 
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index d993f4d34754..08487540e063 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -474,36 +474,6 @@ void dfl_driver_unregister(struct dfl_driver *dfl_drv)
+ }
+ EXPORT_SYMBOL(dfl_driver_unregister);
+ 
+-int dfl_dev_get_vendor_net_cfg(struct dfl_device *dfl_dev)
+-{
+-	struct device *fme_dev;
+-	u64 v;
+-
+-	if (!dfl_dev)
+-		return -EINVAL;
+-
+-	if (dfl_dev->type == FME_ID)
+-		fme_dev = dfl_dev->dev.parent;
+-	else
+-		fme_dev = dfl_dev->cdev->fme_dev;
+-
+-	if (!fme_dev)
+-		return -EINVAL;
+-
+-	v = dfl_get_bitstream_id(fme_dev);
+-	return (int)FIELD_GET(FME_BID_VENDOR_NET_CFG, v);
+-}
+-EXPORT_SYMBOL_GPL(dfl_dev_get_vendor_net_cfg);
+-
+-struct device *dfl_dev_get_base_dev(struct dfl_device *dfl_dev)
+-{
+-	if (!dfl_dev || !dfl_dev->cdev)
+-		return NULL;
+-
+-	return dfl_dev->cdev->parent;
+-}
+-EXPORT_SYMBOL_GPL(dfl_dev_get_base_dev);
+-
+ #define is_header_feature(feature) ((feature)->id == FEATURE_ID_FIU_HEADER)
+ 
+ /**
+diff --git a/drivers/fpga/dfl.h b/drivers/fpga/dfl.h
+index 65b15fb35d82..e61095c2d853 100644
+--- a/drivers/fpga/dfl.h
++++ b/drivers/fpga/dfl.h
+@@ -79,9 +79,6 @@
+ #define FME_CAP_CACHE_SIZE	GENMASK_ULL(43, 32)	/* cache size in KB */
+ #define FME_CAP_CACHE_ASSOC	GENMASK_ULL(47, 44)	/* Associativity */
+ 
+-/* FME BITSTREAM_ID Register Bitfield */
+-#define FME_BID_VENDOR_NET_CFG	GENMASK_ULL(35, 32)     /* vendor net cfg */
+-
+ /* FME Port Offset Register Bitfield */
+ /* Offset to port device feature header */
+ #define FME_PORT_OFST_DFH_OFST	GENMASK_ULL(23, 0)
+@@ -399,17 +396,6 @@ to_dfl_feature_dev_data(struct device *dev)
+ 	return pdata->fdata;
+ }
+ 
+-static inline u64 dfl_get_bitstream_id(struct device *dev)
+-{
+-	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+-
+-	void __iomem *base;
+-
+-	base = dfl_get_feature_ioaddr_by_id(fdata, FME_FEATURE_ID_HEADER);
+-
+-	return readq(base + FME_HDR_BITSTREAM_ID);
+-}
+-
+ static inline
+ struct device *dfl_fpga_fdata_to_parent(struct dfl_feature_dev_data *fdata)
+ {
+diff --git a/include/linux/dfl.h b/include/linux/dfl.h
+index 0593ee85fb13..1cd86b2e7cb1 100644
+--- a/include/linux/dfl.h
++++ b/include/linux/dfl.h
+@@ -67,9 +67,6 @@ struct dfl_driver {
+ #define to_dfl_dev(d) container_of(d, struct dfl_device, dev)
+ #define to_dfl_drv(d) container_of(d, struct dfl_driver, drv)
+ 
+-int dfl_dev_get_vendor_net_cfg(struct dfl_device *dfl_dev);
+-struct device *dfl_dev_get_base_dev(struct dfl_device *dfl_dev);
+-
+ /*
+  * use a macro to avoid include chaining to get THIS_MODULE.
+  */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0094-net-ethernet-intel-remove-extraneous-makefile-line.patch new/debian/patches/fpga-ofs/0094-net-ethernet-intel-remove-extraneous-makefile-line.patch
--- org/debian/patches/fpga-ofs/0094-net-ethernet-intel-remove-extraneous-makefile-line.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0094-net-ethernet-intel-remove-extraneous-makefile-line.patch	2021-07-20 06:17:11.472844674 +0200
@@ -0,0 +1,26 @@
+From a3adcd68e0dac9382f77f4393113ea5ce71f279f Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 18 Mar 2021 13:50:50 -0700
+Subject: [PATCH 094/149] net: ethernet: intel: remove extraneous makefile line
+
+Remove a makefile line that was erroneously added during a patch port.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/net/ethernet/intel/Makefile | 2 --
+ 1 file changed, 2 deletions(-)
+
+diff --git a/drivers/net/ethernet/intel/Makefile b/drivers/net/ethernet/intel/Makefile
+index 0927da1652fd..13b58801662e 100644
+--- a/drivers/net/ethernet/intel/Makefile
++++ b/drivers/net/ethernet/intel/Makefile
+@@ -16,6 +16,4 @@ obj-$(CONFIG_IXGB) += ixgb/
+ obj-$(CONFIG_IAVF) += iavf/
+ obj-$(CONFIG_FM10K) += fm10k/
+ obj-$(CONFIG_ICE) += ice/
+-
+-obj-$(CONFIG_INTEL_M10_BMC_PKVL) += intel-m10-bmc-pkvl.o
+ obj-$(CONFIG_S10HSSI) += s10hssi.o
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0095-Revert-drivers-mfd-intel-m10-bmc-add-debugfs-support.patch new/debian/patches/fpga-ofs/0095-Revert-drivers-mfd-intel-m10-bmc-add-debugfs-support.patch
--- org/debian/patches/fpga-ofs/0095-Revert-drivers-mfd-intel-m10-bmc-add-debugfs-support.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0095-Revert-drivers-mfd-intel-m10-bmc-add-debugfs-support.patch	2021-07-20 06:17:11.472844674 +0200
@@ -0,0 +1,60 @@
+From fa6f012f0a5ea452112c69935c33dbeeee0a542a Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 18 Mar 2021 15:39:08 -0700
+Subject: [PATCH 095/149] Revert "drivers: mfd: intel-m10-bmc add debugfs
+ support to regmap"
+
+This reverts commit 75d4ed4872c33efd1efea7f6b484bb8a7d5c20c8.
+Revert to replace with the latest version of the patch
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/mfd/intel-m10-bmc.c       | 12 ------------
+ include/linux/mfd/intel-m10-bmc.h |  2 --
+ 2 files changed, 14 deletions(-)
+
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index d2714d9ecef2..15d99367da3c 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -114,22 +114,10 @@ int m10bmc_sys_update_bits(struct intel_m10bmc *m10bmc, unsigned int offset,
+ }
+ EXPORT_SYMBOL_GPL(m10bmc_sys_update_bits);
+ 
+-static const struct regmap_range m10_regmap_range[] = {
+-	regmap_reg_range(M10BMC_LEGACY_SYS_BASE, M10BMC_SYS_END),
+-	regmap_reg_range(M10BMC_FLASH_BASE, M10BMC_MEM_END),
+-};
+-
+-static const struct regmap_access_table m10_access_table = {
+-	.yes_ranges	= m10_regmap_range,
+-	.n_yes_ranges	= ARRAY_SIZE(m10_regmap_range),
+-};
+-
+ static struct regmap_config intel_m10bmc_regmap_config = {
+ 	.reg_bits = 32,
+ 	.val_bits = 32,
+ 	.reg_stride = 4,
+-	.wr_table = &m10_access_table,
+-	.rd_table = &m10_access_table,
+ 	.max_register = M10BMC_MEM_END,
+ };
+ 
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index c3e65bbfdee7..d52df5e48d58 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -18,10 +18,8 @@ enum m10bmc_type {
+ 
+ #define M10BMC_LEGACY_SYS_BASE		0x300400
+ #define M10BMC_SYS_BASE			0x300800
+-#define M10BMC_SYS_END			0x300fff
+ #define M10BMC_MEM_END			0x200000fc
+ 
+-#define M10BMC_FLASH_BASE		0x10000000
+ #define M10BMC_STAGING_BASE		0x18000000
+ #define M10BMC_STAGING_SIZE		0x3800000
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0096-mfd-intel-m10-bmc-Simplify-the-legacy-version-reg-de.patch new/debian/patches/fpga-ofs/0096-mfd-intel-m10-bmc-Simplify-the-legacy-version-reg-de.patch
--- org/debian/patches/fpga-ofs/0096-mfd-intel-m10-bmc-Simplify-the-legacy-version-reg-de.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0096-mfd-intel-m10-bmc-Simplify-the-legacy-version-reg-de.patch	2021-07-20 06:17:11.472844674 +0200
@@ -0,0 +1,62 @@
+From e8e792c80c88e32aee6585bee34a0aef96c03237 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Thu, 21 Jan 2021 16:46:57 +0800
+Subject: [PATCH 096/149] mfd: intel-m10-bmc: Simplify the legacy version reg
+ definition
+
+The version register is the only one in the legacy I/O space to be
+accessed, so it is not necessary to define the legacy base & version
+register offset. A direct definition of the legacy version register
+address would be fine.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+----
+v3: no change, rebased to 5.12-rc1
+---
+ drivers/mfd/intel-m10-bmc.c       | 12 +++++-------
+ include/linux/mfd/intel-m10-bmc.h |  2 +-
+ 2 files changed, 6 insertions(+), 8 deletions(-)
+
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index 15d99367da3c..919ccb0dc3a1 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -208,16 +208,14 @@ static int check_m10bmc_version(struct intel_m10bmc *ddata)
+ 
+ 	/*
+ 	 * This check is to filter out the very old legacy BMC versions,
+-	 * M10BMC_LEGACY_SYS_BASE is the offset to this old block of mmio
+-	 * registers. In the old BMC chips, the BMC version info is stored
+-	 * in this old version register (M10BMC_LEGACY_SYS_BASE +
+-	 * M10BMC_BUILD_VER), so its read out value would have not been
+-	 * LEGACY_INVALID (0xffffffff). But in new BMC chips that the
++	 * 0x300400 is the offset to this old block of mmio registers. In the
++	 * old BMC chips, the BMC version info is stored in this old version
++	 * register (0x300400 + 0x68), so its read out value would have not
++	 * been LEGACY_INVALID (0xffffffff). But in new BMC chips that the
+ 	 * driver supports, the value of this register should be
+ 	 * LEGACY_INVALID.
+ 	 */
+-	ret = m10bmc_raw_read(ddata,
+-			      M10BMC_LEGACY_SYS_BASE + M10BMC_BUILD_VER, &v);
++	ret = m10bmc_raw_read(ddata, M10BMC_LEGACY_BUILD_VER, &v);
+ 	if (ret)
+ 		return -ENODEV;
+ 
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index d52df5e48d58..e91528d4f5d2 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -16,7 +16,7 @@ enum m10bmc_type {
+ 	M10_D5005
+ };
+ 
+-#define M10BMC_LEGACY_SYS_BASE		0x300400
++#define M10BMC_LEGACY_BUILD_VER		0x300468
+ #define M10BMC_SYS_BASE			0x300800
+ #define M10BMC_MEM_END			0x200000fc
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0097-mfd-intel-m10-bmc-Add-access-table-configuration-to-.patch new/debian/patches/fpga-ofs/0097-mfd-intel-m10-bmc-Add-access-table-configuration-to-.patch
--- org/debian/patches/fpga-ofs/0097-mfd-intel-m10-bmc-Add-access-table-configuration-to-.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0097-mfd-intel-m10-bmc-Add-access-table-configuration-to-.patch	2021-07-20 06:17:11.472844674 +0200
@@ -0,0 +1,68 @@
+From 89474b64116829db6a4e31d821f5f16ad32f88b5 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Tue, 20 Oct 2020 14:19:50 -0400
+Subject: [PATCH 097/149] mfd: intel-m10-bmc: Add access table configuration to
+ the regmap
+
+This patch adds access tables to the MAX 10 BMC regmap. This prevents
+the host from accessing the unwanted I/O space. It also filters out the
+invalid outputs when reading the regmap debugfs interface.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+----
+v2: Use the new macro M10BMC_LEGACY_BUILD_VER
+v3: No change, rebased to 5.12-rc1
+---
+ drivers/mfd/intel-m10-bmc.c       | 13 +++++++++++++
+ include/linux/mfd/intel-m10-bmc.h |  5 ++++-
+ 2 files changed, 17 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index 919ccb0dc3a1..17c2105b68ca 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -114,10 +114,23 @@ int m10bmc_sys_update_bits(struct intel_m10bmc *m10bmc, unsigned int offset,
+ }
+ EXPORT_SYMBOL_GPL(m10bmc_sys_update_bits);
+ 
++static const struct regmap_range m10bmc_regmap_range[] = {
++	regmap_reg_range(M10BMC_LEGACY_BUILD_VER, M10BMC_LEGACY_BUILD_VER),
++	regmap_reg_range(M10BMC_SYS_BASE, M10BMC_SYS_END),
++	regmap_reg_range(M10BMC_FLASH_BASE, M10BMC_FLASH_END),
++};
++
++static const struct regmap_access_table m10bmc_access_table = {
++	.yes_ranges	= m10bmc_regmap_range,
++	.n_yes_ranges	= ARRAY_SIZE(m10bmc_regmap_range),
++};
++
+ static struct regmap_config intel_m10bmc_regmap_config = {
+ 	.reg_bits = 32,
+ 	.val_bits = 32,
+ 	.reg_stride = 4,
++	.wr_table = &m10bmc_access_table,
++	.rd_table = &m10bmc_access_table,
+ 	.max_register = M10BMC_MEM_END,
+ };
+ 
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index e91528d4f5d2..478b70df0d84 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -18,7 +18,10 @@ enum m10bmc_type {
+ 
+ #define M10BMC_LEGACY_BUILD_VER		0x300468
+ #define M10BMC_SYS_BASE			0x300800
+-#define M10BMC_MEM_END			0x200000fc
++#define M10BMC_SYS_END			0x300fff
++#define M10BMC_FLASH_BASE		0x10000000
++#define M10BMC_FLASH_END		0x1fffffff
++#define M10BMC_MEM_END			M10BMC_FLASH_END
+ 
+ #define M10BMC_STAGING_BASE		0x18000000
+ #define M10BMC_STAGING_SIZE		0x3800000
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0098-mfd-intel-m10-bmc-Clean-up-mac-address-documentation.patch new/debian/patches/fpga-ofs/0098-mfd-intel-m10-bmc-Clean-up-mac-address-documentation.patch
--- org/debian/patches/fpga-ofs/0098-mfd-intel-m10-bmc-Clean-up-mac-address-documentation.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0098-mfd-intel-m10-bmc-Clean-up-mac-address-documentation.patch	2021-07-20 06:17:11.472844674 +0200
@@ -0,0 +1,48 @@
+From b642f32cd7e34fa474a2d6e1a8222e174430c507 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 11:08:42 -0700
+Subject: [PATCH 098/149] mfd: intel-m10-bmc: Clean up mac address
+ documentation
+
+Provide a better description in the Documentation file for mac_address
+and mac_count sysfs nodes.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ .../ABI/testing/sysfs-driver-intel-m10-bmc        | 15 ++++++++-------
+ 1 file changed, 8 insertions(+), 7 deletions(-)
+
+diff --git a/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc
+index c4febaefe0a7..8c9b027af1de 100644
+--- a/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc
++++ b/Documentation/ABI/testing/sysfs-driver-intel-m10-bmc
+@@ -18,18 +18,19 @@ What:		/sys/bus/spi/devices/.../mac_address
+ Date:		December 2020
+ KernelVersion:  5.11
+ Contact:	Russ Weight <russell.h.weight@intel.com>
+-Description:	Read only. Returns the base mac address assigned to
+-		the board managed by the Intel MAX10 BMC. It is
+-		stored in flash and is mirrored in the MAX10 BMC
+-		register space.
++Description:	Read only. Returns the first MAC address in a block
++		of sequential MAC addresses assigned to the board
++		that is managed by the Intel MAX10 BMC. It is stored in
++		FLASH storage and is mirrored in the MAX10 BMC register
++		space.
+ 		Format: "%02x:%02x:%02x:%02x:%02x:%02x".
+ 
+ What:		/sys/bus/spi/devices/.../mac_count
+ Date:		December 2020
+ KernelVersion:  5.11
+ Contact:	Russ Weight <russell.h.weight@intel.com>
+-Description:	Read only. Returns the number of mac addresses
+-		assigned to the board managed by the Intel MAX10
+-		BMC. This value is stored in flash and is mirrored
++Description:	Read only. Returns the number of sequential MAC
++		addresses assigned to the board managed by the Intel
++		MAX10 BMC. This value is stored in FLASH and is mirrored
+ 		in the MAX10 BMC register space.
+ 		Format: "%u".
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0099-fpga-sec-mgr-Remove-reference-to-security-directory.patch new/debian/patches/fpga-ofs/0099-fpga-sec-mgr-Remove-reference-to-security-directory.patch
--- org/debian/patches/fpga-ofs/0099-fpga-sec-mgr-Remove-reference-to-security-directory.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0099-fpga-sec-mgr-Remove-reference-to-security-directory.patch	2021-07-20 06:17:11.472844674 +0200
@@ -0,0 +1,50 @@
+From 6c6166eb864fc5fe87c1557b262c1d002a23fdd5 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 19 Mar 2021 12:02:18 -0700
+Subject: [PATCH 099/149] fpga: sec-mgr: Remove reference to security directory
+
+Update the documentation for the FPGA Security Manager class driver to
+remove the reference to the security subdirectory. The security
+subdirectory has been moved out of the class driver and into the device
+specific driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ Documentation/fpga/fpga-sec-mgr.rst | 14 ++++----------
+ 1 file changed, 4 insertions(+), 10 deletions(-)
+
+diff --git a/Documentation/fpga/fpga-sec-mgr.rst b/Documentation/fpga/fpga-sec-mgr.rst
+index 4a1d6519b1d3..9f74c29fe63d 100644
+--- a/Documentation/fpga/fpga-sec-mgr.rst
++++ b/Documentation/fpga/fpga-sec-mgr.rst
+@@ -21,7 +21,7 @@ with the firmware to initiate an update, pass in the necessary data,
+ and collect status on the update.
+ 
+ In addition to managing secure updates of the FPGA and BMC images,
+-the FPGA Security Manager update process may also used to
++the FPGA Security Manager update process may also be used to
+ program root entry hashes and cancellation keys for the FPGA static
+ region, the FPGA partial reconfiguration region, and the BMC.
+ 
+@@ -35,15 +35,9 @@ retrieving error information in the event of a failure.
+ Sysfs Attributes
+ ================
+ 
+-The API consists of two groups of sysfs attributes as described below.
+-
+-1. Files in the *security* sub-directory can be used to read security
+-   information including: Root Entry Hashes (REH), Cancelled Code
+-   Signing Keys (CSK), and the flash update count for FPGA images.
+-
+-2. Files in the *update* sub-directory can be used to instantiate and
+-   monitor a secure update.
+-
++The API includes a sysfs entry *name* to export the name of the parent
++driver. It also includes an *update* sub-directory that can be used to
++instantiate and monitor a secure update.
+ 
+ See `<../ABI/testing/sysfs-class-fpga-sec-mgr>`__ for a full
+ description of the sysfs attributes for the FPGA Security
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0100-Revert-fpga-dfl-afu-harden-port-enable-logic.patch new/debian/patches/fpga-ofs/0100-Revert-fpga-dfl-afu-harden-port-enable-logic.patch
--- org/debian/patches/fpga-ofs/0100-Revert-fpga-dfl-afu-harden-port-enable-logic.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0100-Revert-fpga-dfl-afu-harden-port-enable-logic.patch	2021-07-20 06:17:11.476844663 +0200
@@ -0,0 +1,125 @@
+From 4f18b420dddcec6c6a7a3558446960155ced74a6 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 18 Mar 2021 17:11:05 -0700
+Subject: [PATCH 100/149] Revert "fpga: dfl: afu: harden port enable logic"
+
+This reverts commit 24d4277b16e768f12909206c6e042ae582a2c1a3.
+Reverting in favor of the latest version of this patch.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl-afu-error.c |  2 +-
+ drivers/fpga/dfl-afu-main.c  | 30 ++++++++----------------------
+ drivers/fpga/dfl-afu.h       |  2 +-
+ 3 files changed, 10 insertions(+), 24 deletions(-)
+
+diff --git a/drivers/fpga/dfl-afu-error.c b/drivers/fpga/dfl-afu-error.c
+index 4820ca3a837c..e880c04ac856 100644
+--- a/drivers/fpga/dfl-afu-error.c
++++ b/drivers/fpga/dfl-afu-error.c
+@@ -102,7 +102,7 @@ static int afu_port_err_clear(struct device *dev, u64 err)
+ 	__afu_port_err_mask(fdata, false);
+ 
+ 	/* Enable the Port by clear the reset */
+-	ret = __afu_port_enable(fdata);
++	__afu_port_enable(fdata);
+ 
+ done:
+ 	mutex_unlock(&fdata->lock);
+diff --git a/drivers/fpga/dfl-afu-main.c b/drivers/fpga/dfl-afu-main.c
+index 4211cf3acb8a..884666500653 100644
+--- a/drivers/fpga/dfl-afu-main.c
++++ b/drivers/fpga/dfl-afu-main.c
+@@ -21,9 +21,6 @@
+ 
+ #include "dfl-afu.h"
+ 
+-#define RST_POLL_INVL 10 /* us */
+-#define RST_POLL_TIMEOUT 1000 /* us */
+-
+ /**
+  * __afu_port_enable - enable a port by clear reset
+  * @fdata: port feature dev data.
+@@ -35,7 +32,7 @@
+  *
+  * The caller needs to hold lock for protection.
+  */
+-int __afu_port_enable(struct dfl_feature_dev_data *fdata)
++void __afu_port_enable(struct dfl_feature_dev_data *fdata)
+ {
+ 	void __iomem *base;
+ 	u64 v;
+@@ -43,7 +40,7 @@ int __afu_port_enable(struct dfl_feature_dev_data *fdata)
+ 	WARN_ON(!fdata->disable_count);
+ 
+ 	if (--fdata->disable_count != 0)
+-		return 0;
++		return;
+ 
+ 	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+@@ -51,22 +48,11 @@ int __afu_port_enable(struct dfl_feature_dev_data *fdata)
+ 	v = readq(base + PORT_HDR_CTRL);
+ 	v &= ~PORT_CTRL_SFTRST;
+ 	writeq(v, base + PORT_HDR_CTRL);
+-
+-	/*
+-	 * HW clears the ack bit to indicate that the port is fully out
+-	 * of reset.
+-	 */
+-	if (readq_poll_timeout(base + PORT_HDR_CTRL, v,
+-			       !(v & PORT_CTRL_SFTRST_ACK),
+-			       RST_POLL_INVL, RST_POLL_TIMEOUT)) {
+-		dev_err(fdata->dfl_cdev->parent,
+-			"timeout, failure to enable device\n");
+-		return -ETIMEDOUT;
+-	}
+-
+-	return 0;
+ }
+ 
++#define RST_POLL_INVL 10 /* us */
++#define RST_POLL_TIMEOUT 1000 /* us */
++
+ /**
+  * __afu_port_disable - disable a port by hold reset
+  * @fdata: port feature dev data.
+@@ -124,7 +110,7 @@ static int __port_reset(struct dfl_feature_dev_data *fdata)
+ 
+ 	ret = __afu_port_disable(fdata);
+ 	if (!ret)
+-		ret = __afu_port_enable(fdata);
++		__afu_port_enable(fdata);
+ 
+ 	return ret;
+ }
+@@ -901,11 +887,11 @@ static int afu_dev_destroy(struct platform_device *pdev)
+ 
+ static int port_enable_set(struct dfl_feature_dev_data *fdata, bool enable)
+ {
+-	int ret;
++	int ret = 0;
+ 
+ 	mutex_lock(&fdata->lock);
+ 	if (enable)
+-		ret = __afu_port_enable(fdata);
++		__afu_port_enable(fdata);
+ 	else
+ 		ret = __afu_port_disable(fdata);
+ 	mutex_unlock(&fdata->lock);
+diff --git a/drivers/fpga/dfl-afu.h b/drivers/fpga/dfl-afu.h
+index 5a6f8e4fae71..48feffc233fa 100644
+--- a/drivers/fpga/dfl-afu.h
++++ b/drivers/fpga/dfl-afu.h
+@@ -83,7 +83,7 @@ struct dfl_afu {
+ };
+ 
+ /* hold fdata->lock when call __afu_port_enable/disable */
+-int __afu_port_enable(struct dfl_feature_dev_data *fdata);
++void __afu_port_enable(struct dfl_feature_dev_data *fdata);
+ int __afu_port_disable(struct dfl_feature_dev_data *fdata);
+ 
+ void afu_mmio_region_init(struct dfl_feature_dev_data *fdata);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0101-fpga-dfl-afu-harden-port-enable-logic.patch new/debian/patches/fpga-ofs/0101-fpga-dfl-afu-harden-port-enable-logic.patch
--- org/debian/patches/fpga-ofs/0101-fpga-dfl-afu-harden-port-enable-logic.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0101-fpga-dfl-afu-harden-port-enable-logic.patch	2021-07-20 06:17:11.476844663 +0200
@@ -0,0 +1,164 @@
+From 53ab5debc76d773da407fdc4ade0507b528633b8 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 23 Feb 2021 09:43:51 -0800
+Subject: [PATCH 101/149] fpga: dfl: afu: harden port enable logic
+
+Port enable is not complete until ACK = 0. Change
+__afu_port_enable() to guarantee that the enable process
+is complete by polling for ACK == 0.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+Reviewed-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Acked-by: Wu Hao <hao.wu@intel.com>
+---
+ drivers/fpga/dfl-afu-error.c | 10 ++++++----
+ drivers/fpga/dfl-afu-main.c  | 34 ++++++++++++++++++++++++----------
+ drivers/fpga/dfl-afu.h       |  2 +-
+ 3 files changed, 31 insertions(+), 15 deletions(-)
+
+diff --git a/drivers/fpga/dfl-afu-error.c b/drivers/fpga/dfl-afu-error.c
+index e880c04ac856..d2b702e2bc30 100644
+--- a/drivers/fpga/dfl-afu-error.c
++++ b/drivers/fpga/dfl-afu-error.c
+@@ -51,7 +51,7 @@ static int afu_port_err_clear(struct device *dev, u64 err)
+ {
+ 	struct dfl_feature_dev_data *fdata = to_dfl_feature_dev_data(dev);
+ 	void __iomem *base_err, *base_hdr;
+-	int ret = -EBUSY;
++	int enable_ret = 0, ret = -EBUSY;
+ 	u64 v;
+ 
+ 	base_err = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_ERROR);
+@@ -95,18 +95,20 @@ static int afu_port_err_clear(struct device *dev, u64 err)
+ 		v = readq(base_err + PORT_FIRST_ERROR);
+ 		writeq(v, base_err + PORT_FIRST_ERROR);
+ 	} else {
++		dev_warn(dev, "%s: received 0x%llx, expected 0x%llx\n",
++			 __func__, v, err);
+ 		ret = -EINVAL;
+ 	}
+ 
+ 	/* Clear mask */
+ 	__afu_port_err_mask(fdata, false);
+ 
+-	/* Enable the Port by clear the reset */
+-	__afu_port_enable(fdata);
++	/* Enable the Port by clearing the reset */
++	enable_ret = __afu_port_enable(fdata);
+ 
+ done:
+ 	mutex_unlock(&fdata->lock);
+-	return ret;
++	return enable_ret ? enable_ret : ret;
+ }
+ 
+ static ssize_t errors_show(struct device *dev, struct device_attribute *attr,
+diff --git a/drivers/fpga/dfl-afu-main.c b/drivers/fpga/dfl-afu-main.c
+index 884666500653..5a74ee285f95 100644
+--- a/drivers/fpga/dfl-afu-main.c
++++ b/drivers/fpga/dfl-afu-main.c
+@@ -21,6 +21,9 @@
+ 
+ #include "dfl-afu.h"
+ 
++#define RST_POLL_INVL 10 /* us */
++#define RST_POLL_TIMEOUT 1000 /* us */
++
+ /**
+  * __afu_port_enable - enable a port by clear reset
+  * @fdata: port feature dev data.
+@@ -32,7 +35,7 @@
+  *
+  * The caller needs to hold lock for protection.
+  */
+-void __afu_port_enable(struct dfl_feature_dev_data *fdata)
++int __afu_port_enable(struct dfl_feature_dev_data *fdata)
+ {
+ 	void __iomem *base;
+ 	u64 v;
+@@ -40,7 +43,7 @@ void __afu_port_enable(struct dfl_feature_dev_data *fdata)
+ 	WARN_ON(!fdata->disable_count);
+ 
+ 	if (--fdata->disable_count != 0)
+-		return;
++		return 0;
+ 
+ 	base = dfl_get_feature_ioaddr_by_id(fdata, PORT_FEATURE_ID_HEADER);
+ 
+@@ -48,10 +51,21 @@ void __afu_port_enable(struct dfl_feature_dev_data *fdata)
+ 	v = readq(base + PORT_HDR_CTRL);
+ 	v &= ~PORT_CTRL_SFTRST;
+ 	writeq(v, base + PORT_HDR_CTRL);
+-}
+ 
+-#define RST_POLL_INVL 10 /* us */
+-#define RST_POLL_TIMEOUT 1000 /* us */
++	/*
++	 * HW clears the ack bit to indicate that the port is fully out
++	 * of reset.
++	 */
++	if (readq_poll_timeout(base + PORT_HDR_CTRL, v,
++			       !(v & PORT_CTRL_SFTRST_ACK),
++			       RST_POLL_INVL, RST_POLL_TIMEOUT)) {
++		dev_err(fdata->dfl_cdev->parent,
++			"timeout, failure to enable device\n");
++		return -ETIMEDOUT;
++	}
++
++	return 0;
++}
+ 
+ /**
+  * __afu_port_disable - disable a port by hold reset
+@@ -85,7 +99,7 @@ int __afu_port_disable(struct dfl_feature_dev_data *fdata)
+ 			       v & PORT_CTRL_SFTRST_ACK,
+ 			       RST_POLL_INVL, RST_POLL_TIMEOUT)) {
+ 		dev_err(fdata->dfl_cdev->parent,
+-			"timeout, fail to reset device\n");
++			"timeout, failure to disable device\n");
+ 		return -ETIMEDOUT;
+ 	}
+ 
+@@ -110,9 +124,9 @@ static int __port_reset(struct dfl_feature_dev_data *fdata)
+ 
+ 	ret = __afu_port_disable(fdata);
+ 	if (!ret)
+-		__afu_port_enable(fdata);
++		return ret;
+ 
+-	return ret;
++	return __afu_port_enable(fdata);
+ }
+ 
+ static int port_reset(struct platform_device *pdev)
+@@ -887,11 +901,11 @@ static int afu_dev_destroy(struct platform_device *pdev)
+ 
+ static int port_enable_set(struct dfl_feature_dev_data *fdata, bool enable)
+ {
+-	int ret = 0;
++	int ret;
+ 
+ 	mutex_lock(&fdata->lock);
+ 	if (enable)
+-		__afu_port_enable(fdata);
++		ret = __afu_port_enable(fdata);
+ 	else
+ 		ret = __afu_port_disable(fdata);
+ 	mutex_unlock(&fdata->lock);
+diff --git a/drivers/fpga/dfl-afu.h b/drivers/fpga/dfl-afu.h
+index 48feffc233fa..5a6f8e4fae71 100644
+--- a/drivers/fpga/dfl-afu.h
++++ b/drivers/fpga/dfl-afu.h
+@@ -83,7 +83,7 @@ struct dfl_afu {
+ };
+ 
+ /* hold fdata->lock when call __afu_port_enable/disable */
+-void __afu_port_enable(struct dfl_feature_dev_data *fdata);
++int __afu_port_enable(struct dfl_feature_dev_data *fdata);
+ int __afu_port_disable(struct dfl_feature_dev_data *fdata);
+ 
+ void afu_mmio_region_init(struct dfl_feature_dev_data *fdata);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0102-Documentation-fpga-dfl-Fix-make-htmldocs.patch new/debian/patches/fpga-ofs/0102-Documentation-fpga-dfl-Fix-make-htmldocs.patch
--- org/debian/patches/fpga-ofs/0102-Documentation-fpga-dfl-Fix-make-htmldocs.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0102-Documentation-fpga-dfl-Fix-make-htmldocs.patch	2021-07-20 06:17:11.476844663 +0200
@@ -0,0 +1,53 @@
+From 95771b42fc613dd93ed4b07b664ae723d7ab0838 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Mon, 22 Mar 2021 12:37:32 -0700
+Subject: [PATCH 102/149] Documentation: fpga: dfl: Fix make htmldocs
+
+Fix up the dfl.rst file to avoid issues with the kernel "make htmldocs"
+makefile target.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ Documentation/fpga/dfl.rst | 5 ++++-
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+diff --git a/Documentation/fpga/dfl.rst b/Documentation/fpga/dfl.rst
+index db92696a5f52..f3a1223f2517 100644
+--- a/Documentation/fpga/dfl.rst
++++ b/Documentation/fpga/dfl.rst
+@@ -7,6 +7,7 @@ Authors:
+ - Enno Luebbers <enno.luebbers@intel.com>
+ - Xiao Guangrong <guangrong.xiao@linux.intel.com>
+ - Wu Hao <hao.wu@intel.com>
++- Xu Yilun <yilun.xu@intel.com>
+ 
+ The Device Feature List (DFL) FPGA framework (and drivers according to
+ this framework) hides the very details of low layer hardwares and provides
+@@ -502,7 +503,7 @@ FME Partial Reconfiguration Sub Feature driver (see drivers/fpga/dfl-fme-pr.c)
+ could be a reference.
+ 
+ Location of DFLs on a PCI Device
+-===========================
++================================
+ The original method for finding a DFL on a PCI device assumed the start of the
+ first DFL to offset 0 of bar 0.  If the first node of the DFL is an FME,
+ then further DFLs in the port(s) are specified in FME header registers.
+@@ -514,6 +515,7 @@ data begins with a 4 byte vendor specific register for the number of DFLs follow
+ Offset/BIR vendor specific registers for each DFL. Bits 2:0 of Offset/BIR register
+ indicates the BAR, and bits 31:3 form the 8 byte aligned offset where bits 2:0 are
+ zero.
++::
+ 
+         +----------------------------+
+         |31     Number of DFLS      0|
+@@ -529,6 +531,7 @@ Being able to specify more than one DFL per BAR has been considered, but it
+ was determined the use case did not provide value.  Specifying a single DFL
+ per BAR simplifies the implementation and allows for extra error checking.
+ 
++
+ Userspace driver support for DFL devices
+ ========================================
+ The purpose of an FPGA is to be reprogrammed with newly developed hardware
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0103-drivers-fpga-dfl-spi-altera-Fix-format-string.patch new/debian/patches/fpga-ofs/0103-drivers-fpga-dfl-spi-altera-Fix-format-string.patch
--- org/debian/patches/fpga-ofs/0103-drivers-fpga-dfl-spi-altera-Fix-format-string.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0103-drivers-fpga-dfl-spi-altera-Fix-format-string.patch	2021-07-20 06:17:11.476844663 +0200
@@ -0,0 +1,28 @@
+From 6a0fe60567db2ee03199af368a08e2ef2a813262 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Mon, 22 Mar 2021 12:40:16 -0700
+Subject: [PATCH 103/149] drivers: fpga: dfl-spi-altera: Fix format string
+
+Fix format string for dev_dbg call.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl-spi-altera.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/dfl-spi-altera.c b/drivers/fpga/dfl-spi-altera.c
+index 21223d7437a2..8ddfc5d5e2ba 100644
+--- a/drivers/fpga/dfl-spi-altera.c
++++ b/drivers/fpga/dfl-spi-altera.c
+@@ -141,7 +141,7 @@ static struct platform_device *create_cntrl(struct device *dev,
+ 	pdata.num_devices = 1;
+ 	pdata.devices = m10_info;
+ 
+-	dev_dbg(dev, "%s cs %hu bpm 0x%x mode 0x%hx\n", __func__,
++	dev_dbg(dev, "%s cs %u bpm 0x%x mode 0x%x\n", __func__,
+ 		pdata.num_chipselect, pdata.bits_per_word_mask,
+ 		pdata.mode_bits);
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0104-drivers-fpga-dfl-spi-altera-Fix-kconfig-documentatio.patch new/debian/patches/fpga-ofs/0104-drivers-fpga-dfl-spi-altera-Fix-kconfig-documentatio.patch
--- org/debian/patches/fpga-ofs/0104-drivers-fpga-dfl-spi-altera-Fix-kconfig-documentatio.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0104-drivers-fpga-dfl-spi-altera-Fix-kconfig-documentatio.patch	2021-07-20 06:17:11.476844663 +0200
@@ -0,0 +1,30 @@
+From cf861373c16903e6ed51fda4f15bb0dfd9f88a6d Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Mon, 22 Mar 2021 12:50:22 -0700
+Subject: [PATCH 104/149] drivers: fpga: dfl-spi-altera: Fix kconfig
+ documentation
+
+Remove unnecessary whitespace from the Kconfig documentation
+for the dfl-spi-altera driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/Kconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
+index d78f35dd9bc1..2adbc71db5c8 100644
+--- a/drivers/fpga/Kconfig
++++ b/drivers/fpga/Kconfig
+@@ -209,7 +209,7 @@ config FPGA_DFL_SPI_ALTERA
+ 	select REGMAP
+ 	help
+ 	  This is a DFL bus driver for the Altera SPI master controller.
+-          The SPI master is connected to a SPI slave to Avalon Master
++	  The SPI master is connected to a SPI slave to Avalon Master
+ 	  bridge in a Intel MAX BMC.
+ 
+ config FPGA_DFL_PCI
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0105-fpga-m10bmc-sec-Change-order-of-available_images.patch new/debian/patches/fpga-ofs/0105-fpga-m10bmc-sec-Change-order-of-available_images.patch
--- org/debian/patches/fpga-ofs/0105-fpga-m10bmc-sec-Change-order-of-available_images.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0105-fpga-m10bmc-sec-Change-order-of-available_images.patch	2021-07-20 06:17:11.476844663 +0200
@@ -0,0 +1,40 @@
+From 8210c3f66a0e503f65172f6489e1c8e40dc55e29 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Mon, 22 Mar 2021 12:45:36 -0700
+Subject: [PATCH 105/149] fpga: m10bmc-sec: Change order of available_images
+
+The sysfs available_images file returns the keywords in the order
+that they are listed in the n3000_image_load_hndlrs[] array. Change
+the order to be alphabetical.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index e1850af8e39c..b0df2e148aad 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -707,14 +707,14 @@ static int m10bmc_sec_retimer_eeprom_load(struct fpga_sec_mgr *smgr)
+ }
+ 
+ static struct image_load n3000_image_load_hndlrs[] = {
+-	{
+-		.name = "bmc_user",
+-		.load_image = m10bmc_sec_bmc_image_load_0,
+-	},
+ 	{
+ 		.name = "bmc_factory",
+ 		.load_image = m10bmc_sec_bmc_image_load_1,
+ 	},
++	{
++		.name = "bmc_user",
++		.load_image = m10bmc_sec_bmc_image_load_0,
++	},
+ 	{
+ 		.name = "retimer_fw",
+ 		.load_image = m10bmc_sec_retimer_eeprom_load,
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0106-net-ethernet-intel-Fix-kconfig-documentation-for-s10.patch new/debian/patches/fpga-ofs/0106-net-ethernet-intel-Fix-kconfig-documentation-for-s10.patch
--- org/debian/patches/fpga-ofs/0106-net-ethernet-intel-Fix-kconfig-documentation-for-s10.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0106-net-ethernet-intel-Fix-kconfig-documentation-for-s10.patch	2021-07-20 06:17:11.476844663 +0200
@@ -0,0 +1,36 @@
+From 0b15658c31b03bee04cc3fc7e271f48baa2a7c2c Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Mon, 22 Mar 2021 12:58:05 -0700
+Subject: [PATCH 106/149] net: ethernet: intel: Fix kconfig documentation for
+ s10hssi
+
+Remove unnecessary whitespace from s10hssi documentation.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/net/ethernet/intel/Kconfig | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/net/ethernet/intel/Kconfig b/drivers/net/ethernet/intel/Kconfig
+index fdebe11fcc77..a77563d8f489 100644
+--- a/drivers/net/ethernet/intel/Kconfig
++++ b/drivers/net/ethernet/intel/Kconfig
+@@ -350,10 +350,10 @@ config S10HSSI
+ 	  This driver provides control plane support for an Stratix 10
+ 	  High Speed Serial Interface.
+ 
+-          The Stratix 10 High Speed Serial Interface provides a data
+-          path between the FPGA and the external QSFP interfaces.  This
+-          data path does not involve packets transferred between host
+-          memory and the fpga.  As such a very limited set of networking
+-          functionality is provided.
++	  The Stratix 10 High Speed Serial Interface provides a data
++	  path between the FPGA and the external QSFP interfaces.  This
++	  data path does not involve packets transferred between host
++	  memory and the fpga.  As such a very limited set of networking
++	  functionality is provided.
+ 
+ endif # NET_VENDOR_INTEL
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0107-mfd-intel-m10-bmc-Use-sysfs_emit-for-sysfs-nodes.patch new/debian/patches/fpga-ofs/0107-mfd-intel-m10-bmc-Use-sysfs_emit-for-sysfs-nodes.patch
--- org/debian/patches/fpga-ofs/0107-mfd-intel-m10-bmc-Use-sysfs_emit-for-sysfs-nodes.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0107-mfd-intel-m10-bmc-Use-sysfs_emit-for-sysfs-nodes.patch	2021-07-20 06:17:11.480844652 +0200
@@ -0,0 +1,54 @@
+From 0634a8d06a33ab9f4982cc019e75086cf2863547 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Mon, 22 Mar 2021 12:55:26 -0700
+Subject: [PATCH 107/149] mfd: intel-m10-bmc: Use sysfs_emit for sysfs nodes
+
+The upstream kernel is moving away from sprintf() variants to the
+common use of sysfs_emit() for sysfs node output. Change the
+mac_address and mac_count sysfs nodes to be consistent with what
+was accepted upstream.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/mfd/intel-m10-bmc.c | 18 +++++++++---------
+ 1 file changed, 9 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index 17c2105b68ca..14b226e43fee 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -179,13 +179,13 @@ static ssize_t mac_address_show(struct device *dev,
+ 	if (ret)
+ 		return ret;
+ 
+-	return sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+-		       (u8)FIELD_GET(M10BMC_MAC_BYTE1, macaddr1),
+-		       (u8)FIELD_GET(M10BMC_MAC_BYTE2, macaddr1),
+-		       (u8)FIELD_GET(M10BMC_MAC_BYTE3, macaddr1),
+-		       (u8)FIELD_GET(M10BMC_MAC_BYTE4, macaddr1),
+-		       (u8)FIELD_GET(M10BMC_MAC_BYTE5, macaddr2),
+-		       (u8)FIELD_GET(M10BMC_MAC_BYTE6, macaddr2));
++	return sysfs_emit(buf, "%02x:%02x:%02x:%02x:%02x:%02x\n",
++			  (u8)FIELD_GET(M10BMC_MAC_BYTE1, macaddr1),
++			  (u8)FIELD_GET(M10BMC_MAC_BYTE2, macaddr1),
++			  (u8)FIELD_GET(M10BMC_MAC_BYTE3, macaddr1),
++			  (u8)FIELD_GET(M10BMC_MAC_BYTE4, macaddr1),
++			  (u8)FIELD_GET(M10BMC_MAC_BYTE5, macaddr2),
++			  (u8)FIELD_GET(M10BMC_MAC_BYTE6, macaddr2));
+ }
+ static DEVICE_ATTR_RO(mac_address);
+ 
+@@ -200,8 +200,8 @@ static ssize_t mac_count_show(struct device *dev,
+ 	if (ret)
+ 		return ret;
+ 
+-	return sprintf(buf, "%u\n",
+-		       (u8)FIELD_GET(M10BMC_MAC_COUNT, macaddr2));
++	return sysfs_emit(buf, "%u\n",
++			  (u8)FIELD_GET(M10BMC_MAC_COUNT, macaddr2));
+ }
+ static DEVICE_ATTR_RO(mac_count);
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0108-fpga-dfl-afu-fix-port-reset-if-condition.patch new/debian/patches/fpga-ofs/0108-fpga-dfl-afu-fix-port-reset-if-condition.patch
--- org/debian/patches/fpga-ofs/0108-fpga-dfl-afu-fix-port-reset-if-condition.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0108-fpga-dfl-afu-fix-port-reset-if-condition.patch	2021-07-20 06:17:11.480844652 +0200
@@ -0,0 +1,30 @@
+From c4ecad1dda37fadd7d2fc7a7a5b301a56e7f3092 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 23 Mar 2021 13:17:42 -0700
+Subject: [PATCH 108/149] fpga: dfl: afu: fix port reset if condition
+
+This is a fixup for the commit:
+
+"fpga: dfl: afu: harden port enable logic"
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl-afu-main.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/dfl-afu-main.c b/drivers/fpga/dfl-afu-main.c
+index 5a74ee285f95..d0b297ebc3d8 100644
+--- a/drivers/fpga/dfl-afu-main.c
++++ b/drivers/fpga/dfl-afu-main.c
+@@ -123,7 +123,7 @@ static int __port_reset(struct dfl_feature_dev_data *fdata)
+ 	int ret;
+ 
+ 	ret = __afu_port_disable(fdata);
+-	if (!ret)
++	if (ret)
+ 		return ret;
+ 
+ 	return __afu_port_enable(fdata);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0109-net-ethernet-s10hssi-fix-the-crash-in-the-ipv6-netwo.patch new/debian/patches/fpga-ofs/0109-net-ethernet-s10hssi-fix-the-crash-in-the-ipv6-netwo.patch
--- org/debian/patches/fpga-ofs/0109-net-ethernet-s10hssi-fix-the-crash-in-the-ipv6-netwo.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0109-net-ethernet-s10hssi-fix-the-crash-in-the-ipv6-netwo.patch	2021-07-20 06:17:11.480844652 +0200
@@ -0,0 +1,102 @@
+From cca5129f8d49720332bd1a00b226e4643285d07c Mon Sep 17 00:00:00 2001
+From: Chen Guanqiao <chenguanqiao@kuaishou.com>
+Date: Wed, 24 Mar 2021 10:19:09 +0800
+Subject: [PATCH 109/149] net: ethernet: s10hssi: fix the crash in the ipv6
+ network
+
+This patch simply fills ndo_start_xmit() in netdev and no other
+operations.
+
+In the ipv6 network, after the date is sent, the netdev ndo_start_xmit()
+hook will be called. But s10ssi does not fill the ndo_start_xmit() in
+netdev, so it will case a "NULL pointer" crash.
+
+In the ipv6 network, run the following command:
+
+$ ifconfig s10hssi0 up
+
+Will cause the machine to crash:
+
+[  961.346621] BUG: unable to handle kernel NULL pointer dereference at 0000000000000000
+[  961.346651] PGD 0 P4D 0
+[  961.346661] Oops: 0010 [#1] SMP NOPTI
+[  961.346673] CPU: 62 PID: 0 Comm: swapper/62 Kdump: loaded Tainted: G           OE    --------- -  -
+[  961.346702] Hardware name: Inspur SA5212M5/YZMB-00882-104, BIOS 4.1.8 05/21/2019
+[  961.346721] RIP: 0010:          (null)
+[  961.346734] Code: Bad RIP value.
+[  961.346745] RSP: 0018:ffff98ce7fb83bd0 EFLAGS: 00010286
+[  961.346760] RAX: 0000000000000000 RBX: ffff988e7fff6000 RCX: ffff98ce7fb83c4c
+[  961.346778] RDX: ffffffffc0479620 RSI: ffff988e7fff6000 RDI: ffff98ce7e3ce900
+[  961.346796] RBP: 00000000ee0f0000 R08: 0000000000000000 R09: 000000000000004c
+[  961.346815] R10: ffff988e7cd9e540 R11: 0000000000000000 R12: 0000000000000000
+[  961.346833] R13: ffff985d88f61000 R14: ffff988e6975ce00 R15: ffff98ce7e3ce900
+[  961.346851] FS:  0000000000000000(0000) GS:ffff98ce7fb80000(0000) knlGS:0000000000000000
+[  961.346871] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
+[  961.346887] CR2: ffffffffffffffd6 CR3: 0000000e8880a006 CR4: 00000000007606e0
+[  961.346905] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
+[  961.346924] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
+[  961.346943] PKRU: 55555554
+[  961.346953] Call Trace:
+[  961.346964]  <IRQ>
+[  961.346979]  ? dev_hard_start_xmit+0xa5/0x210
+[  961.346994]  ? __dev_queue_xmit+0x6c1/0x9e0
+[  961.347008]  ? __neigh_create+0x427/0x580
+[  961.347023]  ? ip6_finish_output2+0x1b9/0x5b0
+[  961.347039]  ? kmem_cache_alloc+0x18e/0x1c0
+[  961.347053]  ? kmem_cache_alloc_trace+0x3f/0x1d0
+[  961.347068]  ? ip6_output+0x68/0x110
+[  961.347083]  ? mld_sendpack+0x168/0x280
+[  961.347096]  ? add_grhead.isra.26+0x2e/0xa0
+[  961.347110]  ? mld_ifc_timer_expire+0x198/0x2d0
+[  961.347125]  ? mld_clear_delrec+0xf0/0xf0
+[  961.347142]  ? call_timer_fn+0x2b/0x130
+[  961.347154]  ? run_timer_softirq+0x3d1/0x410
+[  961.347168]  ? enqueue_hrtimer+0x38/0x90
+[  961.347182]  ? __hrtimer_run_queues+0x130/0x280
+[  961.347198]  ? __do_softirq+0xe3/0x30a
+[  961.347211]  ? ktime_get+0x36/0xa0
+[  961.347225]  ? irq_exit+0x100/0x110
+[  961.347237]  ? smp_apic_timer_interrupt+0x74/0x140
+[  961.347252]  ? apic_timer_interrupt+0xf/0x20
+[  961.347264]  </IRQ>
+[  961.347275]  ? mwait_idle+0x7d/0x160
+[  961.347764]  ? do_idle+0x1f1/0x280
+[  961.348207]  ? cpu_startup_entry+0x6f/0x80
+[  961.348649]  ? start_secondary+0x1a7/0x200
+[  961.349081]  ? secondary_startup_64+0xb7/0xc0
+
+Signed-off-by: Chen Guanqiao <chenguanqiao@kuaishou.com>
+---
+ drivers/net/ethernet/intel/s10hssi.c | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+diff --git a/drivers/net/ethernet/intel/s10hssi.c b/drivers/net/ethernet/intel/s10hssi.c
+index a3db9bb7101f..dd36114dec05 100644
+--- a/drivers/net/ethernet/intel/s10hssi.c
++++ b/drivers/net/ethernet/intel/s10hssi.c
+@@ -161,10 +161,22 @@ static int netdev_set_mac_address(struct net_device *ndev, void *p)
+ 	return 0;
+ }
+ 
++static netdev_tx_t s10hssi_dummy_netdev_xmit(struct sk_buff *skb,
++					     struct net_device *dev)
++{
++	if (!dev)
++		return -EINVAL;
++
++	kfree_skb(skb);
++	net_warn_ratelimited("%s(): Dropping skb.\n", __func__);
++	return NETDEV_TX_OK;
++}
++
+ static const struct net_device_ops netdev_ops = {
+ 	.ndo_change_mtu = netdev_change_mtu,
+ 	.ndo_set_features = netdev_set_features,
+ 	.ndo_set_mac_address = netdev_set_mac_address,
++	.ndo_start_xmit = s10hssi_dummy_netdev_xmit,
+ };
+ 
+ struct stat_info {
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0110-dfl-Remove-config-parameter-CONFIG_REGMAP_MMIO.patch new/debian/patches/fpga-ofs/0110-dfl-Remove-config-parameter-CONFIG_REGMAP_MMIO.patch
--- org/debian/patches/fpga-ofs/0110-dfl-Remove-config-parameter-CONFIG_REGMAP_MMIO.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0110-dfl-Remove-config-parameter-CONFIG_REGMAP_MMIO.patch	2021-07-20 06:17:11.480844652 +0200
@@ -0,0 +1,29 @@
+From 109a92ae217dbc92951796a030983f6ac14454a8 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Thu, 25 Mar 2021 08:43:37 -0700
+Subject: [PATCH 110/149] dfl: Remove config parameter CONFIG_REGMAP_MMIO
+
+CONFIG_REGMAP_MMIO is selected as needed and does not need to be
+explicitly turned on.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ configs/n3000_d5005_defconfig | 2 --
+ 1 file changed, 2 deletions(-)
+
+diff --git a/configs/n3000_d5005_defconfig b/configs/n3000_d5005_defconfig
+index dda5069bb46f..fee4a31e99a8 100644
+--- a/configs/n3000_d5005_defconfig
++++ b/configs/n3000_d5005_defconfig
+@@ -27,8 +27,6 @@ CONFIG_SPI_ALTERA=m
+ CONFIG_INTEL_S10_PHY=m
+ CONFIG_S10HSSI=m
+ 
+-CONFIG_REGMAP_MMIO=m
+-
+ CONFIG_MEMORY=y
+ CONFIG_FPGA_DFL_EMIF=m
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0111-pci-add-Silicom-Denmark-vendor-id.patch new/debian/patches/fpga-ofs/0111-pci-add-Silicom-Denmark-vendor-id.patch
--- org/debian/patches/fpga-ofs/0111-pci-add-Silicom-Denmark-vendor-id.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0111-pci-add-Silicom-Denmark-vendor-id.patch	2021-07-20 06:17:11.484844640 +0200
@@ -0,0 +1,31 @@
+From 9967f255173db230d240b58a49b0d71b924d0667 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Martin=20Hundeb=C3=B8ll?= <mhu@silicom.dk>
+Date: Mon, 1 Feb 2021 13:20:45 +0100
+Subject: [PATCH 111/149] pci: add Silicom Denmark vendor id
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Update pci_ids.h with the vendor id for Silicom Denmark.
+
+Signed-off-by: Martin Hundebøll <mhu@silicom.dk>
+---
+ include/linux/pci_ids.h | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
+index 1ab1e24bcbce..cd5e669c5da1 100644
+--- a/include/linux/pci_ids.h
++++ b/include/linux/pci_ids.h
+@@ -2587,6 +2587,8 @@
+ 
+ #define PCI_VENDOR_ID_REDHAT		0x1b36
+ 
++#define PCI_VENDOR_ID_SILICOM_DENMARK	0x1c2c
++
+ #define PCI_VENDOR_ID_AMAZON_ANNAPURNA_LABS	0x1c36
+ 
+ #define PCI_VENDOR_ID_CIRCUITCO		0x1cc8
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0112-fpga-dfl-pci-add-device-IDs-for-Silicom-N501x-PAC-ca.patch new/debian/patches/fpga-ofs/0112-fpga-dfl-pci-add-device-IDs-for-Silicom-N501x-PAC-ca.patch
--- org/debian/patches/fpga-ofs/0112-fpga-dfl-pci-add-device-IDs-for-Silicom-N501x-PAC-ca.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0112-fpga-dfl-pci-add-device-IDs-for-Silicom-N501x-PAC-ca.patch	2021-07-20 06:17:11.484844640 +0200
@@ -0,0 +1,43 @@
+From 7eea026670c49dcf2c5a6a8d90f497b425ae80e7 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Martin=20Hundeb=C3=B8ll?= <mhu@silicom.dk>
+Date: Mon, 1 Feb 2021 13:20:45 +0100
+Subject: [PATCH 112/149] fpga: dfl: pci: add device IDs for Silicom N501x PAC
+ cards
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds the approved PCI Express Device IDs for the
+Silicom PAC N5010 and N5011 cards.
+
+Signed-off-by: Martin Hundebøll <mhu@silicom.dk>
+---
+ drivers/fpga/dfl-pci.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/drivers/fpga/dfl-pci.c b/drivers/fpga/dfl-pci.c
+index fb279679479a..b758b39d2157 100644
+--- a/drivers/fpga/dfl-pci.c
++++ b/drivers/fpga/dfl-pci.c
+@@ -75,6 +75,9 @@ static void cci_pci_free_irq(struct pci_dev *pcidev)
+ #define PCIE_DEVICE_ID_INTEL_PAC_N3000		0x0B30
+ #define PCIE_DEVICE_ID_INTEL_PAC_D5005		0x0B2B
+ #define PCIE_DEVCIE_ID_INTEL_OFS		0xaf00
++#define PCIE_DEVICE_ID_SILICOM_PAC_N5010	0x1000
++#define PCIE_DEVICE_ID_SILICOM_PAC_N5011	0x1001
++
+ /* VF Device */
+ #define PCIE_DEVICE_ID_VF_INT_5_X		0xBCBF
+ #define PCIE_DEVICE_ID_VF_INT_6_X		0xBCC1
+@@ -92,6 +95,8 @@ static struct pci_device_id cci_pcie_id_tbl[] = {
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_D5005),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_D5005_VF),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVCIE_ID_INTEL_OFS),},
++	{PCI_DEVICE(PCI_VENDOR_ID_SILICOM_DENMARK, PCIE_DEVICE_ID_SILICOM_PAC_N5010),},
++	{PCI_DEVICE(PCI_VENDOR_ID_SILICOM_DENMARK, PCIE_DEVICE_ID_SILICOM_PAC_N5011),},
+ 	{0,}
+ };
+ MODULE_DEVICE_TABLE(pci, cci_pcie_id_tbl);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0113-fpga-dfl-spi-altera-support-n1050-feature-revision.patch new/debian/patches/fpga-ofs/0113-fpga-dfl-spi-altera-support-n1050-feature-revision.patch
--- org/debian/patches/fpga-ofs/0113-fpga-dfl-spi-altera-support-n1050-feature-revision.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0113-fpga-dfl-spi-altera-support-n1050-feature-revision.patch	2021-07-20 06:17:11.484844640 +0200
@@ -0,0 +1,70 @@
+From b1898ad47ef048c4d98cc96da98add0b8e11543f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Martin=20Hundeb=C3=B8ll?= <mhu@silicom.dk>
+Date: Mon, 1 Feb 2021 13:20:46 +0100
+Subject: [PATCH 113/149] fpga: dfl-spi-altera: support n1050 feature revision
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The Max10 BMC on the Silicom n5010 PAC card is slightly different than
+the existing BMC's, so use a dedicated feature revision detect it.
+
+Signed-off-by: Martin Hundebøll <mhu@silicom.dk>
+---
+ drivers/fpga/dfl-spi-altera.c | 19 ++++++++++++++++---
+ 1 file changed, 16 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/fpga/dfl-spi-altera.c b/drivers/fpga/dfl-spi-altera.c
+index 8ddfc5d5e2ba..50a3d0ef4771 100644
+--- a/drivers/fpga/dfl-spi-altera.c
++++ b/drivers/fpga/dfl-spi-altera.c
+@@ -22,6 +22,11 @@
+ #include <linux/spi/altera.h>
+ #include <linux/dfl.h>
+ 
++#include "dfl.h"
++
++#define FME_FEATURE_ID_MAX10_SPI	0xe
++#define FME_FEATURE_REV_MAX10_SPI_N5010	0x1
++
+ struct dfl_altera_spi {
+ 	void __iomem *base;
+ 	struct regmap *regmap;
+@@ -117,6 +122,13 @@ static struct spi_board_info m10_bmc_info = {
+ 	.chip_select = 0,
+ };
+ 
++static struct spi_board_info m10_n5010_bmc_info = {
++	.modalias = "m10-n5010",
++	.max_speed_hz = 12500000,
++	.bus_num = 0,
++	.chip_select = 0,
++};
++
+ static struct platform_device *create_cntrl(struct device *dev,
+ 					    void __iomem *base,
+ 					    struct spi_board_info *m10_info)
+@@ -180,7 +192,10 @@ static int dfl_spi_altera_probe(struct dfl_device *dfl_dev)
+ 	if (IS_ERR(aspi->regmap))
+ 		return PTR_ERR(aspi->regmap);
+ 
+-	aspi->altr_spi = create_cntrl(dev, aspi->base, &m10_bmc_info);
++	if (dfl_feature_revision(aspi->base) == FME_FEATURE_REV_MAX10_SPI_N5010)
++		aspi->altr_spi = create_cntrl(dev, aspi->base, &m10_n5010_bmc_info);
++	else
++		aspi->altr_spi = create_cntrl(dev, aspi->base, &m10_bmc_info);
+ 
+ 	if (IS_ERR(aspi->altr_spi)) {
+ 		dev_err(dev, "%s failed to create spi platform driver\n",
+@@ -198,8 +213,6 @@ static void dfl_spi_altera_remove(struct dfl_device *dfl_dev)
+ 	platform_device_unregister(aspi->altr_spi);
+ }
+ 
+-#define FME_FEATURE_ID_MAX10_SPI        0xe
+-
+ static const struct dfl_device_id dfl_spi_altera_ids[] = {
+ 	{ FME_ID, FME_FEATURE_ID_MAX10_SPI },
+ 	{ }
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0114-mfd-intel-m10-bmc-add-n5010-variant.patch new/debian/patches/fpga-ofs/0114-mfd-intel-m10-bmc-add-n5010-variant.patch
--- org/debian/patches/fpga-ofs/0114-mfd-intel-m10-bmc-add-n5010-variant.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0114-mfd-intel-m10-bmc-add-n5010-variant.patch	2021-07-20 06:17:11.484844640 +0200
@@ -0,0 +1,82 @@
+From c319f5839b90e58ea7501e818225ad322ecbdaca Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Martin=20Hundeb=C3=B8ll?= <mhu@silicom.dk>
+Date: Mon, 1 Feb 2021 13:20:46 +0100
+Subject: [PATCH 114/149] mfd: intel-m10-bmc: add n5010 variant
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The m10-bmc is used on the Silicom N5010 PAC too, so add it to list of
+m10bmc types.
+
+Signed-off-by: Martin Hundebøll <mhu@silicom.dk>
+---
+ drivers/mfd/intel-m10-bmc.c       | 14 ++++++++++++++
+ include/linux/mfd/intel-m10-bmc.h |  5 ++++-
+ 2 files changed, 18 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index 14b226e43fee..4ec321151e64 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -32,6 +32,12 @@ static const struct regmap_range n3000_fw_handshake_regs[] = {
+ 	regmap_reg_range(M10BMC_N3000_TELEM_START, M10BMC_N3000_TELEM_END),
+ };
+ 
++static struct mfd_cell m10bmc_n5010_bmc_subdevs[] = {};
++
++static const struct regmap_range n5010_fw_handshake_regs[] = {
++	regmap_reg_range(M10BMC_N5010_TELEM_START, M10BMC_N5010_TELEM_END),
++};
++
+ int m10bmc_fw_state_enter(struct intel_m10bmc *m10bmc,
+ 			  enum m10bmc_fw_state new_state)
+ {
+@@ -286,6 +292,13 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ 		ddata->handshake_sys_reg_nranges =
+ 			ARRAY_SIZE(d5005_fw_handshake_regs);
+ 		break;
++	case M10_N5010:
++		cells = m10bmc_n5010_bmc_subdevs;
++		n_cell = ARRAY_SIZE(m10bmc_n5010_bmc_subdevs);
++		ddata->handshake_sys_reg_ranges = n5010_fw_handshake_regs;
++		ddata->handshake_sys_reg_nranges =
++			ARRAY_SIZE(n5010_fw_handshake_regs);
++		break;
+ 	default:
+ 		return -ENODEV;
+ 	}
+@@ -301,6 +314,7 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ static const struct spi_device_id m10bmc_spi_id[] = {
+ 	{ "m10-n3000", M10_N3000 },
+ 	{ "m10-d5005", M10_D5005 },
++	{ "m10-n5010", M10_N5010 },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(spi, m10bmc_spi_id);
+diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
+index 478b70df0d84..f3cd31b19f5c 100644
+--- a/include/linux/mfd/intel-m10-bmc.h
++++ b/include/linux/mfd/intel-m10-bmc.h
+@@ -13,7 +13,8 @@
+ /* Supported MAX10 BMC types */
+ enum m10bmc_type {
+ 	M10_N3000,
+-	M10_D5005
++	M10_D5005,
++	M10_N5010,
+ };
+ 
+ #define M10BMC_LEGACY_BUILD_VER		0x300468
+@@ -79,6 +80,8 @@ enum m10bmc_type {
+ #define M10BMC_N3000_TELEM_END		0x250
+ #define M10BMC_D5005_TELEM_START	0x100
+ #define M10BMC_D5005_TELEM_END		0x300
++#define M10BMC_N5010_TELEM_START	0x100
++#define M10BMC_N5010_TELEM_END		0x250
+ 
+ /* Secure update doorbell register, in system register region */
+ #define M10BMC_DOORBELL			0x400
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0115-hwmon-intel-m10-bmc-hwmon-add-n5010-sensors.patch new/debian/patches/fpga-ofs/0115-hwmon-intel-m10-bmc-hwmon-add-n5010-sensors.patch
--- org/debian/patches/fpga-ofs/0115-hwmon-intel-m10-bmc-hwmon-add-n5010-sensors.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0115-hwmon-intel-m10-bmc-hwmon-add-n5010-sensors.patch	2021-07-20 06:17:11.484844640 +0200
@@ -0,0 +1,169 @@
+From 4488dd399d53362d3e37364f46032dc580910f40 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Martin=20Hundeb=C3=B8ll?= <mhu@silicom.dk>
+Date: Mon, 1 Feb 2021 13:20:46 +0100
+Subject: [PATCH 115/149] hwmon: intel-m10-bmc-hwmon: add n5010 sensors
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add the list of sensors supported by the Silicom n5010 PAC, and enable
+the drivers as a subtype of the intel-m10-bmc multi-function driver.
+
+Signed-off-by: Martin Hundebøll <mhu@silicom.dk>
+---
+ drivers/hwmon/intel-m10-bmc-hwmon.c | 116 ++++++++++++++++++++++++++++
+ drivers/mfd/intel-m10-bmc.c         |   4 +-
+ 2 files changed, 119 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/hwmon/intel-m10-bmc-hwmon.c b/drivers/hwmon/intel-m10-bmc-hwmon.c
+index bd7ed2ed3a1e..7a08e4c44a4b 100644
+--- a/drivers/hwmon/intel-m10-bmc-hwmon.c
++++ b/drivers/hwmon/intel-m10-bmc-hwmon.c
+@@ -228,6 +228,118 @@ static const struct m10bmc_hwmon_board_data d5005bmc_hwmon_bdata = {
+ 	.hinfo = d5005bmc_hinfo,
+ };
+ 
++static const struct m10bmc_sdata n5010bmc_temp_tbl[] = {
++	{ 0x100, 0x0, 0x104, 0x0, 0x0, 1000, "Board Local Temperature" },
++	{ 0x108, 0x0, 0x10c, 0x0, 0x0, 1000, "FPGA 1 Temperature" },
++	{ 0x110, 0x0, 0x114, 0x0, 0x0, 1000, "FPGA 2 Temperature" },
++	{ 0x118, 0x0, 0x0, 0x0, 0x0, 1000, "Card Top Temperature" },
++	{ 0x11c, 0x0, 0x0, 0x0, 0x0, 1000, "Card Bottom Temperature" },
++	{ 0x128, 0x0, 0x0, 0x0, 0x0, 1000, "FPGA 1.2V Temperature" },
++	{ 0x134, 0x0, 0x0, 0x0, 0x0, 1000, "FPGA 5V Temperature" },
++	{ 0x140, 0x0, 0x0, 0x0, 0x0, 1000, "FPGA 0.9V Temperature" },
++	{ 0x14c, 0x0, 0x0, 0x0, 0x0, 1000, "FPGA 0.85V Temperature" },
++	{ 0x158, 0x0, 0x0, 0x0, 0x0, 1000, "AUX 12V Temperature" },
++	{ 0x164, 0x0, 0x0, 0x0, 0x0, 1000, "Backplane 12V Temperature" },
++	{ 0x1a8, 0x0, 0x0, 0x0, 0x0, 1000, "QSFP28-1 Temperature" },
++	{ 0x1ac, 0x0, 0x0, 0x0, 0x0, 1000, "QSFP28-2 Temperature" },
++	{ 0x1b0, 0x0, 0x0, 0x0, 0x0, 1000, "QSFP28-3 Temperature" },
++	{ 0x1b4, 0x0, 0x0, 0x0, 0x0, 1000, "QSFP28-4 Temperature" },
++	{ 0x1b8, 0x0, 0x0, 0x0, 0x0, 1000, "CVL1 Internal Temperature" },
++	{ 0x1bc, 0x0, 0x0, 0x0, 0x0, 1000, "CVL2 Internal Temperature" },
++};
++
++static const struct m10bmc_sdata n5010bmc_in_tbl[] = {
++	{ 0x120, 0x0, 0x0, 0x0, 0x0, 1, "FPGA 1.2V Voltage" },
++	{ 0x12c, 0x0, 0x0, 0x0, 0x0, 1, "FPGA 5V Voltage" },
++	{ 0x138, 0x0, 0x0, 0x0, 0x0, 1, "FPGA 0.9V Voltage" },
++	{ 0x144, 0x0, 0x0, 0x0, 0x0, 1, "FPGA 0.85V Voltage" },
++	{ 0x150, 0x0, 0x0, 0x0, 0x0, 1, "AUX 12V Voltage" },
++	{ 0x15c, 0x0, 0x0, 0x0, 0x0, 1, "Backplane 12V Voltage" },
++	{ 0x16c, 0x0, 0x0, 0x0, 0x0, 1, "DDR4 1.2V Voltage" },
++	{ 0x17c, 0x0, 0x0, 0x0, 0x0, 1, "FPGA 1.8V Voltage" },
++	{ 0x184, 0x0, 0x0, 0x0, 0x0, 1, "QDR 1.3V Voltage" },
++	{ 0x18c, 0x0, 0x0, 0x0, 0x0, 1, "CVL1 0.8V Voltage" },
++	{ 0x194, 0x0, 0x0, 0x0, 0x0, 1, "CVL1 1.05V Voltage" },
++	{ 0x19c, 0x0, 0x0, 0x0, 0x0, 1, "CVL2 1.05V Voltage" },
++	{ 0x1a4, 0x0, 0x0, 0x0, 0x0, 1, "CVL2 0.8V Voltage" },
++};
++
++static const struct m10bmc_sdata n5010bmc_curr_tbl[] = {
++	{ 0x124, 0x0, 0x0, 0x0, 0x0, 1, "FPGA 1.2V Current" },
++	{ 0x130, 0x0, 0x0, 0x0, 0x0, 1, "FPGA 5V Current" },
++	{ 0x13c, 0x0, 0x0, 0x0, 0x0, 1, "FPGA 0.9V Current" },
++	{ 0x148, 0x0, 0x0, 0x0, 0x0, 1, "FPGA 0.85V Current" },
++	{ 0x154, 0x0, 0x0, 0x0, 0x0, 1, "AUX 12V Current" },
++	{ 0x160, 0x0, 0x0, 0x0, 0x0, 1, "Backplane 12V Current" },
++	{ 0x168, 0x0, 0x0, 0x0, 0x0, 1, "DDR4 1.2V Current" },
++	{ 0x178, 0x0, 0x0, 0x0, 0x0, 1, "FPGA 1.8V Current" },
++	{ 0x180, 0x0, 0x0, 0x0, 0x0, 1, "QDR 1.3V Current" },
++	{ 0x188, 0x0, 0x0, 0x0, 0x0, 1, "CVL1 0.8V Current" },
++	{ 0x190, 0x0, 0x0, 0x0, 0x0, 1, "CVL1 1.05V Current" },
++	{ 0x198, 0x0, 0x0, 0x0, 0x0, 1, "CVL2 1.05V Current" },
++	{ 0x1a0, 0x0, 0x0, 0x0, 0x0, 1, "CVL2 0.8V Current" },
++};
++
++static const struct hwmon_channel_info *n5010bmc_hinfo[] = {
++	HWMON_CHANNEL_INFO(temp,
++			   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_CRIT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL,
++			   HWMON_T_INPUT | HWMON_T_LABEL),
++	HWMON_CHANNEL_INFO(in,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL,
++			   HWMON_I_INPUT | HWMON_I_LABEL),
++	HWMON_CHANNEL_INFO(curr,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL,
++			   HWMON_C_INPUT | HWMON_C_LABEL),
++	NULL
++};
++
++static const struct m10bmc_hwmon_board_data n5010bmc_hwmon_bdata = {
++	.tables = {
++		[hwmon_temp] = n5010bmc_temp_tbl,
++		[hwmon_in] = n5010bmc_in_tbl,
++		[hwmon_curr] = n5010bmc_curr_tbl,
++	},
++
++	.hinfo = n5010bmc_hinfo,
++};
++
+ static umode_t
+ m10bmc_hwmon_is_visible(const void *data, enum hwmon_sensor_types type,
+ 			u32 attr, int channel)
+@@ -438,6 +550,10 @@ static const struct platform_device_id intel_m10bmc_hwmon_ids[] = {
+ 		.name = "d5005bmc-hwmon",
+ 		.driver_data = (unsigned long)&d5005bmc_hwmon_bdata,
+ 	},
++	{
++		.name = "n5010bmc-hwmon",
++		.driver_data = (unsigned long)&n5010bmc_hwmon_bdata,
++	},
+ 	{ }
+ };
+ 
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index 4ec321151e64..040aaeb979be 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -32,7 +32,9 @@ static const struct regmap_range n3000_fw_handshake_regs[] = {
+ 	regmap_reg_range(M10BMC_N3000_TELEM_START, M10BMC_N3000_TELEM_END),
+ };
+ 
+-static struct mfd_cell m10bmc_n5010_bmc_subdevs[] = {};
++static struct mfd_cell m10bmc_n5010_bmc_subdevs[] = {
++	{ .name = "n5010bmc-hwmon" },
++};
+ 
+ static const struct regmap_range n5010_fw_handshake_regs[] = {
+ 	regmap_reg_range(M10BMC_N5010_TELEM_START, M10BMC_N5010_TELEM_END),
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0116-fpga-intel-m10-bmc-secure-add-n5010-device-id.patch new/debian/patches/fpga-ofs/0116-fpga-intel-m10-bmc-secure-add-n5010-device-id.patch
--- org/debian/patches/fpga-ofs/0116-fpga-intel-m10-bmc-secure-add-n5010-device-id.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0116-fpga-intel-m10-bmc-secure-add-n5010-device-id.patch	2021-07-20 06:17:11.484844640 +0200
@@ -0,0 +1,48 @@
+From 81e68a4f313bfabb080d9eaf954f35387cb6b963 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Martin=20Hundeb=C3=B8ll?= <mhu@silicom.dk>
+Date: Mon, 1 Feb 2021 13:20:46 +0100
+Subject: [PATCH 116/149] fpga: intel-m10-bmc-secure: add n5010 device id
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The Silicom n5010 PAC features the max10 bmc secure funtionality, so add
+it to the list of device id's, and enable it in the intel-m10-bmc
+multi-function driver.
+
+Signed-off-by: Martin Hundebøll <mhu@silicom.dk>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 4 ++++
+ drivers/mfd/intel-m10-bmc.c         | 1 +
+ 2 files changed, 5 insertions(+)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index b0df2e148aad..5b4dd7288211 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -796,6 +796,10 @@ static const struct platform_device_id intel_m10bmc_secure_ids[] = {
+ 		.name = "d5005bmc-secure",
+ 		.driver_data = (unsigned long)M10_D5005,
+ 	},
++	{
++		.name = "n5010bmc-secure",
++		.driver_data = (unsigned long)M10_N5010,
++	},
+ 	{ }
+ };
+ 
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index 040aaeb979be..e103ee11ced9 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -34,6 +34,7 @@ static const struct regmap_range n3000_fw_handshake_regs[] = {
+ 
+ static struct mfd_cell m10bmc_n5010_bmc_subdevs[] = {
+ 	{ .name = "n5010bmc-hwmon" },
++	{ .name = "n5010bmc-secure" },
+ };
+ 
+ static const struct regmap_range n5010_fw_handshake_regs[] = {
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0117-net-ethernet-silicom-add-n5010-phy-driver.patch new/debian/patches/fpga-ofs/0117-net-ethernet-silicom-add-n5010-phy-driver.patch
--- org/debian/patches/fpga-ofs/0117-net-ethernet-silicom-add-n5010-phy-driver.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0117-net-ethernet-silicom-add-n5010-phy-driver.patch	2021-07-20 06:17:11.496844606 +0200
@@ -0,0 +1,392 @@
+From 120bf7a2f6eec3933136f021d60003357dca462f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Martin=20Hundeb=C3=B8ll?= <mhu@silicom.dk>
+Date: Mon, 1 Feb 2021 13:20:47 +0100
+Subject: [PATCH 117/149] net: ethernet: silicom: add n5010-phy driver
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The n5010 PAC uses its board management controller to some aspects of
+the line-side handling. Add a driver to setup a fixed link phy for the
+n5010-hssi network driver.
+
+Signed-off-by: Martin Hundebøll <mhu@silicom.dk>
+---
+ MAINTAINERS                              |   6 +
+ drivers/mfd/intel-m10-bmc.c              |   1 +
+ drivers/net/ethernet/Kconfig             |   1 +
+ drivers/net/ethernet/Makefile            |   1 +
+ drivers/net/ethernet/silicom/Kconfig     |  27 +++
+ drivers/net/ethernet/silicom/Makefile    |   6 +
+ drivers/net/ethernet/silicom/n5010-phy.c | 235 +++++++++++++++++++++++
+ drivers/net/ethernet/silicom/n5010-phy.h |  16 ++
+ 8 files changed, 293 insertions(+)
+ create mode 100644 drivers/net/ethernet/silicom/Kconfig
+ create mode 100644 drivers/net/ethernet/silicom/Makefile
+ create mode 100644 drivers/net/ethernet/silicom/n5010-phy.c
+ create mode 100644 drivers/net/ethernet/silicom/n5010-phy.h
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 3ca831430da6..276821992ff4 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -15992,6 +15992,12 @@ S:	Maintained
+ F:	drivers/input/touchscreen/silead.c
+ F:	drivers/platform/x86/touchscreen_dmi.c
+ 
++SILICOM PAC N5010 DRIVER
++M:	Esa Leskinen <ele@silicom.dk>
++L:	netdev@vger.kernel.org
++S:	Maintained
++F:	drivers/net/ethernet/silicom/n5010-phy.c
++
+ SILICON LABS WIRELESS DRIVERS (for WFxxx series)
+ M:	Jérôme Pouiller <jerome.pouiller@silabs.com>
+ S:	Supported
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index e103ee11ced9..f5817cdc79e0 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -35,6 +35,7 @@ static const struct regmap_range n3000_fw_handshake_regs[] = {
+ static struct mfd_cell m10bmc_n5010_bmc_subdevs[] = {
+ 	{ .name = "n5010bmc-hwmon" },
+ 	{ .name = "n5010bmc-secure" },
++	{ .name = "n5010bmc-phy" },
+ };
+ 
+ static const struct regmap_range n5010_fw_handshake_regs[] = {
+diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
+index de50e8b9e656..e8204ff04500 100644
+--- a/drivers/net/ethernet/Kconfig
++++ b/drivers/net/ethernet/Kconfig
+@@ -167,6 +167,7 @@ source "drivers/net/ethernet/seeq/Kconfig"
+ source "drivers/net/ethernet/sfc/Kconfig"
+ source "drivers/net/ethernet/sgi/Kconfig"
+ source "drivers/net/ethernet/silan/Kconfig"
++source "drivers/net/ethernet/silicom/Kconfig"
+ source "drivers/net/ethernet/sis/Kconfig"
+ source "drivers/net/ethernet/smsc/Kconfig"
+ source "drivers/net/ethernet/socionext/Kconfig"
+diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
+index f8f38dcb5f8a..d6f889f89dbe 100644
+--- a/drivers/net/ethernet/Makefile
++++ b/drivers/net/ethernet/Makefile
+@@ -78,6 +78,7 @@ obj-$(CONFIG_NET_VENDOR_ROCKER) += rocker/
+ obj-$(CONFIG_NET_VENDOR_SAMSUNG) += samsung/
+ obj-$(CONFIG_NET_VENDOR_SEEQ) += seeq/
+ obj-$(CONFIG_NET_VENDOR_SILAN) += silan/
++obj-$(CONFIG_NET_VENDOR_SILICOM) += silicom/
+ obj-$(CONFIG_NET_VENDOR_SIS) += sis/
+ obj-$(CONFIG_NET_VENDOR_SOLARFLARE) += sfc/
+ obj-$(CONFIG_NET_VENDOR_SGI) += sgi/
+diff --git a/drivers/net/ethernet/silicom/Kconfig b/drivers/net/ethernet/silicom/Kconfig
+new file mode 100644
+index 000000000000..b109c5079656
+--- /dev/null
++++ b/drivers/net/ethernet/silicom/Kconfig
+@@ -0,0 +1,27 @@
++# SPDX-License-Identifier: GPL-2.0-only
++#
++# Silicom network device configuration
++#
++
++config NET_VENDOR_SILICOM
++	bool "Silicom devices"
++	default y
++	help
++	  If you have a network (Ethernet) card belonging to this class, say Y.
++
++	  Note that the answer to this question doesn't directly affect the
++	  kernel: saying N will just cause the configurator to skip all
++	  the questions about Silicom cards. If you say Y, you will be asked for
++	  your specific card in the following questions.
++
++if NET_VENDOR_SILICOM
++
++config N5010_PHY
++	tristate "Fixed Phy Driver for Silicom PAC N5010"
++	depends on MFD_INTEL_M10_BMC && FIXED_PHY
++	help
++	  The n5010 card consists of a primary FPGA running the network controller,
++	  and a side-fpga running the board management controller (bmc). This driver
++	  reads status bits and controls link LEDs via the bmc.
++
++endif # NET_VENDOR_SILICOM
+diff --git a/drivers/net/ethernet/silicom/Makefile b/drivers/net/ethernet/silicom/Makefile
+new file mode 100644
+index 000000000000..c51cd4b4c517
+--- /dev/null
++++ b/drivers/net/ethernet/silicom/Makefile
+@@ -0,0 +1,6 @@
++# SPDX-License-Identifier: GPL-2.0
++#
++# Makefile for the Silicom network device drivers.
++#
++
++obj-$(CONFIG_N5010_PHY) += n5010-phy.o
+diff --git a/drivers/net/ethernet/silicom/n5010-phy.c b/drivers/net/ethernet/silicom/n5010-phy.c
+new file mode 100644
+index 000000000000..f094749b3a01
+--- /dev/null
++++ b/drivers/net/ethernet/silicom/n5010-phy.c
+@@ -0,0 +1,235 @@
++// SPDX-License-Identifier: GPL-2.0
++/* Intel Max10 BMC Lightning Creek phy Driver
++ *
++ * Copyright (C) 2020 Silicom Denmark A/S. All rights reserved.
++ */
++#include <linux/bits.h>
++#include <linux/device.h>
++#include <linux/mfd/intel-m10-bmc.h>
++#include <linux/mod_devicetable.h>
++#include <linux/module.h>
++#include <linux/netdevice.h>
++#include <linux/phy.h>
++#include <linux/phy_fixed.h>
++#include <linux/platform_device.h>
++
++#include "n5010-phy.h"
++
++#define N5010_PHY_CSR_0		0x40c
++#define N5010_PHY_CSR_1		0x410
++
++#define N5010_PHY_ABSENT_0	BIT(7)
++#define N5010_PHY_ABSENT_1	BIT(23)
++
++#define N5010_PHY_LED_0		GENMASK(5, 3)
++#define N5010_PHY_LED_1		GENMASK(21, 19)
++
++struct n5010_phy {
++	struct intel_m10bmc *m10bmc;
++};
++
++struct n5010_port {
++	u64 num;
++	bool sfp_in;
++	struct n5010_phy *priv;
++	struct phy_device *phy;
++	bool (*get_link)(struct net_device *netdev);
++};
++
++static struct fixed_phy_status n5010_phy_status = {
++	.link = 0,
++	.speed = 1000,
++	.duplex = 1,
++};
++
++static int n5010_phy_sfp_status(struct n5010_port *port)
++{
++	unsigned int offset, bit, val;
++	int ret;
++
++	switch (port->num) {
++	case 0:
++		offset = N5010_PHY_CSR_1;
++		bit = N5010_PHY_ABSENT_0;
++		break;
++	case 1:
++		offset = N5010_PHY_CSR_1;
++		bit = N5010_PHY_ABSENT_1;
++		break;
++	case 2:
++		offset = N5010_PHY_CSR_0;
++		bit = N5010_PHY_ABSENT_0;
++		break;
++	case 3:
++		offset = N5010_PHY_CSR_0;
++		bit = N5010_PHY_ABSENT_1;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	ret = m10bmc_sys_read(port->priv->m10bmc, offset, &val);
++	if (ret)
++		return ret;
++
++	port->sfp_in = !(val & bit);
++
++	return 0;
++}
++
++static int n5010_phy_set_led(struct n5010_port *port, bool link)
++{
++	unsigned int offset, mask, val;
++
++	switch (port->num) {
++	case 0:
++		offset = N5010_PHY_CSR_1;
++		mask = N5010_PHY_LED_0;
++		break;
++	case 1:
++		offset = N5010_PHY_CSR_1;
++		mask = N5010_PHY_LED_1;
++		break;
++	case 2:
++		offset = N5010_PHY_CSR_0;
++		mask = N5010_PHY_LED_0;
++		break;
++	case 3:
++		offset = N5010_PHY_CSR_0;
++		mask = N5010_PHY_LED_1;
++		break;
++	default:
++		return -EINVAL;
++	}
++
++	val = link ? mask : 0;
++
++	return m10bmc_sys_update_bits(port->priv->m10bmc, offset, mask, val);
++}
++
++static void n5010_phy_adjust_link(struct net_device *netdev)
++{
++	struct n5010_port *port = netdev->phydev->priv;
++	bool link = netdev->phydev->link;
++	int err;
++
++	netdev_info(netdev, "link: %i\n", link);
++
++	err = n5010_phy_set_led(port, link);
++	if (err)
++		netdev_info(netdev, "failed to set led: %i\n", err);
++}
++
++static int n5010_phy_update_link(struct net_device *netdev,
++				 struct fixed_phy_status *status)
++{
++	struct n5010_port *port = netdev->phydev->priv;
++	bool sfp_in = port->sfp_in;
++
++	n5010_phy_sfp_status(port);
++	status->link = port->get_link(netdev);
++
++	if (sfp_in != port->sfp_in)
++		netdev_info(netdev, "sfp: %s\n", port->sfp_in ? "in" : "out");
++
++	return 0;
++}
++
++int n5010_phy_module_info(struct net_device *netdev)
++{
++	struct n5010_port *port = netdev->phydev->priv;
++
++	return port->sfp_in ? -ENODATA : -ENODEV;
++}
++EXPORT_SYMBOL(n5010_phy_module_info);
++
++int n5010_phy_attach(struct device *dev, struct net_device *netdev,
++		     bool (*get_link)(struct net_device *), u64 port_num)
++{
++	struct n5010_phy *priv = dev_get_drvdata(dev);
++	struct phy_device *phy;
++	struct n5010_port *port;
++	int ret;
++
++	phy = fixed_phy_register(PHY_POLL, &n5010_phy_status, NULL);
++	if (IS_ERR(phy))
++		return PTR_ERR(phy);
++
++	port = devm_kzalloc(&phy->mdio.dev, sizeof(*port), GFP_KERNEL);
++	if (!port)
++		return -ENOMEM;
++
++	port->num = port_num;
++	port->priv = priv;
++	port->phy = phy;
++	port->get_link = get_link;
++
++	phy->priv = port;
++
++	ret = phy_connect_direct(netdev, phy, &n5010_phy_adjust_link,
++				 PHY_INTERFACE_MODE_NA);
++	if (ret)
++		goto err_deregister;
++
++	fixed_phy_set_link_update(phy, n5010_phy_update_link);
++	fixed_phy_change_carrier(netdev, false);
++	n5010_phy_sfp_status(port);
++
++	netdev_info(netdev, "sfp: %s\n", port->sfp_in ? "in" : "out");
++
++	return 0;
++
++err_deregister:
++	fixed_phy_unregister(phy);
++
++	return ret;
++}
++EXPORT_SYMBOL(n5010_phy_attach);
++
++int n5010_phy_detach(struct net_device *netdev)
++{
++	struct phy_device *phy = netdev->phydev;
++
++	phy_detach(phy);
++	fixed_phy_unregister(phy);
++	phy_device_free(phy);
++
++	return 0;
++}
++EXPORT_SYMBOL(n5010_phy_detach);
++
++static int n5010_phy_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct n5010_phy *priv;
++
++	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
++	if (!priv)
++		return -ENOMEM;
++
++	dev_set_drvdata(dev, priv);
++	priv->m10bmc = dev_get_drvdata(dev->parent);
++
++	return 0;
++}
++
++static const struct platform_device_id n5010_phy_ids[] = {
++	{
++		.name = "n5010bmc-phy",
++	},
++	{ }
++};
++
++static struct platform_driver n5010_phy_driver = {
++	.probe = n5010_phy_probe,
++	.driver = {
++		.name = "n5010bmc-phy",
++	},
++	.id_table = n5010_phy_ids,
++};
++module_platform_driver(n5010_phy_driver);
++
++MODULE_DEVICE_TABLE(platform, n5010_phy_ids);
++MODULE_AUTHOR("Intel Corporation");
++MODULE_DESCRIPTION("Intel MAX10 BMC phy driver for n5010");
++MODULE_LICENSE("GPL v2");
+diff --git a/drivers/net/ethernet/silicom/n5010-phy.h b/drivers/net/ethernet/silicom/n5010-phy.h
+new file mode 100644
+index 000000000000..9d466f88fb1a
+--- /dev/null
++++ b/drivers/net/ethernet/silicom/n5010-phy.h
+@@ -0,0 +1,16 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Header File for DFL driver and device API
++ *
++ * Copyright (C) 2020 Silicom Denmark A/S. All rights reserved.
++ */
++
++#ifndef __SILICOM_N5010_PHY_H
++#define __SILICOM_N5010_PHY_H
++
++int n5010_phy_module_info(struct net_device *netdev);
++int n5010_phy_attach(struct device *dev, struct net_device *netdev,
++		     bool (*update)(struct net_device *netdev), u64 port_num);
++int n5010_phy_detach(struct net_device *netdev);
++
++#endif
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0118-net-ethernet-silicom-add-n5010-hssi-driver.patch new/debian/patches/fpga-ofs/0118-net-ethernet-silicom-add-n5010-hssi-driver.patch
--- org/debian/patches/fpga-ofs/0118-net-ethernet-silicom-add-n5010-hssi-driver.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0118-net-ethernet-silicom-add-n5010-hssi-driver.patch	2021-07-20 06:17:11.508844572 +0200
@@ -0,0 +1,676 @@
+From 1b439ec45e28081a60542a192a5eb7ac6b493f96 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Martin=20Hundeb=C3=B8ll?= <mhu@silicom.dk>
+Date: Mon, 1 Feb 2021 13:20:47 +0100
+Subject: [PATCH 118/149] net: ethernet: silicom: add n5010-hssi driver
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add Silicom Lightning Creek high speed driver.
+
+Signed-off-by: Martin Hundebøll <mhu@silicom.dk>
+---
+ MAINTAINERS                               |   1 +
+ drivers/net/ethernet/silicom/Kconfig      |  10 +
+ drivers/net/ethernet/silicom/Makefile     |   1 +
+ drivers/net/ethernet/silicom/n5010-hssi.c | 608 ++++++++++++++++++++++
+ 4 files changed, 620 insertions(+)
+ create mode 100644 drivers/net/ethernet/silicom/n5010-hssi.c
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 276821992ff4..4aa1f8b6b05c 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -15996,6 +15996,7 @@ SILICOM PAC N5010 DRIVER
+ M:	Esa Leskinen <ele@silicom.dk>
+ L:	netdev@vger.kernel.org
+ S:	Maintained
++F:	drivers/net/ethernet/silicom/n5010-hssi.c
+ F:	drivers/net/ethernet/silicom/n5010-phy.c
+ 
+ SILICON LABS WIRELESS DRIVERS (for WFxxx series)
+diff --git a/drivers/net/ethernet/silicom/Kconfig b/drivers/net/ethernet/silicom/Kconfig
+index b109c5079656..2366418f5f25 100644
+--- a/drivers/net/ethernet/silicom/Kconfig
++++ b/drivers/net/ethernet/silicom/Kconfig
+@@ -24,4 +24,14 @@ config N5010_PHY
+ 	  and a side-fpga running the board management controller (bmc). This driver
+ 	  reads status bits and controls link LEDs via the bmc.
+ 
++config N5010_HSSI
++	tristate "Control Plane Driver for Silicom PAC N5010 HSSI"
++	select N5010_PHY
++	select REGMAP_INDIRECT_REGISTER
++	help
++	  This driver provides control plane support for the Silicom N5010
++	  Programmable Acceleration Card. This driver adds network interfaces
++	  for the line-side QFSP modules, supporting various control/status
++	  operations.
++
+ endif # NET_VENDOR_SILICOM
+diff --git a/drivers/net/ethernet/silicom/Makefile b/drivers/net/ethernet/silicom/Makefile
+index c51cd4b4c517..e613043ae1c1 100644
+--- a/drivers/net/ethernet/silicom/Makefile
++++ b/drivers/net/ethernet/silicom/Makefile
+@@ -4,3 +4,4 @@
+ #
+ 
+ obj-$(CONFIG_N5010_PHY) += n5010-phy.o
++obj-$(CONFIG_N5010_HSSI) += n5010-hssi.o
+diff --git a/drivers/net/ethernet/silicom/n5010-hssi.c b/drivers/net/ethernet/silicom/n5010-hssi.c
+new file mode 100644
+index 000000000000..9627fa9a03fe
+--- /dev/null
++++ b/drivers/net/ethernet/silicom/n5010-hssi.c
+@@ -0,0 +1,608 @@
++// SPDX-License-Identifier: GPL-2.0
++
++/* Silicom(R) Low Latency 100G Network Driver
++ *
++ * Copyright (C) 2020 Silicom Denmark. All rights reserved.
++ */
++
++#include <linux/bitfield.h>
++#include <linux/etherdevice.h>
++#include <linux/ethtool.h>
++#include <linux/dfl.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/jiffies.h>
++#include <linux/module.h>
++#include <linux/netdevice.h>
++#include <linux/phy.h>
++#include <linux/regmap.h>
++#include <linux/spi/spi.h>
++#include <linux/timer.h>
++#include <linux/uaccess.h>
++
++#include "n5010-phy.h"
++
++#define CAPABILITY_OFFSET	0x08
++#define CAP_AVAILABLE_RATES	GENMASK_ULL(7, 0)
++#define CAP_CONTAINS_PCS	GENMASK_ULL(15, 8)
++#define CAP_CONTAINS_FEC	GENMASK_ULL(23, 16)
++#define CAP_PORT_CNT		GENMASK_ULL(43, 40)
++#define CAP_RATE_1G		BIT_ULL(0)
++#define CAP_RATE_10G		BIT_ULL(1)
++#define CAP_RATE_25G		BIT_ULL(2)
++#define CAP_RATE_40G		BIT_ULL(3)
++#define CAP_RATE_50G		BIT_ULL(4)
++#define CAP_RATE_100G		BIT_ULL(5)
++#define CAP_RATE_200G		BIT_ULL(6)
++#define CAP_RATE_400G		BIT_ULL(7)
++
++#define MB_MAC_OFFSET		0x28
++#define MB_FEC_OFFSET		0x68
++#define MB_PHY_OFFSET		0xa8
++#define MB_PORT_SIZE            0x10
++
++#define PHY_BASE_OFF		0x2000
++#define PHY_RX_SER_LOOP_BACK	0x4e1
++
++#define FEC_RX_STATUS		0x180
++#define FEC_RX_STATUS_LINK	0x0ULL
++#define FEC_RX_STATUS_LINK_NO	0x3ULL
++
++#define MAC_TX_SRC_ADDR_LO	0x40c
++#define MAC_TX_SRC_ADDR_HI	0x40d
++#define MAC_RX_MTU		0x506
++#define MAC_MAX_MTU		9600
++
++#define ILL_100G_TX_STATS_CLR	0x845
++#define ILL_100G_RX_STATS_CLR	0x945
++#define ILL_100G_LPBK_OFF	0x313
++#define ILL_100G_LPBK_EN_VAL	0xffff
++
++#define STATS_CLR_INT_US		1
++#define STATS_CLR_INT_TIMEOUT_US	1000
++
++struct n5010_hssi_ops_params {
++	struct stat_info *stats;
++	u32 num_stats;
++	u32 tx_clr_off;
++	u32 rx_clr_off;
++};
++
++struct n5010_hssi_regmaps {
++	struct regmap *regmap;
++};
++
++struct n5010_hssi_netdata {
++	struct dfl_device *dfl_dev;
++	struct regmap *regmap_mac;
++	struct regmap *regmap_fec;
++	struct regmap *regmap_phy;
++	u32 link_status;
++	const struct n5010_hssi_ops_params *ops_params;
++};
++
++struct n5010_hssi_drvdata {
++	struct dfl_device *dfl_dev;
++	void __iomem *base;
++	u64  port_cnt;
++	struct net_device *netdev[];
++};
++
++static bool n5010_hssi_update_link(struct net_device *netdev)
++{
++	struct n5010_hssi_netdata *npriv = netdev_priv(netdev);
++	u32 link_status = FEC_RX_STATUS_LINK_NO;
++
++	regmap_read(npriv->regmap_fec, FEC_RX_STATUS, &link_status);
++
++	return link_status == FEC_RX_STATUS_LINK;
++}
++
++static int netdev_open(struct net_device *netdev)
++{
++	if (netdev->phydev)
++		phy_start(netdev->phydev);
++
++	return 0;
++}
++
++static int netdev_stop(struct net_device *netdev)
++{
++	if (netdev->phydev)
++		phy_stop(netdev->phydev);
++
++	return 0;
++}
++
++static int netdev_change_mtu(struct net_device *netdev, int new_mtu)
++{
++	struct n5010_hssi_netdata *npriv = netdev_priv(netdev);
++
++	netdev->mtu = new_mtu;
++
++	return regmap_write(npriv->regmap_mac, MAC_RX_MTU, new_mtu);
++}
++
++static int netdev_set_features(struct net_device *netdev,
++			       netdev_features_t features)
++{
++	return 0;
++}
++
++static int netdev_set_mac_address(struct net_device *netdev, void *p)
++{
++	struct n5010_hssi_netdata *npriv = netdev_priv(netdev);
++	struct sockaddr *addr = p;
++	u32 mac_part1, mac_part2;
++	int ret;
++
++	memcpy(netdev->dev_addr, addr->sa_data, ETH_ALEN);
++
++	mac_part1 = (addr->sa_data[0] << 8) | addr->sa_data[1];
++	mac_part2 = (addr->sa_data[2] << 24) | (addr->sa_data[3] << 16) |
++		    (addr->sa_data[4] << 8) | addr->sa_data[5];
++
++	ret = regmap_write(npriv->regmap_mac, MAC_TX_SRC_ADDR_HI, mac_part1);
++	if (ret)
++		return ret;
++
++	return regmap_write(npriv->regmap_mac, MAC_TX_SRC_ADDR_LO, mac_part2);
++}
++
++static netdev_tx_t netdev_xmit(struct sk_buff *skb, struct net_device *netdev)
++{
++	kfree_skb(skb);
++
++	return NETDEV_TX_OK;
++}
++
++static const struct net_device_ops netdev_ops = {
++	.ndo_open = netdev_open,
++	.ndo_stop = netdev_stop,
++	.ndo_start_xmit = netdev_xmit,
++	.ndo_change_mtu = netdev_change_mtu,
++	.ndo_set_features = netdev_set_features,
++	.ndo_set_mac_address = netdev_set_mac_address,
++};
++
++struct stat_info {
++	unsigned int addr;
++	char string[ETH_GSTRING_LEN];
++};
++
++#define STAT_INFO(_addr, _string) \
++	.addr = _addr, .string = _string,
++
++static void ethtool_get_strings(struct net_device *netdev, u32 stringset,
++				u8 *s)
++{
++	struct n5010_hssi_netdata *npriv = netdev_priv(netdev);
++	unsigned int i, stats_num = 0;
++	struct stat_info *stat;
++
++	if (stringset != ETH_SS_STATS)
++		return;
++
++	stat = npriv->ops_params->stats;
++	stats_num = npriv->ops_params->num_stats;
++
++	for (i = 0; i < stats_num; i++, s += ETH_GSTRING_LEN)
++		memcpy(s, stat[i].string, ETH_GSTRING_LEN);
++}
++
++static int ethtool_get_sset_count(struct net_device *netdev, int stringset)
++{
++	struct n5010_hssi_netdata *npriv = netdev_priv(netdev);
++
++	if (stringset == ETH_SS_STATS)
++		return npriv->ops_params->num_stats;
++
++	return 0;
++}
++
++static u64 read_mac_stat(struct regmap *regmap, unsigned int addr)
++{
++	u32 data_l, data_h;
++
++	regmap_read(regmap, addr, &data_l);
++	regmap_read(regmap, addr + 1, &data_h);
++
++	return data_l + ((u64)data_h << 32);
++}
++
++static int ethtool_reset(struct net_device *netdev, u32 *flags)
++{
++	struct n5010_hssi_netdata *npriv = netdev_priv(netdev);
++	struct regmap *regmap = npriv->regmap_mac;
++	u32 reg, val;
++	int ret;
++
++	if (*flags | ETH_RESET_MGMT) {
++		reg = npriv->ops_params->tx_clr_off;
++
++		ret = regmap_write(regmap, reg, 1);
++		if (ret)
++			return ret;
++
++		ret = regmap_write(regmap, reg, 0);
++		if (ret)
++			return ret;
++
++		ret = regmap_read_poll_timeout(regmap, reg, val, (val & 1) == 0,
++					       STATS_CLR_INT_US,
++					       STATS_CLR_INT_TIMEOUT_US);
++		if (ret) {
++			dev_err(&netdev->dev, "failed to clear tx stats\n");
++			return ret;
++		}
++
++		reg = npriv->ops_params->rx_clr_off;
++
++		ret = regmap_write(regmap, reg, 1);
++		if (ret)
++			return ret;
++
++		ret = regmap_write(regmap, reg, 0);
++		if (ret)
++			return ret;
++
++		ret = regmap_read_poll_timeout(regmap, reg, val, (val & 1) == 0,
++					       STATS_CLR_INT_US,
++					       STATS_CLR_INT_TIMEOUT_US);
++		if (ret) {
++			dev_err(&netdev->dev, "failed to clear rx stats\n");
++			return ret;
++		}
++	}
++
++	return 0;
++}
++
++static void ethtool_get_stats(struct net_device *netdev,
++			      struct ethtool_stats *stats, u64 *data)
++{
++	struct n5010_hssi_netdata *npriv = netdev_priv(netdev);
++	unsigned int i, stats_num = npriv->ops_params->num_stats;
++	struct stat_info *stat = npriv->ops_params->stats;
++
++	for (i = 0; i < stats_num; i++)
++		data[i] = read_mac_stat(npriv->regmap_mac, stat[i].addr);
++}
++
++static int ethtool_module_info(struct net_device *netdev,
++			       struct ethtool_modinfo *modinfo)
++{
++	return n5010_phy_module_info(netdev);
++}
++
++static const struct ethtool_ops ethtool_ops = {
++	.get_strings = ethtool_get_strings,
++	.get_sset_count = ethtool_get_sset_count,
++	.get_ethtool_stats = ethtool_get_stats,
++	.get_link = ethtool_op_get_link,
++	.get_module_info = ethtool_module_info,
++	.reset = ethtool_reset,
++};
++
++static struct stat_info stats_100g[] = {
++	/* tx statistics */
++	{STAT_INFO(0x800, "tx_fragments")},
++	{STAT_INFO(0x802, "tx_jabbers")},
++	{STAT_INFO(0x804, "tx_crcerr")},
++	{STAT_INFO(0x806, "tx_crcerr_sizeok")},
++	{STAT_INFO(0x808, "tx_mcast_data_err")},
++	{STAT_INFO(0x80a, "tx_bcast_data_err")},
++	{STAT_INFO(0x80c, "tx_ucast_data_err")},
++	{STAT_INFO(0x80e, "tx_mcast_ctrl_err")},
++	{STAT_INFO(0x810, "tx_bcast_ctrl_err")},
++	{STAT_INFO(0x812, "tx_ucast_ctrl_err")},
++	{STAT_INFO(0x814, "tx_pause_err")},
++	{STAT_INFO(0x816, "tx_64b")},
++	{STAT_INFO(0x818, "tx_65to127b")},
++	{STAT_INFO(0x81a, "tx_128to255b")},
++	{STAT_INFO(0x81c, "tx_256to511b")},
++	{STAT_INFO(0x81e, "tx_512to1023b")},
++	{STAT_INFO(0x820, "tx_1024to1518b")},
++	{STAT_INFO(0x822, "tx_1519tomaxb")},
++	{STAT_INFO(0x824, "tx_oversize")},
++	{STAT_INFO(0x836, "tx_st")},
++	{STAT_INFO(0x826, "tx_mcast_data_ok")},
++	{STAT_INFO(0x828, "tx_bcast_data_ok")},
++	{STAT_INFO(0x82a, "tx_ucast_data_ok")},
++	{STAT_INFO(0x82c, "tx_mcast_ctrl_ok")},
++	{STAT_INFO(0x82e, "tx_bcast_ctrl_ok")},
++	{STAT_INFO(0x830, "tx_ucast_ctrl_ok")},
++	{STAT_INFO(0x832, "tx_pause")},
++	{STAT_INFO(0x860, "tx_payload_octets_ok")},
++	{STAT_INFO(0x862, "tx_frame_octets_ok")},
++
++	/* rx statistics */
++	{STAT_INFO(0x900, "rx_fragments")},
++	{STAT_INFO(0x902, "rx_jabbers")},
++	{STAT_INFO(0x904, "rx_crcerr")},
++	{STAT_INFO(0x906, "rx_crcerr_sizeok")},
++	{STAT_INFO(0x908, "rx_mcast_data_err")},
++	{STAT_INFO(0x90a, "rx_bcast_data_err")},
++	{STAT_INFO(0x90c, "rx_ucast_data_err")},
++	{STAT_INFO(0x90e, "rx_mcast_ctrl_err")},
++	{STAT_INFO(0x910, "rx_bcast_ctrl_err")},
++	{STAT_INFO(0x912, "rx_ucast_ctrl_err")},
++	{STAT_INFO(0x914, "rx_pause_err")},
++	{STAT_INFO(0x916, "rx_64b")},
++	{STAT_INFO(0x918, "rx_65to127b")},
++	{STAT_INFO(0x91a, "rx_128to255b")},
++	{STAT_INFO(0x91c, "rx_256to511b")},
++	{STAT_INFO(0x91e, "rx_512to1023b")},
++	{STAT_INFO(0x920, "rx_1024to1518b")},
++	{STAT_INFO(0x922, "rx_1519tomaxb")},
++	{STAT_INFO(0x924, "rx_oversize")},
++	{STAT_INFO(0x936, "rx_st")},
++	{STAT_INFO(0x926, "rx_mcast_data_ok")},
++	{STAT_INFO(0x928, "rx_bcast_data_ok")},
++	{STAT_INFO(0x92a, "rx_ucast_data_ok")},
++	{STAT_INFO(0x92c, "rx_mcast_ctrl_ok")},
++	{STAT_INFO(0x92e, "rx_bcast_ctrl_ok")},
++	{STAT_INFO(0x930, "rx_ucast_ctrl_ok")},
++	{STAT_INFO(0x932, "rx_pause")},
++	{STAT_INFO(0x960, "rx_payload_octets_ok")},
++	{STAT_INFO(0x962, "rx_frame_octets_ok")},
++};
++
++static const struct n5010_hssi_ops_params n5010_100g_params = {
++	.stats = stats_100g,
++	.num_stats = ARRAY_SIZE(stats_100g),
++	.tx_clr_off = ILL_100G_TX_STATS_CLR,
++	.rx_clr_off = ILL_100G_RX_STATS_CLR,
++};
++
++static void n5010_hssi_init_netdev(struct net_device *netdev)
++{
++	netdev->ethtool_ops = &ethtool_ops;
++	netdev->netdev_ops = &netdev_ops;
++	netdev->features = 0;
++	netdev->hard_header_len = 0;
++	netdev->priv_flags |= IFF_NO_QUEUE;
++	netdev->max_mtu = MAC_MAX_MTU;
++	netdev->needs_free_netdev  = true;
++
++	ether_setup(netdev);
++}
++
++enum n5010_hssi_regmap {
++	regmap_mac,
++	regmap_fec,
++	regmap_phy,
++};
++
++#ifndef devm_regmap_init_indirect_register
++struct regmap *devm_regmap_init_indirect_register(struct device *dev,
++						  void __iomem *base,
++						  struct regmap_config *cfg);
++#endif
++
++static struct regmap *n5010_hssi_create_regmap(struct n5010_hssi_drvdata *priv,
++					       u64 port,
++					       enum n5010_hssi_regmap type)
++{
++	void __iomem *base = priv->base + port * MB_PORT_SIZE;
++	struct device *dev = &priv->dfl_dev->dev;
++	struct regmap_config cfg = {0};
++	char regmap_name[20];
++
++	switch (type) {
++	case regmap_mac:
++		sprintf(regmap_name, "n5010_hssi_mac%llu", port);
++		base += MB_MAC_OFFSET;
++		cfg.val_bits = 32;
++		cfg.max_register = 0xbbf;
++		break;
++	case regmap_fec:
++		sprintf(regmap_name, "n5010_hssi_fec%llu", port);
++		base += MB_FEC_OFFSET;
++		cfg.val_bits = 8;
++		cfg.max_register = 0x29c;
++		break;
++	case regmap_phy:
++		sprintf(regmap_name, "n5010_hssi_phy%llu", port);
++		base += MB_PHY_OFFSET;
++		cfg.val_bits = 8;
++		cfg.max_register = 0x40144;
++		break;
++	}
++
++	cfg.name = regmap_name;
++	cfg.reg_bits = 32;
++
++	return devm_regmap_init_indirect_register(dev, base, &cfg);
++}
++
++static int n5010_hssi_create_netdev(struct n5010_hssi_drvdata *priv,
++				    struct device *phy, u64 port)
++{
++	struct device *dev = &priv->dfl_dev->dev;
++	struct n5010_hssi_netdata *npriv;
++	struct net_device *netdev;
++	int err = -ENOMEM;
++	u32 flags;
++
++	netdev = alloc_netdev(sizeof(struct n5010_hssi_netdata),
++			      "n5010_hssi%d", NET_NAME_UNKNOWN,
++			      n5010_hssi_init_netdev);
++	priv->netdev[port] = netdev;
++
++	if (!netdev)
++		return -ENOMEM;
++
++	npriv = netdev_priv(netdev);
++
++	npriv->dfl_dev = priv->dfl_dev;
++
++	npriv->regmap_mac = n5010_hssi_create_regmap(priv, port, regmap_mac);
++	if (!npriv->regmap_mac)
++		goto err_unreg_netdev;
++
++	npriv->regmap_fec = n5010_hssi_create_regmap(priv, port, regmap_fec);
++	if (!npriv->regmap_fec)
++		goto err_unreg_netdev;
++
++	npriv->regmap_phy = n5010_hssi_create_regmap(priv, port, regmap_phy);
++	if (!npriv->regmap_phy)
++		goto err_unreg_netdev;
++
++	npriv->ops_params = &n5010_100g_params;
++
++	SET_NETDEV_DEV(netdev, dev);
++
++	flags = ETH_RESET_MGMT;
++
++	npriv->link_status = FEC_RX_STATUS_LINK_NO;
++
++	err = ethtool_reset(netdev, &flags);
++	if (err) {
++		dev_err(dev, "failed to reset MGMT %s: %d", netdev->name, err);
++		goto err_unreg_netdev;
++	}
++
++	err = register_netdev(netdev);
++	if (err) {
++		dev_err(dev, "failed to register %s: %d", netdev->name, err);
++		goto err_unreg_netdev;
++	}
++
++	err = n5010_phy_attach(phy, netdev, n5010_hssi_update_link, port);
++	if (err)
++		goto err_unreg_netdev;
++
++	return 0;
++
++err_unreg_netdev:
++	unregister_netdev(netdev);
++
++	return err;
++}
++
++static int n5010_match_phy_dev(struct device *dev, void *data)
++{
++	return dev->driver && !strcmp(dev->driver->name, "n5010bmc-phy");
++}
++
++static int n5010_match_phy_master(struct device *dev, const void *data)
++{
++	struct dfl_device *dfl_dev = (void *)data;
++	struct device *base_dev = dfl_dev_get_base_dev(dfl_dev);
++
++	/* look trace device tree until a direct dfl-device is found */
++	do {
++		if (!dev->bus)
++			continue;
++
++		if (!strcmp(dev->bus->name, "dfl"))
++			break;
++
++		if (!dev->parent)
++			return 0;
++	} while ((dev = dev->parent));
++
++	if (!dev)
++		return 0;
++
++	/* compare the base (pci) device of the spi controller with the base
++	 * (pci) device of the n5010-hssi device
++	 */
++	return dfl_dev_get_base_dev(to_dfl_dev(dev)) == base_dev;
++}
++
++static int n5010_hssi_probe(struct dfl_device *dfl_dev)
++{
++	struct device *phy_master, *phy_dev;
++	struct device *dev = &dfl_dev->dev;
++	struct n5010_hssi_drvdata *priv;
++	u64 val, port_cnt, port;
++	void __iomem *base;
++	u64 priv_size;
++	int ret = 0;
++
++	/* find the spi controller from this pci device */
++	phy_master = bus_find_device(&spi_bus_type, NULL, dfl_dev,
++				     n5010_match_phy_master);
++	if (!phy_master) {
++		dev_info(dev, "phy master not found; deferring probe\n");
++		return -EPROBE_DEFER;
++	}
++
++	/* find the spi slave matching the n5010-phy driver */
++	phy_dev = device_find_child(phy_master, dfl_dev,
++				    n5010_match_phy_dev);
++	if (!phy_dev) {
++		dev_info(dev, "phy slave not found; deferring probe\n");
++		ret = -EPROBE_DEFER;
++		goto err_phy_master;
++	}
++
++	base = devm_ioremap_resource(dev, &dfl_dev->mmio_res);
++	if (IS_ERR(base)) {
++		ret = PTR_ERR(base);
++		goto err_phy_dev;
++	}
++
++	val = readq(base + CAPABILITY_OFFSET);
++	port_cnt =  FIELD_GET(CAP_PORT_CNT, val);
++	priv_size = sizeof(*priv) + port_cnt * sizeof(void *);
++
++	priv = devm_kzalloc(dev, priv_size, GFP_KERNEL);
++	if (!priv) {
++		ret = -ENOMEM;
++		goto err_phy_dev;
++	}
++
++	dev_set_drvdata(dev, priv);
++
++	priv->dfl_dev = dfl_dev;
++	priv->port_cnt = port_cnt;
++	priv->base = base;
++
++	for (port = 0; port < priv->port_cnt; port++) {
++		ret = n5010_hssi_create_netdev(priv, phy_dev, port);
++		if (ret)
++			goto err_phy_dev;
++	}
++
++err_phy_dev:
++	put_device(phy_dev);
++err_phy_master:
++	put_device(phy_master);
++
++	return ret;
++}
++
++static void n5010_hssi_remove(struct dfl_device *dfl_dev)
++{
++	struct n5010_hssi_drvdata *priv = dev_get_drvdata(&dfl_dev->dev);
++	u64 port;
++
++	for (port = 0; port < priv->port_cnt; port++) {
++		n5010_phy_detach(priv->netdev[port]);
++		unregister_netdev(priv->netdev[port]);
++	}
++}
++
++#define FME_FEATURE_ID_LL_100G_MAC_N5010	0x1f /* Silicom Lightning Creek */
++
++static const struct dfl_device_id n5010_hssi_mac_ids[] = {
++	{ FME_ID, FME_FEATURE_ID_LL_100G_MAC_N5010 },
++	{ }
++};
++
++static struct dfl_driver n5010_hssi_driver = {
++	.drv = {
++		.name = "n5010_hssi",
++	},
++	.id_table = n5010_hssi_mac_ids,
++	.probe = n5010_hssi_probe,
++	.remove = n5010_hssi_remove,
++};
++
++module_dfl_driver(n5010_hssi_driver);
++MODULE_DEVICE_TABLE(dfl, n5010_hssi_mac_ids);
++MODULE_DESCRIPTION("Network Device Driver for Silicom Lightning Creek");
++MODULE_AUTHOR("Esa Leskinen <ele@silicom.dk>");
++MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0119-configs-add-n5010-defconfig-snippet.patch new/debian/patches/fpga-ofs/0119-configs-add-n5010-defconfig-snippet.patch
--- org/debian/patches/fpga-ofs/0119-configs-add-n5010-defconfig-snippet.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0119-configs-add-n5010-defconfig-snippet.patch	2021-07-20 06:17:11.508844572 +0200
@@ -0,0 +1,55 @@
+From eba20378cce64a6a7ce1480cd60e9cac9a0d9861 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Martin=20Hundeb=C3=B8ll?= <mhu@silicom.dk>
+Date: Mon, 1 Feb 2021 13:20:47 +0100
+Subject: [PATCH 119/149] configs: add n5010 defconfig snippet
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add a config snippet to use when building for the Silicom N5010 PAC.
+
+Signed-off-by: Martin Hundebøll <mhu@silicom.dk>
+---
+ configs/n5010_defconfig | 30 ++++++++++++++++++++++++++++++
+ 1 file changed, 30 insertions(+)
+ create mode 100644 configs/n5010_defconfig
+
+diff --git a/configs/n5010_defconfig b/configs/n5010_defconfig
+new file mode 100644
+index 000000000000..0150c142aa5e
+--- /dev/null
++++ b/configs/n5010_defconfig
+@@ -0,0 +1,30 @@
++CONFIG_FPGA_DFL=m
++CONFIG_FPGA_DFL_FME=m
++CONFIG_FPGA_DFL_FME_MGR=m
++CONFIG_FPGA_DFL_FME_BRIDGE=m
++CONFIG_FPGA_DFL_FME_REGION=m
++CONFIG_FPGA_DFL_AFU=m
++CONFIG_FPGA_DFL_SPI_ALTERA=m
++CONFIG_FPGA_DFL_PCI=m
++
++CONFIG_FPGA=m
++CONFIG_FPGA_MGR=m
++CONFIG_FPGA_BRIDGE=m
++CONFIG_FPGA_REGION=m
++CONFIG_FPGA_SEC_MGR=m
++CONFIG_IFPGA_M10_BMC_SECURE=m
++
++CONFIG_SPI=y
++CONFIG_SPI_MASTER=y
++CONFIG_MFD_INTEL_M10_BMC=m
++CONFIG_SENSORS_INTEL_M10_BMC_HWMON=m
++
++CONFIG_SPI_ALTERA=m
++
++CONFIG_FIXED_PHY=m
++CONFIG_NET_VENDOR_SILICOM=y
++CONFIG_N5010_HSSI=m
++CONFIG_n5010_PHY=m
++
++CONFIG_REGMAP_INDIRECT_REGISTER=m
++CONFIG_REGMAP_SPI_AVMM=m
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0120-configs-Resolve-unmatched-configs-in-n5010_defconfig.patch new/debian/patches/fpga-ofs/0120-configs-Resolve-unmatched-configs-in-n5010_defconfig.patch
--- org/debian/patches/fpga-ofs/0120-configs-Resolve-unmatched-configs-in-n5010_defconfig.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0120-configs-Resolve-unmatched-configs-in-n5010_defconfig.patch	2021-07-20 06:17:11.508844572 +0200
@@ -0,0 +1,37 @@
+From 8f61e0d557abc814e4ecdff73bd131d54d715caf Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 31 Mar 2021 17:18:59 -0700
+Subject: [PATCH 120/149] configs: Resolve unmatched configs in n5010_defconfig
+
+CONFIG_FPGA_MGR does not exist in the kernel source.
+Changed CONFIG_n5010_PHY=m to CONFIG_N5010_PHY=m
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ configs/n5010_defconfig | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+diff --git a/configs/n5010_defconfig b/configs/n5010_defconfig
+index 0150c142aa5e..4dd488ddfca9 100644
+--- a/configs/n5010_defconfig
++++ b/configs/n5010_defconfig
+@@ -8,7 +8,6 @@ CONFIG_FPGA_DFL_SPI_ALTERA=m
+ CONFIG_FPGA_DFL_PCI=m
+ 
+ CONFIG_FPGA=m
+-CONFIG_FPGA_MGR=m
+ CONFIG_FPGA_BRIDGE=m
+ CONFIG_FPGA_REGION=m
+ CONFIG_FPGA_SEC_MGR=m
+@@ -24,7 +23,7 @@ CONFIG_SPI_ALTERA=m
+ CONFIG_FIXED_PHY=m
+ CONFIG_NET_VENDOR_SILICOM=y
+ CONFIG_N5010_HSSI=m
+-CONFIG_n5010_PHY=m
++CONFIG_N5010_PHY=m
+ 
+ CONFIG_REGMAP_INDIRECT_REGISTER=m
+ CONFIG_REGMAP_SPI_AVMM=m
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0121-fpga-dfl-add-an-API-to-get-the-base-device-for-dfl-d.patch new/debian/patches/fpga-ofs/0121-fpga-dfl-add-an-API-to-get-the-base-device-for-dfl-d.patch
--- org/debian/patches/fpga-ofs/0121-fpga-dfl-add-an-API-to-get-the-base-device-for-dfl-d.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0121-fpga-dfl-add-an-API-to-get-the-base-device-for-dfl-d.patch	2021-07-20 06:17:11.508844572 +0200
@@ -0,0 +1,64 @@
+From b56880de86675db97bbe1317933801b894aa95f0 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Tue, 21 Apr 2020 22:51:00 +0800
+Subject: [PATCH 121/149] fpga: dfl: add an API to get the base device for dfl
+ device
+
+Restoring this patch. It was inadvertently reverted in the context of:
+
+a872b3481848 Revert "fpga: dfl: export network configuration info for
+             DFL based FPGA"
+
+This patch adds an API for dfl devices to find which physical device
+owns the DFL.
+
+This patch makes preparation for supporting DFL Ether Group private
+feature driver. It uses this information to determine which retimer
+device physically connects to which ether group.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Reviewed-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+----
+v2: change commit msg according to Matthew's suggestion.
+v3: no change.
+---
+ drivers/fpga/dfl.c  | 9 +++++++++
+ include/linux/dfl.h | 2 ++
+ 2 files changed, 11 insertions(+)
+
+diff --git a/drivers/fpga/dfl.c b/drivers/fpga/dfl.c
+index 08487540e063..8967283729c2 100644
+--- a/drivers/fpga/dfl.c
++++ b/drivers/fpga/dfl.c
+@@ -474,6 +474,15 @@ void dfl_driver_unregister(struct dfl_driver *dfl_drv)
+ }
+ EXPORT_SYMBOL(dfl_driver_unregister);
+ 
++struct device *dfl_dev_get_base_dev(struct dfl_device *dfl_dev)
++{
++	if (!dfl_dev || !dfl_dev->cdev)
++		return NULL;
++
++	return dfl_dev->cdev->parent;
++}
++EXPORT_SYMBOL_GPL(dfl_dev_get_base_dev);
++
+ #define is_header_feature(feature) ((feature)->id == FEATURE_ID_FIU_HEADER)
+ 
+ /**
+diff --git a/include/linux/dfl.h b/include/linux/dfl.h
+index 1cd86b2e7cb1..783d6a9d8f08 100644
+--- a/include/linux/dfl.h
++++ b/include/linux/dfl.h
+@@ -67,6 +67,8 @@ struct dfl_driver {
+ #define to_dfl_dev(d) container_of(d, struct dfl_device, dev)
+ #define to_dfl_drv(d) container_of(d, struct dfl_driver, drv)
+ 
++struct device *dfl_dev_get_base_dev(struct dfl_device *dfl_dev);
++
+ /*
+  * use a macro to avoid include chaining to get THIS_MODULE.
+  */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0122-configs-Update-readme.txt-for-N5010.patch new/debian/patches/fpga-ofs/0122-configs-Update-readme.txt-for-N5010.patch
--- org/debian/patches/fpga-ofs/0122-configs-Update-readme.txt-for-N5010.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0122-configs-Update-readme.txt-for-N5010.patch	2021-07-20 06:17:11.508844572 +0200
@@ -0,0 +1,26 @@
+From 21208cdd4c0a6e61eef799e0c9cd9e45790b46d4 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 2 Apr 2021 11:22:16 -0700
+Subject: [PATCH 122/149] configs: Update readme.txt for N5010
+
+Add a reference in the readme.txt file for the n5010_defconfig file.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ configs/readme.txt | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/configs/readme.txt b/configs/readme.txt
+index 285d09021633..a40f07af91b1 100644
+--- a/configs/readme.txt
++++ b/configs/readme.txt
+@@ -14,3 +14,6 @@ support the Intel n3000 and d5005 PCIe cards:
+ 
+ n3000_d5005_defconfig
+ 	Default configuration for Intel n3000 and d5005 PCIe cards.
++
++n5010_defconfig
++	Default configuration for Silicom n5010 PCIe card.
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0123-configs-Combine-config-fragments-into-one-file.patch new/debian/patches/fpga-ofs/0123-configs-Combine-config-fragments-into-one-file.patch
--- org/debian/patches/fpga-ofs/0123-configs-Combine-config-fragments-into-one-file.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0123-configs-Combine-config-fragments-into-one-file.patch	2021-07-20 06:17:11.508844572 +0200
@@ -0,0 +1,123 @@
+From 8209367284a132ecea18f5c2545350b978285b0a Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Mon, 5 Apr 2021 11:13:31 -0700
+Subject: [PATCH 123/149] configs: Combine config fragments into one file
+
+Having separate config files means having a lot of duplicate options
+listed in both files. It also means that both config files need to be
+used in order to build all of the DFL support into a single kernel.
+
+This change merges the configs into a single list of config options and
+renames the readme.txt file to README.
+
+The n3000_d5005_defconfig and n5010_defconfig files are now deprecated
+and will be removed soon.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ configs/README     | 13 +++++++++++++
+ configs/dfl-config | 45 +++++++++++++++++++++++++++++++++++++++++++++
+ configs/readme.txt | 19 -------------------
+ 3 files changed, 58 insertions(+), 19 deletions(-)
+ create mode 100644 configs/README
+ create mode 100644 configs/dfl-config
+ delete mode 100644 configs/readme.txt
+
+diff --git a/configs/README b/configs/README
+new file mode 100644
+index 000000000000..d100a073056b
+--- /dev/null
++++ b/configs/README
+@@ -0,0 +1,13 @@
++This directory contains the dfl-config file which includes the config
++options required to enable the Device Feature List (DFL) driver support.
++By design the DFL driver collection is extendable and it is anticipated
++that new drivers will be added to the collection.
++
++The dfl related config options are intended to be appended to a base kernel
++configuration. For example the following commands would modify an existing
++kernel configuration to enable support DFL cards.
++
++	# cd kernel_source_directory
++	# cp /boot/config-`uname -r` .config
++	# cat configs/dfl-config >> .config
++	# make olddefconfig
+diff --git a/configs/dfl-config b/configs/dfl-config
+new file mode 100644
+index 000000000000..d339cc3ee3d5
+--- /dev/null
++++ b/configs/dfl-config
+@@ -0,0 +1,45 @@
++# Core FPGA support
++
++CONFIG_FPGA=m
++CONFIG_FPGA_BRIDGE=m
++CONFIG_FPGA_REGION=m
++
++# Core DFL support
++
++CONFIG_FPGA_DFL=m
++CONFIG_FPGA_DFL_PCI=m
++CONFIG_FPGA_DFL_AFU=m
++CONFIG_FPGA_DFL_FME=m
++CONFIG_FPGA_DFL_FME_MGR=m
++CONFIG_FPGA_DFL_FME_BRIDGE=m
++CONFIG_FPGA_DFL_FME_REGION=m
++
++CONFIG_SPI_ALTERA=m
++CONFIG_FPGA_DFL_SPI_ALTERA=m
++
++CONFIG_FPGA_SEC_MGR=m
++CONFIG_IFPGA_M10_BMC_SECURE=m
++
++CONFIG_MFD_INTEL_M10_BMC=m
++CONFIG_SENSORS_INTEL_M10_BMC_HWMON=m
++
++CONFIG_UIO_DFL=m
++
++# N3000 / D5005 Support
++
++CONFIG_MEMORY=y
++CONFIG_IIO_INTERRUPT_TRIGGER=m
++
++CONFIG_FPGA_DFL_EMIF=m
++CONFIG_FPGA_DFL_INTEL_S10_IOPLL=m
++CONFIG_FPGA_DFL_NIOS_INTEL_PAC_N3000=m
++CONFIG_FPGA_DFl_HSSI=m
++CONFIG_S10HSSI=m
++CONFIG_INTEL_S10_PHY=m
++
++# N5010 Support
++
++CONFIG_FIXED_PHY=m
++CONFIG_N5010_HSSI=m
++CONFIG_N5010_PHY=m
++CONFIG_NET_VENDOR_SILICOM=y
+diff --git a/configs/readme.txt b/configs/readme.txt
+deleted file mode 100644
+index a40f07af91b1..000000000000
+--- a/configs/readme.txt
++++ /dev/null
+@@ -1,19 +0,0 @@
+-This directory contains linux kernel configuration fragments related to
+-the Device Feature List (DFL) driver collection. By design the DFL driver
+-collection is extendable, and it is anticipated that new drivers will be added
+-to the collection.
+-
+-The fragments are intended to be appended to a base kernel configuration.
+-For example the following commands would configure the kernel source to
+-support the Intel n3000 and d5005 PCIe cards:
+-
+-	# cd kernel_source_directory
+-	# cp /boot/config-`uname -r` .config
+-	# cat configs/n3000_d5005_defconfig >> .config
+-	# make olddefconfig
+-
+-n3000_d5005_defconfig
+-	Default configuration for Intel n3000 and d5005 PCIe cards.
+-
+-n5010_defconfig
+-	Default configuration for Silicom n5010 PCIe card.
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0124-configs-Remove-individual-config-fragments.patch new/debian/patches/fpga-ofs/0124-configs-Remove-individual-config-fragments.patch
--- org/debian/patches/fpga-ofs/0124-configs-Remove-individual-config-fragments.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0124-configs-Remove-individual-config-fragments.patch	2021-07-20 06:17:11.508844572 +0200
@@ -0,0 +1,94 @@
+From 3eed06ad960492c7b6d56fef45a09cabd92fcc78 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Mon, 5 Apr 2021 16:16:32 -0700
+Subject: [PATCH 124/149] configs: Remove individual config fragments
+
+The DFL config options are now all documented in a single file:
+configs/dfl-config. Remove the n3000_d5005_defconfig and
+n5010_defconfig config files.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ configs/n3000_d5005_defconfig | 33 ---------------------------------
+ configs/n5010_defconfig       | 29 -----------------------------
+ 2 files changed, 62 deletions(-)
+ delete mode 100644 configs/n3000_d5005_defconfig
+ delete mode 100644 configs/n5010_defconfig
+
+diff --git a/configs/n3000_d5005_defconfig b/configs/n3000_d5005_defconfig
+deleted file mode 100644
+index fee4a31e99a8..000000000000
+--- a/configs/n3000_d5005_defconfig
++++ /dev/null
+@@ -1,33 +0,0 @@
+-CONFIG_FPGA_DFL=m
+-CONFIG_FPGA_DFL_FME=m
+-CONFIG_FPGA_DFL_FME_MGR=m
+-CONFIG_FPGA_DFL_FME_BRIDGE=m
+-CONFIG_FPGA_DFL_FME_REGION=m
+-CONFIG_FPGA_DFL_AFU=m
+-CONFIG_FPGA_DFL_NIOS_INTEL_PAC_N3000=m
+-CONFIG_FPGA_DFL_SPI_ALTERA=m
+-CONFIG_FPGA_DFL_PCI=m
+-CONFIG_FPGA_DFl_HSSI=m
+-CONFIG_FPGA_DFL_INTEL_S10_IOPLL=m
+-
+-CONFIG_FPGA=m
+-CONFIG_FPGA_BRIDGE=m
+-CONFIG_FPGA_REGION=m
+-
+-CONFIG_FPGA_SEC_MGR=m
+-CONFIG_IFPGA_M10_BMC_SECURE=m
+-
+-CONFIG_UIO_DFL=m
+-
+-CONFIG_SENSORS_INTEL_M10_BMC_HWMON=m
+-CONFIG_MFD_INTEL_M10_BMC=m
+-
+-CONFIG_SPI_ALTERA=m
+-
+-CONFIG_INTEL_S10_PHY=m
+-CONFIG_S10HSSI=m
+-
+-CONFIG_MEMORY=y
+-CONFIG_FPGA_DFL_EMIF=m
+-
+-CONFIG_IIO_INTERRUPT_TRIGGER=m
+diff --git a/configs/n5010_defconfig b/configs/n5010_defconfig
+deleted file mode 100644
+index 4dd488ddfca9..000000000000
+--- a/configs/n5010_defconfig
++++ /dev/null
+@@ -1,29 +0,0 @@
+-CONFIG_FPGA_DFL=m
+-CONFIG_FPGA_DFL_FME=m
+-CONFIG_FPGA_DFL_FME_MGR=m
+-CONFIG_FPGA_DFL_FME_BRIDGE=m
+-CONFIG_FPGA_DFL_FME_REGION=m
+-CONFIG_FPGA_DFL_AFU=m
+-CONFIG_FPGA_DFL_SPI_ALTERA=m
+-CONFIG_FPGA_DFL_PCI=m
+-
+-CONFIG_FPGA=m
+-CONFIG_FPGA_BRIDGE=m
+-CONFIG_FPGA_REGION=m
+-CONFIG_FPGA_SEC_MGR=m
+-CONFIG_IFPGA_M10_BMC_SECURE=m
+-
+-CONFIG_SPI=y
+-CONFIG_SPI_MASTER=y
+-CONFIG_MFD_INTEL_M10_BMC=m
+-CONFIG_SENSORS_INTEL_M10_BMC_HWMON=m
+-
+-CONFIG_SPI_ALTERA=m
+-
+-CONFIG_FIXED_PHY=m
+-CONFIG_NET_VENDOR_SILICOM=y
+-CONFIG_N5010_HSSI=m
+-CONFIG_N5010_PHY=m
+-
+-CONFIG_REGMAP_INDIRECT_REGISTER=m
+-CONFIG_REGMAP_SPI_AVMM=m
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0125-Revert-DEBUG-WARNING-enable-debugfs-writing-of-regma.patch new/debian/patches/fpga-ofs/0125-Revert-DEBUG-WARNING-enable-debugfs-writing-of-regma.patch
--- org/debian/patches/fpga-ofs/0125-Revert-DEBUG-WARNING-enable-debugfs-writing-of-regma.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0125-Revert-DEBUG-WARNING-enable-debugfs-writing-of-regma.patch	2021-07-20 06:17:11.508844572 +0200
@@ -0,0 +1,33 @@
+From 320f477f2a284b9535fd8c8360b470da0587af69 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Tue, 6 Apr 2021 13:33:02 -0700
+Subject: [PATCH 125/149] Revert "DEBUG WARNING enable debugfs writing of
+ regmap registers"
+
+This reverts commit 50731b580d322342b4508d7d9792cb0ac883d268.
+
+Reverting debugfs remap write capability from the LTS kernel by
+default. Revert or skip this patch if you want to have write
+capablity for your environment.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/base/regmap/regmap-debugfs.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
+index 27a99ede3f88..ff2ee87987c7 100644
+--- a/drivers/base/regmap/regmap-debugfs.c
++++ b/drivers/base/regmap/regmap-debugfs.c
+@@ -290,7 +290,7 @@ static ssize_t regmap_map_read_file(struct file *file, char __user *user_buf,
+ 				   count, ppos);
+ }
+ 
+-#define REGMAP_ALLOW_WRITE_DEBUGFS
++#undef REGMAP_ALLOW_WRITE_DEBUGFS
+ #ifdef REGMAP_ALLOW_WRITE_DEBUGFS
+ /*
+  * This can be dangerous especially when we have clients such as
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0126-fpga-dfl-pci-gracefully-handle-misconfigured-port-en.patch new/debian/patches/fpga-ofs/0126-fpga-dfl-pci-gracefully-handle-misconfigured-port-en.patch
--- org/debian/patches/fpga-ofs/0126-fpga-dfl-pci-gracefully-handle-misconfigured-port-en.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0126-fpga-dfl-pci-gracefully-handle-misconfigured-port-en.patch	2021-07-20 06:17:11.512844561 +0200
@@ -0,0 +1,60 @@
+From 65e4e68017168c0d14066a3217c7928472fb5a08 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Thu, 8 Apr 2021 07:09:37 -0700
+Subject: [PATCH 126/149] fpga: dfl: pci: gracefully handle misconfigured port
+ entries
+
+Gracefully ignore misconfigured port entries encountered in
+incorrect FPGA images.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ drivers/fpga/dfl-pci.c | 16 +++++++++++++++-
+ 1 file changed, 15 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/dfl-pci.c b/drivers/fpga/dfl-pci.c
+index b758b39d2157..e999e8d92571 100644
+--- a/drivers/fpga/dfl-pci.c
++++ b/drivers/fpga/dfl-pci.c
+@@ -219,6 +219,7 @@ static int find_dfls_by_default(struct pci_dev *pcidev,
+ 	int port_num, bar, i, ret = 0;
+ 	resource_size_t start, len;
+ 	void __iomem *base;
++	int bars = 0;
+ 	u32 offset;
+ 	u64 v;
+ 
+@@ -235,6 +236,7 @@ static int find_dfls_by_default(struct pci_dev *pcidev,
+ 	if (dfl_feature_is_fme(base)) {
+ 		start = pci_resource_start(pcidev, 0);
+ 		len = pci_resource_len(pcidev, 0);
++		bars |= BIT(0);
+ 
+ 		dfl_fpga_enum_info_add_dfl(info, start, len);
+ 
+@@ -260,9 +262,21 @@ static int find_dfls_by_default(struct pci_dev *pcidev,
+ 			 */
+ 			bar = FIELD_GET(FME_PORT_OFST_BAR_ID, v);
+ 			offset = FIELD_GET(FME_PORT_OFST_DFH_OFST, v);
++			if (bars & BIT(bar)) {
++				dev_warn(&pcidev->dev, "skipping bad port BAR %d\n", bar);
++				continue;
++			}
++
+ 			start = pci_resource_start(pcidev, bar) + offset;
+-			len = pci_resource_len(pcidev, bar) - offset;
++			len = pci_resource_len(pcidev, bar);
++			if (offset >= len) {
++				dev_warn(&pcidev->dev, "bad port offset %u >= %pa\n",
++					 offset, &len);
++				continue;
++			}
+ 
++			len -= offset;
++			bars |= BIT(bar);
+ 			dfl_fpga_enum_info_add_dfl(info, start, len);
+ 		}
+ 	} else if (dfl_feature_is_port(base)) {
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0127-net-ethernet-silicom-Prevent-sprintf-buffer-overflow.patch new/debian/patches/fpga-ofs/0127-net-ethernet-silicom-Prevent-sprintf-buffer-overflow.patch
--- org/debian/patches/fpga-ofs/0127-net-ethernet-silicom-Prevent-sprintf-buffer-overflow.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0127-net-ethernet-silicom-Prevent-sprintf-buffer-overflow.patch	2021-07-20 06:17:11.512844561 +0200
@@ -0,0 +1,63 @@
+From 835e451259eb60c3787142ddce213aa3cc5bade7 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 9 Apr 2021 09:25:56 -0700
+Subject: [PATCH 127/149] net: ethernet: silicom: Prevent sprintf buffer
+ overflow
+
+Static analysis identified three sprintf calls as potential buffer
+overflows. The format string would permit up to 30 characters,
+whereas the buffer only provides 20 characters.
+
+Change these sprintf() instances to the linux kernel standard scnprintf().
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/net/ethernet/silicom/n5010-hssi.c | 12 ++++++++----
+ 1 file changed, 8 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/ethernet/silicom/n5010-hssi.c b/drivers/net/ethernet/silicom/n5010-hssi.c
+index 9627fa9a03fe..d8827d4ce47a 100644
+--- a/drivers/net/ethernet/silicom/n5010-hssi.c
++++ b/drivers/net/ethernet/silicom/n5010-hssi.c
+@@ -379,6 +379,7 @@ struct regmap *devm_regmap_init_indirect_register(struct device *dev,
+ 						  struct regmap_config *cfg);
+ #endif
+ 
++#define REGMAP_NAME_SIZE	20
+ static struct regmap *n5010_hssi_create_regmap(struct n5010_hssi_drvdata *priv,
+ 					       u64 port,
+ 					       enum n5010_hssi_regmap type)
+@@ -386,23 +387,26 @@ static struct regmap *n5010_hssi_create_regmap(struct n5010_hssi_drvdata *priv,
+ 	void __iomem *base = priv->base + port * MB_PORT_SIZE;
+ 	struct device *dev = &priv->dfl_dev->dev;
+ 	struct regmap_config cfg = {0};
+-	char regmap_name[20];
++	char regmap_name[REGMAP_NAME_SIZE];
+ 
+ 	switch (type) {
+ 	case regmap_mac:
+-		sprintf(regmap_name, "n5010_hssi_mac%llu", port);
++		scnprintf(regmap_name, REGMAP_NAME_SIZE,
++			  "n5010_hssi_mac%llu", port);
+ 		base += MB_MAC_OFFSET;
+ 		cfg.val_bits = 32;
+ 		cfg.max_register = 0xbbf;
+ 		break;
+ 	case regmap_fec:
+-		sprintf(regmap_name, "n5010_hssi_fec%llu", port);
++		scnprintf(regmap_name, REGMAP_NAME_SIZE,
++			  "n5010_hssi_fec%llu", port);
+ 		base += MB_FEC_OFFSET;
+ 		cfg.val_bits = 8;
+ 		cfg.max_register = 0x29c;
+ 		break;
+ 	case regmap_phy:
+-		sprintf(regmap_name, "n5010_hssi_phy%llu", port);
++		scnprintf(regmap_name, REGMAP_NAME_SIZE,
++			  "n5010_hssi_phy%llu", port);
+ 		base += MB_PHY_OFFSET;
+ 		cfg.val_bits = 8;
+ 		cfg.max_register = 0x40144;
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0128-fpga-dfl-pci-Add-generic-OFS-PCI-PID.patch new/debian/patches/fpga-ofs/0128-fpga-dfl-pci-Add-generic-OFS-PCI-PID.patch
--- org/debian/patches/fpga-ofs/0128-fpga-dfl-pci-Add-generic-OFS-PCI-PID.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0128-fpga-dfl-pci-Add-generic-OFS-PCI-PID.patch	2021-07-20 06:17:11.512844561 +0200
@@ -0,0 +1,37 @@
+From 9e30b1646584d4c014af06e1f16a05dd4b12208f Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Mon, 19 Apr 2021 10:47:39 -0700
+Subject: [PATCH 128/149] fpga: dfl: pci: Add generic OFS PCI PID
+
+Add the PCI product id for an Open FPGA Stack PCI card.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ drivers/fpga/dfl-pci.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/dfl-pci.c b/drivers/fpga/dfl-pci.c
+index e999e8d92571..7ec4f8e1a23b 100644
+--- a/drivers/fpga/dfl-pci.c
++++ b/drivers/fpga/dfl-pci.c
+@@ -74,7 +74,8 @@ static void cci_pci_free_irq(struct pci_dev *pcidev)
+ #define PCIE_DEVICE_ID_PF_DSC_1_X		0x09C4
+ #define PCIE_DEVICE_ID_INTEL_PAC_N3000		0x0B30
+ #define PCIE_DEVICE_ID_INTEL_PAC_D5005		0x0B2B
+-#define PCIE_DEVCIE_ID_INTEL_OFS		0xaf00
++#define PCIE_DEVCIE_ID_INTEL_AF00		0xaf00
++#define PCIE_DEVCIE_ID_INTEL_OFS		0xbcce
+ #define PCIE_DEVICE_ID_SILICOM_PAC_N5010	0x1000
+ #define PCIE_DEVICE_ID_SILICOM_PAC_N5011	0x1001
+ 
+@@ -94,6 +95,7 @@ static struct pci_device_id cci_pcie_id_tbl[] = {
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_N3000),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_D5005),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVICE_ID_INTEL_PAC_D5005_VF),},
++	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVCIE_ID_INTEL_AF00),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCIE_DEVCIE_ID_INTEL_OFS),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_SILICOM_DENMARK, PCIE_DEVICE_ID_SILICOM_PAC_N5010),},
+ 	{PCI_DEVICE(PCI_VENDOR_ID_SILICOM_DENMARK, PCIE_DEVICE_ID_SILICOM_PAC_N5011),},
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0129-net-intel-s10hssi-use-dfl-dev-in-dev_err.patch new/debian/patches/fpga-ofs/0129-net-intel-s10hssi-use-dfl-dev-in-dev_err.patch
--- org/debian/patches/fpga-ofs/0129-net-intel-s10hssi-use-dfl-dev-in-dev_err.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0129-net-intel-s10hssi-use-dfl-dev-in-dev_err.patch	2021-07-20 06:17:11.512844561 +0200
@@ -0,0 +1,53 @@
+From 5daf6f221c969ce8288d32ae5ba94ed938c54c7d Mon Sep 17 00:00:00 2001
+From: Tom Rix <trix@redhat.com>
+Date: Mon, 3 May 2021 13:31:45 -0700
+Subject: [PATCH 129/149] net: intel: s10hssi: use dfl dev in dev_err
+
+Errors with ethtool_reset() are reported as
+
+[  577.456427]  (null): ethtool_reset failed to clear tx stats
+
+Instead of the netdev->dev, use the dfl_dev->dev
+
+Signed-off-by: Tom Rix <trix@redhat.com>
+---
+ drivers/net/ethernet/intel/s10hssi.c | 7 ++++---
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/net/ethernet/intel/s10hssi.c b/drivers/net/ethernet/intel/s10hssi.c
+index dd36114dec05..4374c5f77d8c 100644
+--- a/drivers/net/ethernet/intel/s10hssi.c
++++ b/drivers/net/ethernet/intel/s10hssi.c
+@@ -299,6 +299,7 @@ static u64 read_mac_stat(struct regmap *regmap, unsigned int addr)
+ static int ethtool_reset(struct net_device *netdev, u32 *flags)
+ {
+ 	struct s10hssi_netdata *npriv = netdev_priv(netdev);
++	struct device *dev = &npriv->dfl_dev->dev;
+ 	int ret;
+ 	u32 val;
+ 
+@@ -310,7 +311,7 @@ static int ethtool_reset(struct net_device *netdev, u32 *flags)
+ 					       STATS_CLR_INT_TIMEOUT_US);
+ 
+ 		if (ret) {
+-			dev_err(&netdev->dev, "%s failed to clear tx stats\n", __func__);
++			dev_err(dev, "%s failed to clear tx stats\n", __func__);
+ 			return ret;
+ 		}
+ 
+@@ -321,10 +322,10 @@ static int ethtool_reset(struct net_device *netdev, u32 *flags)
+ 					       STATS_CLR_INT_TIMEOUT_US);
+ 
+ 		if (ret) {
+-			dev_err(&netdev->dev, "%s failed to clear rx stats\n", __func__);
++			dev_err(dev, "%s failed to clear rx stats\n", __func__);
+ 			return ret;
+ 		}
+-		dev_info(&netdev->dev, "%s reset statistics registers\n", __func__);
++		dev_info(dev, "%s reset statistics registers\n", __func__);
+ 	}
+ 
+ 	return 0;
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0130-MAINTAINERS-Add-entry-for-Intel-MAX-10-mfd-driver.patch new/debian/patches/fpga-ofs/0130-MAINTAINERS-Add-entry-for-Intel-MAX-10-mfd-driver.patch
--- org/debian/patches/fpga-ofs/0130-MAINTAINERS-Add-entry-for-Intel-MAX-10-mfd-driver.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0130-MAINTAINERS-Add-entry-for-Intel-MAX-10-mfd-driver.patch	2021-07-20 06:17:11.520844537 +0200
@@ -0,0 +1,38 @@
+From 77941adf18a1fe05af3daabb9da6c2b04cc7bd58 Mon Sep 17 00:00:00 2001
+From: Xu Yilun <yilun.xu@intel.com>
+Date: Mon, 1 Mar 2021 13:59:45 +0800
+Subject: [PATCH 130/149] MAINTAINERS: Add entry for Intel MAX 10 mfd driver
+
+This patch adds maintainer info for Intel MAX 10 mfd driver.
+
+Signed-off-by: Xu Yilun <yilun.xu@intel.com>
+Reviewed-by: Tom Rix <trix@redhat.com>
+Signed-off-by: Lee Jones <lee.jones@linaro.org>
+---
+ MAINTAINERS | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 4aa1f8b6b05c..b11a5dc1a519 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -8990,6 +8990,16 @@ F:	include/linux/mei_cl_bus.h
+ F:	include/uapi/linux/mei.h
+ F:	samples/mei/*
+ 
++INTEL MAX 10 BMC MFD DRIVER
++M:	Xu Yilun <yilun.xu@intel.com>
++R:	Tom Rix <trix@redhat.com>
++S:	Maintained
++F:	Documentation/ABI/testing/sysfs-driver-intel-m10-bmc
++F:	Documentation/hwmon/intel-m10-bmc-hwmon.rst
++F:	drivers/hwmon/intel-m10-bmc-hwmon.c
++F:	drivers/mfd/intel-m10-bmc.c
++F:	include/linux/mfd/intel-m10-bmc.h
++
+ INTEL MENLOW THERMAL DRIVER
+ M:	Sujith Thomas <sujith.thomas@intel.com>
+ L:	platform-driver-x86@vger.kernel.org
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0131-regmap-set-debugfs_name-to-NULL-after-it-is-freed.patch new/debian/patches/fpga-ofs/0131-regmap-set-debugfs_name-to-NULL-after-it-is-freed.patch
--- org/debian/patches/fpga-ofs/0131-regmap-set-debugfs_name-to-NULL-after-it-is-freed.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0131-regmap-set-debugfs_name-to-NULL-after-it-is-freed.patch	2021-07-20 06:17:11.520844537 +0200
@@ -0,0 +1,40 @@
+From b2239c5ca293f66dd757337437bdc0777567a5fa Mon Sep 17 00:00:00 2001
+From: Meng Li <Meng.Li@windriver.com>
+Date: Fri, 26 Feb 2021 10:17:37 +0800
+Subject: [PATCH 131/149] regmap: set debugfs_name to NULL after it is freed
+
+There is a upstream commit cffa4b2122f5("regmap:debugfs:
+Fix a memory leak when calling regmap_attach_dev") that
+adds a if condition when create name for debugfs_name.
+With below function invoking logical, debugfs_name is
+freed in regmap_debugfs_exit(), but it is not created again
+because of the if condition introduced by above commit.
+regmap_reinit_cache()
+	regmap_debugfs_exit()
+	...
+	regmap_debugfs_init()
+So, set debugfs_name to NULL after it is freed.
+
+Fixes: cffa4b2122f5 ("regmap: debugfs: Fix a memory leak when calling regmap_attach_dev")
+Signed-off-by: Meng Li <Meng.Li@windriver.com>
+Link: https://lore.kernel.org/r/20210226021737.7690-1-Meng.Li@windriver.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/base/regmap/regmap-debugfs.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/drivers/base/regmap/regmap-debugfs.c b/drivers/base/regmap/regmap-debugfs.c
+index ff2ee87987c7..211a335a608d 100644
+--- a/drivers/base/regmap/regmap-debugfs.c
++++ b/drivers/base/regmap/regmap-debugfs.c
+@@ -660,6 +660,7 @@ void regmap_debugfs_exit(struct regmap *map)
+ 		regmap_debugfs_free_dump_cache(map);
+ 		mutex_unlock(&map->cache_lock);
+ 		kfree(map->debugfs_name);
++		map->debugfs_name = NULL;
+ 	} else {
+ 		struct regmap_debugfs_node *node, *tmp;
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0132-mfd-intel-m10-bmc-Rename-m10bmc_bmc_subdevs-to-m10bm.patch new/debian/patches/fpga-ofs/0132-mfd-intel-m10-bmc-Rename-m10bmc_bmc_subdevs-to-m10bm.patch
--- org/debian/patches/fpga-ofs/0132-mfd-intel-m10-bmc-Rename-m10bmc_bmc_subdevs-to-m10bm.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0132-mfd-intel-m10-bmc-Rename-m10bmc_bmc_subdevs-to-m10bm.patch	2021-07-20 06:17:11.524844526 +0200
@@ -0,0 +1,61 @@
+From 85d0e6bc382cddcc8c909695656f7932ab68f0b3 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 14:23:46 -0700
+Subject: [PATCH 132/149] mfd: intel-m10-bmc: Rename m10bmc_bmc_subdevs to
+ m10bmc_d5005_subdevs
+
+Change the name of the m10bmc_bmc_subdevs[] array to m10bmc_d5005_subdevs[].
+A comment is also re-written to match the upstreamed code.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/mfd/intel-m10-bmc.c | 19 +++++++++----------
+ 1 file changed, 9 insertions(+), 10 deletions(-)
+
+diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
+index f5817cdc79e0..09da9e55f4c7 100644
+--- a/drivers/mfd/intel-m10-bmc.c
++++ b/drivers/mfd/intel-m10-bmc.c
+@@ -13,7 +13,7 @@
+ #include <linux/regmap.h>
+ #include <linux/spi/spi.h>
+ 
+-static struct mfd_cell m10bmc_bmc_subdevs[] = {
++static struct mfd_cell m10bmc_d5005_subdevs[] = {
+ 	{ .name = "d5005bmc-hwmon" },
+ 	{ .name = "d5005bmc-secure" }
+ };
+@@ -230,13 +230,12 @@ static int check_m10bmc_version(struct intel_m10bmc *ddata)
+ 	int ret;
+ 
+ 	/*
+-	 * This check is to filter out the very old legacy BMC versions,
+-	 * 0x300400 is the offset to this old block of mmio registers. In the
+-	 * old BMC chips, the BMC version info is stored in this old version
+-	 * register (0x300400 + 0x68), so its read out value would have not
+-	 * been LEGACY_INVALID (0xffffffff). But in new BMC chips that the
+-	 * driver supports, the value of this register should be
+-	 * LEGACY_INVALID.
++	 * This check is to filter out the very old legacy BMC versions. In the
++	 * old BMC chips, the BMC version info is stored in the old version
++	 * register (M10BMC_LEGACY_BUILD_VER), so its read out value would have
++	 * not been M10BMC_VER_LEGACY_INVALID (0xffffffff). But in new BMC
++	 * chips that the driver supports, the value of this register should be
++	 * M10BMC_VER_LEGACY_INVALID.
+ 	 */
+ 	ret = m10bmc_raw_read(ddata, M10BMC_LEGACY_BUILD_VER, &v);
+ 	if (ret)
+@@ -290,8 +289,8 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
+ 			ARRAY_SIZE(n3000_fw_handshake_regs);
+ 		break;
+ 	case M10_D5005:
+-		cells = m10bmc_bmc_subdevs;
+-		n_cell = ARRAY_SIZE(m10bmc_bmc_subdevs);
++		cells = m10bmc_d5005_subdevs;
++		n_cell = ARRAY_SIZE(m10bmc_d5005_subdevs);
+ 		ddata->handshake_sys_reg_ranges = d5005_fw_handshake_regs;
+ 		ddata->handshake_sys_reg_nranges =
+ 			ARRAY_SIZE(d5005_fw_handshake_regs);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0133-fpga-sec-mgr-Do-not-dictate-write_blk-size-in-class-.patch new/debian/patches/fpga-ofs/0133-fpga-sec-mgr-Do-not-dictate-write_blk-size-in-class-.patch
--- org/debian/patches/fpga-ofs/0133-fpga-sec-mgr-Do-not-dictate-write_blk-size-in-class-.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0133-fpga-sec-mgr-Do-not-dictate-write_blk-size-in-class-.patch	2021-07-20 06:17:11.524844526 +0200
@@ -0,0 +1,80 @@
+From 1511342dc2ff02c91443661edef3bfba8ba4d6f0 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 12:08:34 -0700
+Subject: [PATCH 133/149] fpga: sec-mgr: Do not dictate write_blk size in class
+ driver
+
+The write_block op is changed to not pass the size. It is up to the parent
+driver to choose an appropriate block size and update the remaining_size
+accordingly following each block write.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/fpga-sec-mgr.c       | 14 ++++----------
+ include/linux/fpga/fpga-sec-mgr.h |  3 +--
+ 2 files changed, 5 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index edcbf5185510..e2a0a64e035e 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -21,8 +21,6 @@ struct fpga_sec_mgr_devres {
+ 	struct fpga_sec_mgr *smgr;
+ };
+ 
+-#define WRITE_BLOCK_SIZE 0x4000	/* Update remaining_size every 0x4000 bytes */
+-
+ #define to_sec_mgr(d) container_of(d, struct fpga_sec_mgr, dev)
+ 
+ static void update_progress(struct fpga_sec_mgr *smgr,
+@@ -79,10 +77,10 @@ static void progress_complete(struct fpga_sec_mgr *smgr)
+ 
+ static void fpga_sec_mgr_update(struct work_struct *work)
+ {
+-	u32 size, blk_size, offset = 0;
+ 	struct fpga_sec_mgr *smgr;
+ 	const struct firmware *fw;
+ 	enum fpga_sec_err ret;
++	u32 offset = 0;
+ 
+ 	smgr = container_of(work, struct fpga_sec_mgr, work);
+ 
+@@ -112,18 +110,14 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ 	if (progress_transition(smgr, FPGA_SEC_PROG_WRITING))
+ 		goto done;
+ 
+-	size = smgr->remaining_size;
+-	while (size && !smgr->request_cancel) {
+-		blk_size = min_t(u32, size, WRITE_BLOCK_SIZE);
+-		size -= blk_size;
+-		ret = smgr->sops->write_blk(smgr, offset, blk_size);
++	while (smgr->remaining_size && !smgr->request_cancel) {
++		ret = smgr->sops->write_blk(smgr, offset);
+ 		if (ret != FPGA_SEC_ERR_NONE) {
+ 			fpga_sec_dev_error(smgr, ret);
+ 			goto done;
+ 		}
+ 
+-		smgr->remaining_size = size;
+-		offset += blk_size;
++		offset = fw->size - smgr->remaining_size;
+ 	}
+ 
+ 	if (progress_transition(smgr, FPGA_SEC_PROG_PROGRAMMING))
+diff --git a/include/linux/fpga/fpga-sec-mgr.h b/include/linux/fpga/fpga-sec-mgr.h
+index d09ebfe9a170..fa10fcd8c2ec 100644
+--- a/include/linux/fpga/fpga-sec-mgr.h
++++ b/include/linux/fpga/fpga-sec-mgr.h
+@@ -60,8 +60,7 @@ struct image_load {
+  */
+ struct fpga_sec_mgr_ops {
+ 	enum fpga_sec_err (*prepare)(struct fpga_sec_mgr *smgr);
+-	enum fpga_sec_err (*write_blk)(struct fpga_sec_mgr *smgr,
+-				       u32 offset, u32 size);
++	enum fpga_sec_err (*write_blk)(struct fpga_sec_mgr *smgr, u32 offset);
+ 	enum fpga_sec_err (*poll_complete)(struct fpga_sec_mgr *smgr);
+ 	enum fpga_sec_err (*cancel)(struct fpga_sec_mgr *smgr);
+ 	void (*cleanup)(struct fpga_sec_mgr *smgr);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0134-fpga-sec-mgr-Change-error-function-names.patch new/debian/patches/fpga-ofs/0134-fpga-sec-mgr-Change-error-function-names.patch
--- org/debian/patches/fpga-ofs/0134-fpga-sec-mgr-Change-error-function-names.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0134-fpga-sec-mgr-Change-error-function-names.patch	2021-07-20 06:17:11.524844526 +0200
@@ -0,0 +1,74 @@
+From 20c9987f3852f851a7bfafed09f56afaf69ea93a Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 12:14:25 -0700
+Subject: [PATCH 134/149] fpga: sec-mgr: Change error function names
+
+Change set_error() to fpga_sec_set_error()
+Change set_hw_errinfo() to fpga_sec_set_hw_errinfo()
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/fpga-sec-mgr.c | 14 +++++++-------
+ 1 file changed, 7 insertions(+), 7 deletions(-)
+
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index e2a0a64e035e..3d689b8d23cd 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -30,13 +30,13 @@ static void update_progress(struct fpga_sec_mgr *smgr,
+ 	sysfs_notify(&smgr->dev.kobj, "update", "status");
+ }
+ 
+-static void set_error(struct fpga_sec_mgr *smgr, enum fpga_sec_err err_code)
++static void fpga_sec_set_error(struct fpga_sec_mgr *smgr, enum fpga_sec_err err_code)
+ {
+ 	smgr->err_state = smgr->progress;
+ 	smgr->err_code = err_code;
+ }
+ 
+-static void set_hw_errinfo(struct fpga_sec_mgr *smgr)
++static void fpga_sec_set_hw_errinfo(struct fpga_sec_mgr *smgr)
+ {
+ 	if (smgr->sops->get_hw_errinfo)
+ 		smgr->hw_errinfo = smgr->sops->get_hw_errinfo(smgr);
+@@ -45,8 +45,8 @@ static void set_hw_errinfo(struct fpga_sec_mgr *smgr)
+ static void fpga_sec_dev_error(struct fpga_sec_mgr *smgr,
+ 			       enum fpga_sec_err err_code)
+ {
+-	set_error(smgr, err_code);
+-	set_hw_errinfo(smgr);
++	fpga_sec_set_error(smgr, err_code);
++	fpga_sec_set_hw_errinfo(smgr);
+ 	smgr->sops->cancel(smgr);
+ }
+ 
+@@ -57,7 +57,7 @@ static int progress_transition(struct fpga_sec_mgr *smgr,
+ 
+ 	mutex_lock(&smgr->lock);
+ 	if (smgr->request_cancel) {
+-		set_error(smgr, FPGA_SEC_ERR_CANCELED);
++		fpga_sec_set_error(smgr, FPGA_SEC_ERR_CANCELED);
+ 		smgr->sops->cancel(smgr);
+ 		ret = -ECANCELED;
+ 	} else {
+@@ -86,7 +86,7 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ 
+ 	get_device(&smgr->dev);
+ 	if (request_firmware(&fw, smgr->filename, &smgr->dev)) {
+-		set_error(smgr, FPGA_SEC_ERR_FILE_READ);
++		fpga_sec_set_error(smgr, FPGA_SEC_ERR_FILE_READ);
+ 		goto idle_exit;
+ 	}
+ 
+@@ -94,7 +94,7 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ 	smgr->remaining_size = fw->size;
+ 
+ 	if (!try_module_get(smgr->dev.parent->driver->owner)) {
+-		set_error(smgr, FPGA_SEC_ERR_BUSY);
++		fpga_sec_set_error(smgr, FPGA_SEC_ERR_BUSY);
+ 		goto release_fw_exit;
+ 	}
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0135-fpga-sec-mgr-Change-to-more-modern-array-format.patch new/debian/patches/fpga-ofs/0135-fpga-sec-mgr-Change-to-more-modern-array-format.patch
--- org/debian/patches/fpga-ofs/0135-fpga-sec-mgr-Change-to-more-modern-array-format.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0135-fpga-sec-mgr-Change-to-more-modern-array-format.patch	2021-07-20 06:17:11.524844526 +0200
@@ -0,0 +1,66 @@
+From c9a333ef91d0b812e51ea34f4d6f09ca5c33e75e Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 12:24:38 -0700
+Subject: [PATCH 135/149] fpga: sec-mgr: Change to more modern array format
+
+Change the definitions of the sec_mgr_prog_str[] and sec_mgr_err_str[]
+arrays from this syntax:
+
+  static const char * const sec_mgr_prog_str[] = {
+	  "idle",                 /* FPGA_SEC_PROG_IDLE */
+
+to this syntax:
+
+  static const char * const sec_mgr_prog_str[] = {
+	  [FPGA_SEC_PROG_IDLE]        = "idle",
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/fpga-sec-mgr.c | 28 ++++++++++++++--------------
+ 1 file changed, 14 insertions(+), 14 deletions(-)
+
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index 3d689b8d23cd..e451e52bed61 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -151,23 +151,23 @@ static void fpga_sec_mgr_update(struct work_struct *work)
+ }
+ 
+ static const char * const sec_mgr_prog_str[] = {
+-	"idle",			/* FPGA_SEC_PROG_IDLE */
+-	"reading",		/* FPGA_SEC_PROG_READING */
+-	"preparing",		/* FPGA_SEC_PROG_PREPARING */
+-	"writing",		/* FPGA_SEC_PROG_WRITING */
+-	"programming"		/* FPGA_SEC_PROG_PROGRAMMING */
++	[FPGA_SEC_PROG_IDLE]	    = "idle",
++	[FPGA_SEC_PROG_READING]	    = "reading",
++	[FPGA_SEC_PROG_PREPARING]   = "preparing",
++	[FPGA_SEC_PROG_WRITING]	    = "writing",
++	[FPGA_SEC_PROG_PROGRAMMING] = "programming"
+ };
+ 
+ static const char * const sec_mgr_err_str[] = {
+-	"none",			/* FPGA_SEC_ERR_NONE */
+-	"hw-error",		/* FPGA_SEC_ERR_HW_ERROR */
+-	"timeout",		/* FPGA_SEC_ERR_TIMEOUT */
+-	"user-abort",		/* FPGA_SEC_ERR_CANCELED */
+-	"device-busy",		/* FPGA_SEC_ERR_BUSY */
+-	"invalid-file-size",	/* FPGA_SEC_ERR_INVALID_SIZE */
+-	"read-write-error",	/* FPGA_SEC_ERR_RW_ERROR */
+-	"flash-wearout",	/* FPGA_SEC_ERR_WEAROUT */
+-	"file-read-error"	/* FPGA_SEC_ERR_FILE_READ */
++	[FPGA_SEC_ERR_NONE]	    = "none",
++	[FPGA_SEC_ERR_HW_ERROR]	    = "hw-error",
++	[FPGA_SEC_ERR_TIMEOUT]	    = "timeout",
++	[FPGA_SEC_ERR_CANCELED]	    = "user-abort",
++	[FPGA_SEC_ERR_BUSY]	    = "device-busy",
++	[FPGA_SEC_ERR_INVALID_SIZE] = "invalid-file-size",
++	[FPGA_SEC_ERR_RW_ERROR]	    = "read-write-error",
++	[FPGA_SEC_ERR_WEAROUT]	    = "flash-wearout",
++	[FPGA_SEC_ERR_FILE_READ]    = "file-read-error"
+ };
+ 
+ static const char *sec_progress(struct device *dev, enum fpga_sec_prog prog)
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0136-fpga-sec-mgr-Fix-comments-initialization-error-messa.patch new/debian/patches/fpga-ofs/0136-fpga-sec-mgr-Fix-comments-initialization-error-messa.patch
--- org/debian/patches/fpga-ofs/0136-fpga-sec-mgr-Fix-comments-initialization-error-messa.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0136-fpga-sec-mgr-Fix-comments-initialization-error-messa.patch	2021-07-20 06:17:11.524844526 +0200
@@ -0,0 +1,56 @@
+From 92aad1b87db8e6a527b09aa693da2002e8052ba8 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 12:38:50 -0700
+Subject: [PATCH 136/149] fpga: sec-mgr: Fix comments, initialization, error
+ messages
+
+Several minor cleanup items to sync with latest version of the driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/fpga-sec-mgr.c | 8 +++++---
+ 1 file changed, 5 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/fpga/fpga-sec-mgr.c b/drivers/fpga/fpga-sec-mgr.c
+index e451e52bed61..78c64f4d5c67 100644
+--- a/drivers/fpga/fpga-sec-mgr.c
++++ b/drivers/fpga/fpga-sec-mgr.c
+@@ -260,7 +260,7 @@ static ssize_t filename_store(struct device *dev, struct device_attribute *attr,
+ 	struct fpga_sec_mgr *smgr = to_sec_mgr(dev);
+ 	int ret = count;
+ 
+-	if (count == 0 || count >= PATH_MAX)
++	if (!count || count >= PATH_MAX)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&smgr->lock);
+@@ -431,7 +431,7 @@ fpga_sec_mgr_create(struct device *dev, const char *name,
+ 
+ 	if (!sops || !sops->cancel || !sops->prepare ||
+ 	    !sops->write_blk || !sops->poll_complete) {
+-		dev_err(dev, "Attempt to register without required ops\n");
++		dev_err(dev, "Attempt to register without all required ops\n");
+ 		return NULL;
+ 	}
+ 
+@@ -463,6 +463,8 @@ fpga_sec_mgr_create(struct device *dev, const char *name,
+ 	smgr->name = name;
+ 	smgr->priv = priv;
+ 	smgr->sops = sops;
++	smgr->err_code = FPGA_SEC_ERR_NONE;
++	smgr->progress = FPGA_SEC_PROG_IDLE;
+ 	init_completion(&smgr->update_done);
+ 	INIT_WORK(&smgr->work, fpga_sec_mgr_update);
+ 
+@@ -586,7 +588,7 @@ EXPORT_SYMBOL_GPL(fpga_sec_mgr_register);
+  * For some devices, once the secure update has begun authentication
+  * the hardware cannot be signaled to stop, and the driver will not
+  * exit until the hardware signals completion.  This could be 30+
+- * minutes of waiting. The driver_unload flag enableds a force-unload
++ * minutes of waiting. The driver_unload flag enables a force-unload
+  * of the driver (e.g. modprobe -r) by signaling the parent driver to
+  * exit even if the hardware update is incomplete. The driver_unload
+  * flag also prevents new updates from starting once the unregister
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0137-fpga-m10bmc-sec-Change-m10bmc_sec_write_blk-paramete.patch new/debian/patches/fpga-ofs/0137-fpga-m10bmc-sec-Change-m10bmc_sec_write_blk-paramete.patch
--- org/debian/patches/fpga-ofs/0137-fpga-m10bmc-sec-Change-m10bmc_sec_write_blk-paramete.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0137-fpga-m10bmc-sec-Change-m10bmc_sec_write_blk-paramete.patch	2021-07-20 06:17:11.524844526 +0200
@@ -0,0 +1,58 @@
+From b41871db0b70e97291e03fa720ef83d3ac2bff94 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 12:45:04 -0700
+Subject: [PATCH 137/149] fpga: m10bmc-sec: Change m10bmc_sec_write_blk
+ parameters
+
+The write_blk op no longer takes a size parameter. It is now up to the
+parent driver (this driver) to determine the appropriate block size.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/intel-m10-bmc-secure.c | 15 +++++++++++----
+ 1 file changed, 11 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
+index 5b4dd7288211..1b66b5ec0872 100644
+--- a/drivers/fpga/intel-m10-bmc-secure.c
++++ b/drivers/fpga/intel-m10-bmc-secure.c
+@@ -395,12 +395,14 @@ static enum fpga_sec_err m10bmc_sec_prepare(struct fpga_sec_mgr *smgr)
+ 	return ret;
+ }
+ 
++#define WRITE_BLOCK_SIZE 0x4000 /* Update remaining_size every 0x4000 bytes */
++
+ static enum fpga_sec_err
+-m10bmc_sec_write_blk(struct fpga_sec_mgr *smgr, u32 offset, u32 size)
++m10bmc_sec_write_blk(struct fpga_sec_mgr *smgr, u32 offset)
+ {
+ 	struct m10bmc_sec *sec = smgr->priv;
+ 	unsigned int stride = regmap_get_reg_stride(sec->m10bmc->regmap);
+-	u32 doorbell;
++	u32 doorbell, blk_size;
+ 	int ret;
+ 
+ 	ret = m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, &doorbell);
+@@ -411,12 +413,17 @@ m10bmc_sec_write_blk(struct fpga_sec_mgr *smgr, u32 offset, u32 size)
+ 		return FPGA_SEC_ERR_HW_ERROR;
+ 	}
+ 
++	blk_size = min_t(u32, smgr->remaining_size, WRITE_BLOCK_SIZE);
+ 	ret = regmap_bulk_write(sec->m10bmc->regmap,
+ 				M10BMC_STAGING_BASE + offset,
+ 				(void *)smgr->data + offset,
+-				(size + stride - 1) / stride);
++				(blk_size + stride - 1) / stride);
+ 
+-	return ret ? FPGA_SEC_ERR_RW_ERROR : FPGA_SEC_ERR_NONE;
++	if (ret)
++		return FPGA_SEC_ERR_RW_ERROR;
++
++	smgr->remaining_size -= blk_size;
++	return FPGA_SEC_ERR_NONE;
+ }
+ 
+ /*
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0138-Revert-fpga-dfl-spi-altera-support-n1050-feature-rev.patch new/debian/patches/fpga-ofs/0138-Revert-fpga-dfl-spi-altera-support-n1050-feature-rev.patch
--- org/debian/patches/fpga-ofs/0138-Revert-fpga-dfl-spi-altera-support-n1050-feature-rev.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0138-Revert-fpga-dfl-spi-altera-support-n1050-feature-rev.patch	2021-07-20 06:17:11.524844526 +0200
@@ -0,0 +1,68 @@
+From 74bb603d6cb875617e7e3648dd30e7c860d95856 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 13:43:07 -0700
+Subject: [PATCH 138/149] Revert "fpga: dfl-spi-altera: support n1050 feature
+ revision"
+
+This reverts commit b1898ad47ef048c4d98cc96da98add0b8e11543f.
+To be replaced with the latest version of the driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl-spi-altera.c | 19 +++----------------
+ 1 file changed, 3 insertions(+), 16 deletions(-)
+
+diff --git a/drivers/fpga/dfl-spi-altera.c b/drivers/fpga/dfl-spi-altera.c
+index 50a3d0ef4771..8ddfc5d5e2ba 100644
+--- a/drivers/fpga/dfl-spi-altera.c
++++ b/drivers/fpga/dfl-spi-altera.c
+@@ -22,11 +22,6 @@
+ #include <linux/spi/altera.h>
+ #include <linux/dfl.h>
+ 
+-#include "dfl.h"
+-
+-#define FME_FEATURE_ID_MAX10_SPI	0xe
+-#define FME_FEATURE_REV_MAX10_SPI_N5010	0x1
+-
+ struct dfl_altera_spi {
+ 	void __iomem *base;
+ 	struct regmap *regmap;
+@@ -122,13 +117,6 @@ static struct spi_board_info m10_bmc_info = {
+ 	.chip_select = 0,
+ };
+ 
+-static struct spi_board_info m10_n5010_bmc_info = {
+-	.modalias = "m10-n5010",
+-	.max_speed_hz = 12500000,
+-	.bus_num = 0,
+-	.chip_select = 0,
+-};
+-
+ static struct platform_device *create_cntrl(struct device *dev,
+ 					    void __iomem *base,
+ 					    struct spi_board_info *m10_info)
+@@ -192,10 +180,7 @@ static int dfl_spi_altera_probe(struct dfl_device *dfl_dev)
+ 	if (IS_ERR(aspi->regmap))
+ 		return PTR_ERR(aspi->regmap);
+ 
+-	if (dfl_feature_revision(aspi->base) == FME_FEATURE_REV_MAX10_SPI_N5010)
+-		aspi->altr_spi = create_cntrl(dev, aspi->base, &m10_n5010_bmc_info);
+-	else
+-		aspi->altr_spi = create_cntrl(dev, aspi->base, &m10_bmc_info);
++	aspi->altr_spi = create_cntrl(dev, aspi->base, &m10_bmc_info);
+ 
+ 	if (IS_ERR(aspi->altr_spi)) {
+ 		dev_err(dev, "%s failed to create spi platform driver\n",
+@@ -213,6 +198,8 @@ static void dfl_spi_altera_remove(struct dfl_device *dfl_dev)
+ 	platform_device_unregister(aspi->altr_spi);
+ }
+ 
++#define FME_FEATURE_ID_MAX10_SPI        0xe
++
+ static const struct dfl_device_id dfl_spi_altera_ids[] = {
+ 	{ FME_ID, FME_FEATURE_ID_MAX10_SPI },
+ 	{ }
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0139-Revert-drivers-fpga-dfl-spi-altera-Fix-format-string.patch new/debian/patches/fpga-ofs/0139-Revert-drivers-fpga-dfl-spi-altera-Fix-format-string.patch
--- org/debian/patches/fpga-ofs/0139-Revert-drivers-fpga-dfl-spi-altera-Fix-format-string.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0139-Revert-drivers-fpga-dfl-spi-altera-Fix-format-string.patch	2021-07-20 06:17:11.528844515 +0200
@@ -0,0 +1,30 @@
+From 1c3df70c7530323508c2410968f1273096c40be2 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 13:43:55 -0700
+Subject: [PATCH 139/149] Revert "drivers: fpga: dfl-spi-altera: Fix format
+ string"
+
+This reverts commit 6a0fe60567db2ee03199af368a08e2ef2a813262.
+To be replaced with the latest version of the driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl-spi-altera.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/fpga/dfl-spi-altera.c b/drivers/fpga/dfl-spi-altera.c
+index 8ddfc5d5e2ba..21223d7437a2 100644
+--- a/drivers/fpga/dfl-spi-altera.c
++++ b/drivers/fpga/dfl-spi-altera.c
+@@ -141,7 +141,7 @@ static struct platform_device *create_cntrl(struct device *dev,
+ 	pdata.num_devices = 1;
+ 	pdata.devices = m10_info;
+ 
+-	dev_dbg(dev, "%s cs %u bpm 0x%x mode 0x%x\n", __func__,
++	dev_dbg(dev, "%s cs %hu bpm 0x%x mode 0x%hx\n", __func__,
+ 		pdata.num_chipselect, pdata.bits_per_word_mask,
+ 		pdata.mode_bits);
+ 
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0140-Revert-drivers-fpga-dfl-spi-altera-enable-regmap-deb.patch new/debian/patches/fpga-ofs/0140-Revert-drivers-fpga-dfl-spi-altera-enable-regmap-deb.patch
--- org/debian/patches/fpga-ofs/0140-Revert-drivers-fpga-dfl-spi-altera-enable-regmap-deb.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0140-Revert-drivers-fpga-dfl-spi-altera-enable-regmap-deb.patch	2021-07-20 06:17:11.528844515 +0200
@@ -0,0 +1,29 @@
+From 42843d3d49df0df35c716e4e801f5b4e5a9cb587 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 13:44:32 -0700
+Subject: [PATCH 140/149] Revert "drivers: fpga: dfl-spi-altera: enable regmap
+ debugfs"
+
+This reverts commit 287dcf7e3b41f9ffc22709b66601d6b5e149b016.
+To be replaced with the latest version of the driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/dfl-spi-altera.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/drivers/fpga/dfl-spi-altera.c b/drivers/fpga/dfl-spi-altera.c
+index 21223d7437a2..b21c344d596f 100644
+--- a/drivers/fpga/dfl-spi-altera.c
++++ b/drivers/fpga/dfl-spi-altera.c
+@@ -104,7 +104,6 @@ static const struct regmap_config indirect_regbus_cfg = {
+ 	.reg_stride = 4,
+ 	.val_bits = 32,
+ 	.fast_io = true,
+-	.max_register = 24,
+ 
+ 	.reg_write = indirect_bus_reg_write,
+ 	.reg_read = indirect_bus_reg_read,
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0141-Revert-fpga-dfl-Add-DFL-bus-driver-for-Altera-SPI-Ma.patch new/debian/patches/fpga-ofs/0141-Revert-fpga-dfl-Add-DFL-bus-driver-for-Altera-SPI-Ma.patch
--- org/debian/patches/fpga-ofs/0141-Revert-fpga-dfl-Add-DFL-bus-driver-for-Altera-SPI-Ma.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0141-Revert-fpga-dfl-Add-DFL-bus-driver-for-Altera-SPI-Ma.patch	2021-07-20 06:17:11.528844515 +0200
@@ -0,0 +1,279 @@
+From 07211ea32e8b57e9f5f57ae7aadf73afd59e8936 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 13:47:25 -0700
+Subject: [PATCH 141/149] Revert "fpga: dfl: Add DFL bus driver for Altera SPI
+ Master"
+
+This reverts commit 504088d3a6fea6608897f499ded5539a7c44358f.
+To be replaced with the latest version of the driver.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/fpga/Kconfig          |   9 --
+ drivers/fpga/Makefile         |   1 -
+ drivers/fpga/dfl-spi-altera.c | 221 ----------------------------------
+ 3 files changed, 231 deletions(-)
+ delete mode 100644 drivers/fpga/dfl-spi-altera.c
+
+diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
+index 2adbc71db5c8..1a72af404fc9 100644
+--- a/drivers/fpga/Kconfig
++++ b/drivers/fpga/Kconfig
+@@ -203,15 +203,6 @@ config FPGA_DFL_NIOS_INTEL_PAC_N3000
+ 	  the card. It also instantiates the SPI master (spi-altera) for
+ 	  the card's BMC (Board Management Controller).
+ 
+-config FPGA_DFL_SPI_ALTERA
+-	tristate "FPGA DFL Altera SPI Master Driver"
+-	depends on FPGA_DFL
+-	select REGMAP
+-	help
+-	  This is a DFL bus driver for the Altera SPI master controller.
+-	  The SPI master is connected to a SPI slave to Avalon Master
+-	  bridge in a Intel MAX BMC.
+-
+ config FPGA_DFL_PCI
+ 	tristate "FPGA DFL PCIe Device Driver"
+ 	depends on PCI && FPGA_DFL
+diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
+index 1a5dfd668ad4..86db58a540b7 100644
+--- a/drivers/fpga/Makefile
++++ b/drivers/fpga/Makefile
+@@ -51,7 +51,6 @@ dfl-afu-objs := dfl-afu-main.o dfl-afu-region.o dfl-afu-dma-region.o
+ dfl-afu-objs += dfl-afu-error.o
+ 
+ obj-$(CONFIG_FPGA_DFL_NIOS_INTEL_PAC_N3000)	+= dfl-n3000-nios.o
+-obj-$(CONFIG_FPGA_DFL_SPI_ALTERA)	+= dfl-spi-altera.o
+ 
+ # Drivers for FPGAs which implement DFL
+ obj-$(CONFIG_FPGA_DFL_PCI)		+= dfl-pci.o
+diff --git a/drivers/fpga/dfl-spi-altera.c b/drivers/fpga/dfl-spi-altera.c
+deleted file mode 100644
+index b21c344d596f..000000000000
+--- a/drivers/fpga/dfl-spi-altera.c
++++ /dev/null
+@@ -1,221 +0,0 @@
+-// SPDX-License-Identifier: GPL-2.0
+-/*
+- * DFL bus driver for Altera SPI Master
+- *
+- * Copyright (C) 2020 Intel Corporation, Inc.
+- *
+- * Authors:
+- *   Matthew Gerlach <matthew.gerlach@linux.intel.com>
+- */
+-
+-#include <linux/types.h>
+-#include <linux/kernel.h>
+-#include <linux/module.h>
+-#include <linux/stddef.h>
+-#include <linux/errno.h>
+-#include <linux/platform_device.h>
+-#include <linux/io.h>
+-#include <linux/bitfield.h>
+-#include <linux/io-64-nonatomic-lo-hi.h>
+-#include <linux/regmap.h>
+-#include <linux/spi/spi.h>
+-#include <linux/spi/altera.h>
+-#include <linux/dfl.h>
+-
+-struct dfl_altera_spi {
+-	void __iomem *base;
+-	struct regmap *regmap;
+-	struct device *dev;
+-	struct platform_device *altr_spi;
+-};
+-
+-#define SPI_CORE_PARAMETER      0x8
+-#define SHIFT_MODE              BIT_ULL(1)
+-#define SHIFT_MODE_MSB          0
+-#define SHIFT_MODE_LSB          1
+-#define DATA_WIDTH              GENMASK_ULL(7, 2)
+-#define NUM_CHIPSELECT          GENMASK_ULL(13, 8)
+-#define CLK_POLARITY            BIT_ULL(14)
+-#define CLK_PHASE               BIT_ULL(15)
+-#define PERIPHERAL_ID           GENMASK_ULL(47, 32)
+-#define SPI_CLK                 GENMASK_ULL(31, 22)
+-#define SPI_INDIRECT_ACC_OFST   0x10
+-
+-#define INDIRECT_ADDR           (SPI_INDIRECT_ACC_OFST+0x0)
+-#define INDIRECT_WR             BIT_ULL(8)
+-#define INDIRECT_RD             BIT_ULL(9)
+-#define INDIRECT_RD_DATA        (SPI_INDIRECT_ACC_OFST+0x8)
+-#define INDIRECT_DATA_MASK      GENMASK_ULL(31, 0)
+-#define INDIRECT_DEBUG          BIT_ULL(32)
+-#define INDIRECT_WR_DATA        (SPI_INDIRECT_ACC_OFST+0x10)
+-#define INDIRECT_TIMEOUT        10000
+-
+-static int indirect_bus_reg_read(void *context, unsigned int reg,
+-				 unsigned int *val)
+-{
+-	struct dfl_altera_spi *aspi = context;
+-	void __iomem *base = aspi->base;
+-	int loops;
+-	u64 v;
+-
+-	writeq((reg >> 2) | INDIRECT_RD, base + INDIRECT_ADDR);
+-
+-	loops = 0;
+-	while ((readq(base + INDIRECT_ADDR) & INDIRECT_RD) &&
+-	       (loops++ < INDIRECT_TIMEOUT))
+-		cpu_relax();
+-
+-	if (loops >= INDIRECT_TIMEOUT) {
+-		pr_err("%s timed out %d\n", __func__, loops);
+-		return -ETIME;
+-	}
+-
+-	v = readq(base + INDIRECT_RD_DATA);
+-
+-	*val = v & INDIRECT_DATA_MASK;
+-
+-	return 0;
+-}
+-
+-static int indirect_bus_reg_write(void *context, unsigned int reg,
+-				  unsigned int val)
+-{
+-	struct dfl_altera_spi *aspi = context;
+-	void __iomem *base = aspi->base;
+-	int loops;
+-
+-	writeq(val, base + INDIRECT_WR_DATA);
+-	writeq((reg >> 2) | INDIRECT_WR, base + INDIRECT_ADDR);
+-
+-	loops = 0;
+-	while ((readq(base + INDIRECT_ADDR) & INDIRECT_WR) &&
+-	       (loops++ < INDIRECT_TIMEOUT))
+-		cpu_relax();
+-
+-	if (loops >= INDIRECT_TIMEOUT) {
+-		pr_err("%s timed out %d\n", __func__, loops);
+-		return -ETIME;
+-	}
+-	return 0;
+-}
+-
+-static const struct regmap_config indirect_regbus_cfg = {
+-	.reg_bits = 32,
+-	.reg_stride = 4,
+-	.val_bits = 32,
+-	.fast_io = true,
+-
+-	.reg_write = indirect_bus_reg_write,
+-	.reg_read = indirect_bus_reg_read,
+-};
+-
+-static struct spi_board_info m10_bmc_info = {
+-	.modalias = "m10-d5005",
+-	.max_speed_hz = 12500000,
+-	.bus_num = 0,
+-	.chip_select = 0,
+-};
+-
+-static struct platform_device *create_cntrl(struct device *dev,
+-					    void __iomem *base,
+-					    struct spi_board_info *m10_info)
+-{
+-	struct altera_spi_platform_data pdata;
+-	struct platform_device_info pdevinfo;
+-	u64 v;
+-
+-	v = readq(base + SPI_CORE_PARAMETER);
+-
+-	memset(&pdata, 0, sizeof(pdata));
+-	pdata.mode_bits = SPI_CS_HIGH;
+-	if (FIELD_GET(CLK_POLARITY, v))
+-		pdata.mode_bits |= SPI_CPOL;
+-	if (FIELD_GET(CLK_PHASE, v))
+-		pdata.mode_bits |= SPI_CPHA;
+-
+-	pdata.num_chipselect = FIELD_GET(NUM_CHIPSELECT, v);
+-	pdata.bits_per_word_mask =
+-		SPI_BPW_RANGE_MASK(1, FIELD_GET(DATA_WIDTH, v));
+-
+-	pdata.num_devices = 1;
+-	pdata.devices = m10_info;
+-
+-	dev_dbg(dev, "%s cs %hu bpm 0x%x mode 0x%hx\n", __func__,
+-		pdata.num_chipselect, pdata.bits_per_word_mask,
+-		pdata.mode_bits);
+-
+-	memset(&pdevinfo, 0, sizeof(pdevinfo));
+-
+-	pdevinfo.name = "subdev_spi_altera";
+-	pdevinfo.id = PLATFORM_DEVID_AUTO;
+-	pdevinfo.parent = dev;
+-	pdevinfo.data = &pdata;
+-	pdevinfo.size_data = sizeof(pdata);
+-
+-	return platform_device_register_full(&pdevinfo);
+-}
+-static int dfl_spi_altera_probe(struct dfl_device *dfl_dev)
+-{
+-	struct device *dev = &dfl_dev->dev;
+-	struct dfl_altera_spi *aspi;
+-
+-	aspi = devm_kzalloc(dev, sizeof(*aspi), GFP_KERNEL);
+-
+-	if (!aspi)
+-		return -ENOMEM;
+-
+-	dev_set_drvdata(dev, aspi);
+-
+-	aspi->dev = dev;
+-
+-	aspi->base = devm_ioremap_resource(dev, &dfl_dev->mmio_res);
+-
+-	if (IS_ERR(aspi->base)) {
+-		dev_err(dev, "%s get mem resource fail!\n", __func__);
+-		return PTR_ERR(aspi->base);
+-	}
+-
+-	aspi->regmap = devm_regmap_init(dev, NULL, aspi, &indirect_regbus_cfg);
+-	if (IS_ERR(aspi->regmap))
+-		return PTR_ERR(aspi->regmap);
+-
+-	aspi->altr_spi = create_cntrl(dev, aspi->base, &m10_bmc_info);
+-
+-	if (IS_ERR(aspi->altr_spi)) {
+-		dev_err(dev, "%s failed to create spi platform driver\n",
+-			__func__);
+-		return PTR_ERR(aspi->base);
+-	}
+-
+-	return 0;
+-}
+-
+-static void dfl_spi_altera_remove(struct dfl_device *dfl_dev)
+-{
+-	struct dfl_altera_spi *aspi = dev_get_drvdata(&dfl_dev->dev);
+-
+-	platform_device_unregister(aspi->altr_spi);
+-}
+-
+-#define FME_FEATURE_ID_MAX10_SPI        0xe
+-
+-static const struct dfl_device_id dfl_spi_altera_ids[] = {
+-	{ FME_ID, FME_FEATURE_ID_MAX10_SPI },
+-	{ }
+-};
+-
+-static struct dfl_driver dfl_spi_altera_driver = {
+-	.drv	= {
+-		.name       = "dfl-spi-altera",
+-	},
+-	.id_table = dfl_spi_altera_ids,
+-	.probe   = dfl_spi_altera_probe,
+-	.remove  = dfl_spi_altera_remove,
+-};
+-
+-module_dfl_driver(dfl_spi_altera_driver);
+-
+-MODULE_DEVICE_TABLE(dfl, dfl_spi_altera_ids);
+-MODULE_DESCRIPTION("DFL spi altera driver");
+-MODULE_AUTHOR("Intel Corporation");
+-MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0142-spi-altera-separate-core-code-from-platform-code.patch new/debian/patches/fpga-ofs/0142-spi-altera-separate-core-code-from-platform-code.patch
--- org/debian/patches/fpga-ofs/0142-spi-altera-separate-core-code-from-platform-code.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0142-spi-altera-separate-core-code-from-platform-code.patch	2021-07-20 06:17:11.528844515 +0200
@@ -0,0 +1,497 @@
+From f691cff9bcbb3201577ac471abd4b304975d8b36 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Fri, 16 Apr 2021 09:57:19 -0700
+Subject: [PATCH 142/149] spi: altera: separate core code from platform code
+
+In preparation of adding support for a new bus type,
+separate the core spi-altera code from the platform
+driver code.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Link: https://lore.kernel.org/r/20210416165720.554144-2-matthew.gerlach@linux.intel.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/Kconfig                           |   9 +-
+ drivers/spi/Makefile                          |   3 +-
+ .../spi/{spi-altera.c => spi-altera-core.c}   | 166 +----------------
+ drivers/spi/spi-altera-platform.c             | 172 ++++++++++++++++++
+ include/linux/spi/altera.h                    |  21 +++
+ 5 files changed, 208 insertions(+), 163 deletions(-)
+ rename drivers/spi/{spi-altera.c => spi-altera-core.c} (56%)
+ create mode 100644 drivers/spi/spi-altera-platform.c
+
+diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
+index aadaea052f51..40ae5baad957 100644
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -58,11 +58,18 @@ config SPI_MEM
+ comment "SPI Master Controller Drivers"
+ 
+ config SPI_ALTERA
+-	tristate "Altera SPI Controller"
++	tristate "Altera SPI Controller platform driver"
++	select SPI_ALTERA_CORE
+ 	select REGMAP_MMIO
+ 	help
+ 	  This is the driver for the Altera SPI Controller.
+ 
++config SPI_ALTERA_CORE
++	tristate "Altera SPI Controller core code"
++	select REGMAP
++	help
++	  "The core code for the Altera SPI Controller"
++
+ config SPI_AR934X
+ 	tristate "Qualcomm Atheros AR934X/QCA95XX SPI controller driver"
+ 	depends on ATH79 || COMPILE_TEST
+diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
+index 6fea5821662e..be575c6f76ad 100644
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -14,7 +14,8 @@ obj-$(CONFIG_SPI_SPIDEV)		+= spidev.o
+ obj-$(CONFIG_SPI_LOOPBACK_TEST)		+= spi-loopback-test.o
+ 
+ # SPI master controller drivers (bus)
+-obj-$(CONFIG_SPI_ALTERA)		+= spi-altera.o
++obj-$(CONFIG_SPI_ALTERA)		+= spi-altera-platform.o
++obj-$(CONFIG_SPI_ALTERA_CORE)		+= spi-altera-core.o
+ obj-$(CONFIG_SPI_AR934X)		+= spi-ar934x.o
+ obj-$(CONFIG_SPI_ARMADA_3700)		+= spi-armada-3700.o
+ obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
+diff --git a/drivers/spi/spi-altera.c b/drivers/spi/spi-altera-core.c
+similarity index 56%
+rename from drivers/spi/spi-altera.c
+rename to drivers/spi/spi-altera-core.c
+index 62ea0c9e321b..de4d31c530d9 100644
+--- a/drivers/spi/spi-altera.c
++++ b/drivers/spi/spi-altera-core.c
+@@ -10,7 +10,6 @@
+  *	Ben Dooks <ben@simtec.co.uk>
+  */
+ 
+-#include <linux/interrupt.h>
+ #include <linux/errno.h>
+ #include <linux/module.h>
+ #include <linux/platform_device.h>
+@@ -41,36 +40,6 @@
+ #define ALTERA_SPI_CONTROL_IE_MSK	0x100
+ #define ALTERA_SPI_CONTROL_SSO_MSK	0x400
+ 
+-#define ALTERA_SPI_MAX_CS		32
+-
+-enum altera_spi_type {
+-	ALTERA_SPI_TYPE_UNKNOWN,
+-	ALTERA_SPI_TYPE_SUBDEV,
+-};
+-
+-struct altera_spi {
+-	int irq;
+-	int len;
+-	int count;
+-	int bytes_per_word;
+-	u32 imr;
+-
+-	/* data buffers */
+-	const unsigned char *tx;
+-	unsigned char *rx;
+-
+-	struct regmap *regmap;
+-	u32 regoff;
+-	struct device *dev;
+-};
+-
+-static const struct regmap_config spi_altera_config = {
+-	.reg_bits = 32,
+-	.reg_stride = 4,
+-	.val_bits = 32,
+-	.fast_io = true,
+-};
+-
+ static int altr_spi_writel(struct altera_spi *hw, unsigned int reg,
+ 			   unsigned int val)
+ {
+@@ -211,7 +180,7 @@ static int altera_spi_txrx(struct spi_master *master,
+ 	return 0;
+ }
+ 
+-static irqreturn_t altera_spi_irq(int irq, void *dev)
++irqreturn_t altera_spi_irq(int irq, void *dev)
+ {
+ 	struct spi_master *master = dev;
+ 	struct altera_spi *hw = spi_master_get_devdata(master);
+@@ -230,84 +199,16 @@ static irqreturn_t altera_spi_irq(int irq, void *dev)
+ 
+ 	return IRQ_HANDLED;
+ }
++EXPORT_SYMBOL_GPL(altera_spi_irq);
+ 
+-static int altera_spi_probe(struct platform_device *pdev)
++void altera_spi_init_master(struct spi_master *master)
+ {
+-	const struct platform_device_id *platid = platform_get_device_id(pdev);
+-	struct altera_spi_platform_data *pdata = dev_get_platdata(&pdev->dev);
+-	enum altera_spi_type type = ALTERA_SPI_TYPE_UNKNOWN;
+-	struct altera_spi *hw;
+-	struct spi_master *master;
+-	int err = -ENODEV;
++	struct altera_spi *hw = spi_master_get_devdata(master);
+ 	u32 val;
+-	u16 i;
+-
+-	master = spi_alloc_master(&pdev->dev, sizeof(struct altera_spi));
+-	if (!master)
+-		return err;
+-
+-	/* setup the master state. */
+-	master->bus_num = pdev->id;
+-
+-	if (pdata) {
+-		if (pdata->num_chipselect > ALTERA_SPI_MAX_CS) {
+-			dev_err(&pdev->dev,
+-				"Invalid number of chipselect: %hu\n",
+-				pdata->num_chipselect);
+-			err = -EINVAL;
+-			goto exit;
+-		}
+ 
+-		master->num_chipselect = pdata->num_chipselect;
+-		master->mode_bits = pdata->mode_bits;
+-		master->bits_per_word_mask = pdata->bits_per_word_mask;
+-	} else {
+-		master->num_chipselect = 16;
+-		master->mode_bits = SPI_CS_HIGH;
+-		master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 16);
+-	}
+-
+-	master->dev.of_node = pdev->dev.of_node;
+ 	master->transfer_one = altera_spi_txrx;
+ 	master->set_cs = altera_spi_set_cs;
+ 
+-	hw = spi_master_get_devdata(master);
+-	hw->dev = &pdev->dev;
+-
+-	if (platid)
+-		type = platid->driver_data;
+-
+-	/* find and map our resources */
+-	if (type == ALTERA_SPI_TYPE_SUBDEV) {
+-		struct resource *regoff;
+-
+-		hw->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+-		if (!hw->regmap) {
+-			dev_err(&pdev->dev, "get regmap failed\n");
+-			goto exit;
+-		}
+-
+-		regoff = platform_get_resource(pdev, IORESOURCE_REG, 0);
+-		if (regoff)
+-			hw->regoff = regoff->start;
+-	} else {
+-		void __iomem *res;
+-
+-		res = devm_platform_ioremap_resource(pdev, 0);
+-		if (IS_ERR(res)) {
+-			err = PTR_ERR(res);
+-			goto exit;
+-		}
+-
+-		hw->regmap = devm_regmap_init_mmio(&pdev->dev, res,
+-						   &spi_altera_config);
+-		if (IS_ERR(hw->regmap)) {
+-			dev_err(&pdev->dev, "regmap mmio init failed\n");
+-			err = PTR_ERR(hw->regmap);
+-			goto exit;
+-		}
+-	}
+-
+ 	/* program defaults into the registers */
+ 	hw->imr = 0;		/* disable spi interrupts */
+ 	altr_spi_writel(hw, ALTERA_SPI_CONTROL, hw->imr);
+@@ -315,64 +216,7 @@ static int altera_spi_probe(struct platform_device *pdev)
+ 	altr_spi_readl(hw, ALTERA_SPI_STATUS, &val);
+ 	if (val & ALTERA_SPI_STATUS_RRDY_MSK)
+ 		altr_spi_readl(hw, ALTERA_SPI_RXDATA, &val); /* flush rxdata */
+-	/* irq is optional */
+-	hw->irq = platform_get_irq(pdev, 0);
+-	if (hw->irq >= 0) {
+-		err = devm_request_irq(&pdev->dev, hw->irq, altera_spi_irq, 0,
+-				       pdev->name, master);
+-		if (err)
+-			goto exit;
+-	}
+-
+-	err = devm_spi_register_master(&pdev->dev, master);
+-	if (err)
+-		goto exit;
+-
+-	if (pdata) {
+-		for (i = 0; i < pdata->num_devices; i++) {
+-			if (!spi_new_device(master, pdata->devices + i))
+-				dev_warn(&pdev->dev,
+-					 "unable to create SPI device: %s\n",
+-					 pdata->devices[i].modalias);
+-		}
+-	}
+-
+-	dev_info(&pdev->dev, "regoff %u, irq %d\n", hw->regoff, hw->irq);
+-
+-	return 0;
+-exit:
+-	spi_master_put(master);
+-	return err;
+ }
++EXPORT_SYMBOL_GPL(altera_spi_init_master);
+ 
+-#ifdef CONFIG_OF
+-static const struct of_device_id altera_spi_match[] = {
+-	{ .compatible = "ALTR,spi-1.0", },
+-	{ .compatible = "altr,spi-1.0", },
+-	{},
+-};
+-MODULE_DEVICE_TABLE(of, altera_spi_match);
+-#endif /* CONFIG_OF */
+-
+-static const struct platform_device_id altera_spi_ids[] = {
+-	{ DRV_NAME,		ALTERA_SPI_TYPE_UNKNOWN },
+-	{ "subdev_spi_altera",	ALTERA_SPI_TYPE_SUBDEV },
+-	{ }
+-};
+-MODULE_DEVICE_TABLE(platform, altera_spi_ids);
+-
+-static struct platform_driver altera_spi_driver = {
+-	.probe = altera_spi_probe,
+-	.driver = {
+-		.name = DRV_NAME,
+-		.pm = NULL,
+-		.of_match_table = of_match_ptr(altera_spi_match),
+-	},
+-	.id_table	= altera_spi_ids,
+-};
+-module_platform_driver(altera_spi_driver);
+-
+-MODULE_DESCRIPTION("Altera SPI driver");
+-MODULE_AUTHOR("Thomas Chou <thomas@wytron.com.tw>");
+ MODULE_LICENSE("GPL");
+-MODULE_ALIAS("platform:" DRV_NAME);
+diff --git a/drivers/spi/spi-altera-platform.c b/drivers/spi/spi-altera-platform.c
+new file mode 100644
+index 000000000000..f7a7c14e3679
+--- /dev/null
++++ b/drivers/spi/spi-altera-platform.c
+@@ -0,0 +1,172 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ * Altera SPI driver
++ *
++ * Copyright (C) 2008 Thomas Chou <thomas@wytron.com.tw>
++ *
++ * Based on spi_s3c24xx.c, which is:
++ * Copyright (c) 2006 Ben Dooks
++ * Copyright (c) 2006 Simtec Electronics
++ *	Ben Dooks <ben@simtec.co.uk>
++ */
++
++#include <linux/interrupt.h>
++#include <linux/errno.h>
++#include <linux/module.h>
++#include <linux/platform_device.h>
++#include <linux/spi/altera.h>
++#include <linux/spi/spi.h>
++#include <linux/io.h>
++#include <linux/of.h>
++
++#define DRV_NAME "spi_altera"
++
++enum altera_spi_type {
++	ALTERA_SPI_TYPE_UNKNOWN,
++	ALTERA_SPI_TYPE_SUBDEV,
++};
++
++static const struct regmap_config spi_altera_config = {
++	.reg_bits = 32,
++	.reg_stride = 4,
++	.val_bits = 32,
++	.fast_io = true,
++};
++
++static int altera_spi_probe(struct platform_device *pdev)
++{
++	const struct platform_device_id *platid = platform_get_device_id(pdev);
++	struct altera_spi_platform_data *pdata = dev_get_platdata(&pdev->dev);
++	enum altera_spi_type type = ALTERA_SPI_TYPE_UNKNOWN;
++	struct altera_spi *hw;
++	struct spi_master *master;
++	int err = -ENODEV;
++	u16 i;
++
++	master = spi_alloc_master(&pdev->dev, sizeof(struct altera_spi));
++	if (!master)
++		return err;
++
++	/* setup the master state. */
++	master->bus_num = pdev->id;
++
++	if (pdata) {
++		if (pdata->num_chipselect > ALTERA_SPI_MAX_CS) {
++			dev_err(&pdev->dev,
++				"Invalid number of chipselect: %u\n",
++				pdata->num_chipselect);
++			err = -EINVAL;
++			goto exit;
++		}
++
++		master->num_chipselect = pdata->num_chipselect;
++		master->mode_bits = pdata->mode_bits;
++		master->bits_per_word_mask = pdata->bits_per_word_mask;
++	} else {
++		master->num_chipselect = 16;
++		master->mode_bits = SPI_CS_HIGH;
++		master->bits_per_word_mask = SPI_BPW_RANGE_MASK(1, 16);
++	}
++
++	master->dev.of_node = pdev->dev.of_node;
++
++	hw = spi_master_get_devdata(master);
++	hw->dev = &pdev->dev;
++
++	if (platid)
++		type = platid->driver_data;
++
++	/* find and map our resources */
++	if (type == ALTERA_SPI_TYPE_SUBDEV) {
++		struct resource *regoff;
++
++		hw->regmap = dev_get_regmap(pdev->dev.parent, NULL);
++		if (!hw->regmap) {
++			dev_err(&pdev->dev, "get regmap failed\n");
++			goto exit;
++		}
++
++		regoff = platform_get_resource(pdev, IORESOURCE_REG, 0);
++		if (regoff)
++			hw->regoff = regoff->start;
++	} else {
++		void __iomem *res;
++
++		res = devm_platform_ioremap_resource(pdev, 0);
++		if (IS_ERR(res)) {
++			err = PTR_ERR(res);
++			goto exit;
++		}
++
++		hw->regmap = devm_regmap_init_mmio(&pdev->dev, res,
++						   &spi_altera_config);
++		if (IS_ERR(hw->regmap)) {
++			dev_err(&pdev->dev, "regmap mmio init failed\n");
++			err = PTR_ERR(hw->regmap);
++			goto exit;
++		}
++	}
++
++	altera_spi_init_master(master);
++
++	/* irq is optional */
++	hw->irq = platform_get_irq(pdev, 0);
++	if (hw->irq >= 0) {
++		err = devm_request_irq(&pdev->dev, hw->irq, altera_spi_irq, 0,
++				       pdev->name, master);
++		if (err)
++			goto exit;
++	}
++
++	err = devm_spi_register_master(&pdev->dev, master);
++	if (err)
++		goto exit;
++
++	if (pdata) {
++		for (i = 0; i < pdata->num_devices; i++) {
++			if (!spi_new_device(master, pdata->devices + i))
++				dev_warn(&pdev->dev,
++					 "unable to create SPI device: %s\n",
++					 pdata->devices[i].modalias);
++		}
++	}
++
++	dev_info(&pdev->dev, "regoff %u, irq %d\n", hw->regoff, hw->irq);
++
++	return 0;
++exit:
++	spi_master_put(master);
++	return err;
++}
++
++#ifdef CONFIG_OF
++static const struct of_device_id altera_spi_match[] = {
++	{ .compatible = "ALTR,spi-1.0", },
++	{ .compatible = "altr,spi-1.0", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, altera_spi_match);
++#endif /* CONFIG_OF */
++
++static const struct platform_device_id altera_spi_ids[] = {
++	{ DRV_NAME,		ALTERA_SPI_TYPE_UNKNOWN },
++	{ "subdev_spi_altera",	ALTERA_SPI_TYPE_SUBDEV },
++	{ }
++};
++MODULE_DEVICE_TABLE(platform, altera_spi_ids);
++
++static struct platform_driver altera_spi_driver = {
++	.probe = altera_spi_probe,
++	.driver = {
++		.name = DRV_NAME,
++		.pm = NULL,
++		.of_match_table = of_match_ptr(altera_spi_match),
++	},
++	.id_table	= altera_spi_ids,
++};
++module_platform_driver(altera_spi_driver);
++
++MODULE_DESCRIPTION("Altera SPI driver");
++MODULE_AUTHOR("Thomas Chou <thomas@wytron.com.tw>");
++MODULE_LICENSE("GPL");
++MODULE_ALIAS("platform:" DRV_NAME);
+diff --git a/include/linux/spi/altera.h b/include/linux/spi/altera.h
+index 2d42641499a6..2e2a622e56da 100644
+--- a/include/linux/spi/altera.h
++++ b/include/linux/spi/altera.h
+@@ -5,10 +5,13 @@
+ #ifndef __LINUX_SPI_ALTERA_H
+ #define __LINUX_SPI_ALTERA_H
+ 
++#include <linux/interrupt.h>
+ #include <linux/regmap.h>
+ #include <linux/spi/spi.h>
+ #include <linux/types.h>
+ 
++#define ALTERA_SPI_MAX_CS		32
++
+ /**
+  * struct altera_spi_platform_data - Platform data of the Altera SPI driver
+  * @mode_bits:		Mode bits of SPI master.
+@@ -26,4 +29,22 @@ struct altera_spi_platform_data {
+ 	struct spi_board_info		*devices;
+ };
+ 
++struct altera_spi {
++	int irq;
++	int len;
++	int count;
++	int bytes_per_word;
++	u32 imr;
++
++	/* data buffers */
++	const unsigned char *tx;
++	unsigned char *rx;
++
++	struct regmap *regmap;
++	u32 regoff;
++	struct device *dev;
++};
++
++extern irqreturn_t altera_spi_irq(int irq, void *dev);
++extern void altera_spi_init_master(struct spi_master *master);
+ #endif /* __LINUX_SPI_ALTERA_H */
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0143-spi-altera-Add-DFL-bus-driver-for-Altera-API-Control.patch new/debian/patches/fpga-ofs/0143-spi-altera-Add-DFL-bus-driver-for-Altera-API-Control.patch
--- org/debian/patches/fpga-ofs/0143-spi-altera-Add-DFL-bus-driver-for-Altera-API-Control.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0143-spi-altera-Add-DFL-bus-driver-for-Altera-API-Control.patch	2021-07-20 06:17:11.532844504 +0200
@@ -0,0 +1,266 @@
+From a4e65743d55645f1b7cb38a7e44536c9aa9c20cd Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Fri, 16 Apr 2021 09:57:20 -0700
+Subject: [PATCH 143/149] spi: altera: Add DFL bus driver for Altera API
+ Controller
+
+This patch adds a Device Feature List (DFL) bus driver for the
+Altera SPI Master controller.  The SPI master is connected to an
+Intel SPI Slave to Avalon Bridge inside an Intel MAX10
+BMC Chip.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Link: https://lore.kernel.org/r/20210416165720.554144-3-matthew.gerlach@linux.intel.com
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/Kconfig          |   9 ++
+ drivers/spi/Makefile         |   1 +
+ drivers/spi/spi-altera-dfl.c | 204 +++++++++++++++++++++++++++++++++++
+ 3 files changed, 214 insertions(+)
+ create mode 100644 drivers/spi/spi-altera-dfl.c
+
+diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
+index 40ae5baad957..b63ae110dc30 100644
+--- a/drivers/spi/Kconfig
++++ b/drivers/spi/Kconfig
+@@ -70,6 +70,15 @@ config SPI_ALTERA_CORE
+ 	help
+ 	  "The core code for the Altera SPI Controller"
+ 
++config SPI_ALTERA_DFL
++	tristate "DFL bus driver for Altera SPI Controller"
++	depends on FPGA_DFL
++	select SPI_ALTERA_CORE
++	help
++	  This is a Device Feature List (DFL) bus driver for the
++	  Altera SPI master controller.  The SPI master is connected
++	  to a SPI slave to Avalon bridge in a Intel MAX BMC.
++
+ config SPI_AR934X
+ 	tristate "Qualcomm Atheros AR934X/QCA95XX SPI controller driver"
+ 	depends on ATH79 || COMPILE_TEST
+diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
+index be575c6f76ad..7854ff575b06 100644
+--- a/drivers/spi/Makefile
++++ b/drivers/spi/Makefile
+@@ -16,6 +16,7 @@ obj-$(CONFIG_SPI_LOOPBACK_TEST)		+= spi-loopback-test.o
+ # SPI master controller drivers (bus)
+ obj-$(CONFIG_SPI_ALTERA)		+= spi-altera-platform.o
+ obj-$(CONFIG_SPI_ALTERA_CORE)		+= spi-altera-core.o
++obj-$(CONFIG_SPI_ALTERA_DFL)		+= spi-altera-dfl.o
+ obj-$(CONFIG_SPI_AR934X)		+= spi-ar934x.o
+ obj-$(CONFIG_SPI_ARMADA_3700)		+= spi-armada-3700.o
+ obj-$(CONFIG_SPI_ATMEL)			+= spi-atmel.o
+diff --git a/drivers/spi/spi-altera-dfl.c b/drivers/spi/spi-altera-dfl.c
+new file mode 100644
+index 000000000000..3e32e4fe5895
+--- /dev/null
++++ b/drivers/spi/spi-altera-dfl.c
+@@ -0,0 +1,204 @@
++// SPDX-License-Identifier: GPL-2.0
++//
++// DFL bus driver for Altera SPI Master
++//
++// Copyright (C) 2020 Intel Corporation, Inc.
++//
++// Authors:
++//   Matthew Gerlach <matthew.gerlach@linux.intel.com>
++//
++
++#include <linux/types.h>
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/stddef.h>
++#include <linux/errno.h>
++#include <linux/platform_device.h>
++#include <linux/io.h>
++#include <linux/bitfield.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/regmap.h>
++#include <linux/spi/spi.h>
++#include <linux/spi/altera.h>
++#include <linux/dfl.h>
++
++#define FME_FEATURE_ID_MAX10_SPI	0xe
++#define FME_FEATURE_REV_MAX10_SPI_N5010	0x1
++
++#define SPI_CORE_PARAMETER      0x8
++#define SHIFT_MODE              BIT_ULL(1)
++#define SHIFT_MODE_MSB          0
++#define SHIFT_MODE_LSB          1
++#define DATA_WIDTH              GENMASK_ULL(7, 2)
++#define NUM_CHIPSELECT          GENMASK_ULL(13, 8)
++#define CLK_POLARITY            BIT_ULL(14)
++#define CLK_PHASE               BIT_ULL(15)
++#define PERIPHERAL_ID           GENMASK_ULL(47, 32)
++#define SPI_CLK                 GENMASK_ULL(31, 22)
++#define SPI_INDIRECT_ACC_OFST   0x10
++
++#define INDIRECT_ADDR           (SPI_INDIRECT_ACC_OFST+0x0)
++#define INDIRECT_WR             BIT_ULL(8)
++#define INDIRECT_RD             BIT_ULL(9)
++#define INDIRECT_RD_DATA        (SPI_INDIRECT_ACC_OFST+0x8)
++#define INDIRECT_DATA_MASK      GENMASK_ULL(31, 0)
++#define INDIRECT_DEBUG          BIT_ULL(32)
++#define INDIRECT_WR_DATA        (SPI_INDIRECT_ACC_OFST+0x10)
++#define INDIRECT_TIMEOUT        10000
++
++static int indirect_bus_reg_read(void *context, unsigned int reg,
++				 unsigned int *val)
++{
++	void __iomem *base = context;
++	int loops;
++	u64 v;
++
++	writeq((reg >> 2) | INDIRECT_RD, base + INDIRECT_ADDR);
++
++	loops = 0;
++	while ((readq(base + INDIRECT_ADDR) & INDIRECT_RD) &&
++	       (loops++ < INDIRECT_TIMEOUT))
++		cpu_relax();
++
++	if (loops >= INDIRECT_TIMEOUT) {
++		pr_err("%s timed out %d\n", __func__, loops);
++		return -ETIME;
++	}
++
++	v = readq(base + INDIRECT_RD_DATA);
++
++	*val = v & INDIRECT_DATA_MASK;
++
++	return 0;
++}
++
++static int indirect_bus_reg_write(void *context, unsigned int reg,
++				  unsigned int val)
++{
++	void __iomem *base = context;
++	int loops;
++
++	writeq(val, base + INDIRECT_WR_DATA);
++	writeq((reg >> 2) | INDIRECT_WR, base + INDIRECT_ADDR);
++
++	loops = 0;
++	while ((readq(base + INDIRECT_ADDR) & INDIRECT_WR) &&
++	       (loops++ < INDIRECT_TIMEOUT))
++		cpu_relax();
++
++	if (loops >= INDIRECT_TIMEOUT) {
++		pr_err("%s timed out %d\n", __func__, loops);
++		return -ETIME;
++	}
++	return 0;
++}
++
++static const struct regmap_config indirect_regbus_cfg = {
++	.reg_bits = 32,
++	.reg_stride = 4,
++	.val_bits = 32,
++	.fast_io = true,
++	.max_register = 24,
++
++	.reg_write = indirect_bus_reg_write,
++	.reg_read = indirect_bus_reg_read,
++};
++
++static struct spi_board_info m10_bmc_info = {
++	.modalias = "m10-d5005",
++	.max_speed_hz = 12500000,
++	.bus_num = 0,
++	.chip_select = 0,
++};
++
++static void config_spi_master(void __iomem *base, struct spi_master *master)
++{
++	u64 v;
++
++	v = readq(base + SPI_CORE_PARAMETER);
++
++	master->mode_bits = SPI_CS_HIGH;
++	if (FIELD_GET(CLK_POLARITY, v))
++		master->mode_bits |= SPI_CPOL;
++	if (FIELD_GET(CLK_PHASE, v))
++		master->mode_bits |= SPI_CPHA;
++
++	master->num_chipselect = FIELD_GET(NUM_CHIPSELECT, v);
++	master->bits_per_word_mask =
++		SPI_BPW_RANGE_MASK(1, FIELD_GET(DATA_WIDTH, v));
++}
++
++static int dfl_spi_altera_probe(struct dfl_device *dfl_dev)
++{
++	struct device *dev = &dfl_dev->dev;
++	struct spi_master *master;
++	struct altera_spi *hw;
++	void __iomem *base;
++	int err = -ENODEV;
++
++	master = spi_alloc_master(dev, sizeof(struct altera_spi));
++	if (!master)
++		return -ENOMEM;
++
++	master->bus_num = dfl_dev->id;
++
++	hw = spi_master_get_devdata(master);
++
++	hw->dev = dev;
++
++	base = devm_ioremap_resource(dev, &dfl_dev->mmio_res);
++
++	if (IS_ERR(base)) {
++		dev_err(dev, "%s get mem resource fail!\n", __func__);
++		return PTR_ERR(base);
++	}
++
++	config_spi_master(base, master);
++	dev_dbg(dev, "%s cs %u bpm 0x%x mode 0x%x\n", __func__,
++		master->num_chipselect, master->bits_per_word_mask,
++		master->mode_bits);
++
++	hw->regmap = devm_regmap_init(dev, NULL, base, &indirect_regbus_cfg);
++	if (IS_ERR(hw->regmap))
++		return PTR_ERR(hw->regmap);
++
++	hw->irq = -EINVAL;
++
++	altera_spi_init_master(master);
++
++	err = devm_spi_register_master(dev, master);
++	if (err) {
++		dev_err(dev, "%s failed to register spi master %d\n", __func__, err);
++		goto exit;
++	}
++
++	if (!spi_new_device(master,  &m10_bmc_info)) {
++		dev_err(dev, "%s failed to create SPI device: %s\n",
++			__func__, m10_bmc_info.modalias);
++	}
++
++	return 0;
++exit:
++	spi_master_put(master);
++	return err;
++}
++
++static const struct dfl_device_id dfl_spi_altera_ids[] = {
++	{ FME_ID, FME_FEATURE_ID_MAX10_SPI },
++	{ }
++};
++
++static struct dfl_driver dfl_spi_altera_driver = {
++	.drv	= {
++		.name       = "dfl-spi-altera",
++	},
++	.id_table = dfl_spi_altera_ids,
++	.probe   = dfl_spi_altera_probe,
++};
++
++module_dfl_driver(dfl_spi_altera_driver);
++
++MODULE_DEVICE_TABLE(dfl, dfl_spi_altera_ids);
++MODULE_DESCRIPTION("DFL spi altera driver");
++MODULE_AUTHOR("Intel Corporation");
++MODULE_LICENSE("GPL v2");
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0144-spi-altera-Support-n1050-feature-revision.patch new/debian/patches/fpga-ofs/0144-spi-altera-Support-n1050-feature-revision.patch
--- org/debian/patches/fpga-ofs/0144-spi-altera-Support-n1050-feature-revision.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0144-spi-altera-Support-n1050-feature-revision.patch	2021-07-20 06:17:11.532844504 +0200
@@ -0,0 +1,63 @@
+From c317d21c63e622fb6a17f80f4dcce1f78585c08c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Martin=20Hundeb=C3=B8ll?= <mhu@silicom.dk>
+Date: Mon, 1 Feb 2021 13:20:46 +0100
+Subject: [PATCH 144/149] spi: altera: Support n1050 feature revision
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The Max10 BMC on the Silicom n5010 PAC card is slightly different than
+the existing BMC's, so use a dedicated feature revision detect it.
+
+Signed-off-by: Martin Hundebøll <mhu@silicom.dk>
+---
+ drivers/spi/spi-altera-dfl.c | 18 +++++++++++++++---
+ 1 file changed, 15 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/spi/spi-altera-dfl.c b/drivers/spi/spi-altera-dfl.c
+index 3e32e4fe5895..e6f2d39a6701 100644
+--- a/drivers/spi/spi-altera-dfl.c
++++ b/drivers/spi/spi-altera-dfl.c
+@@ -111,6 +111,13 @@ static struct spi_board_info m10_bmc_info = {
+ 	.chip_select = 0,
+ };
+ 
++static struct spi_board_info m10_n5010_bmc_info = {
++	.modalias = "m10-n5010",
++	.max_speed_hz = 12500000,
++	.bus_num = 0,
++	.chip_select = 0,
++};
++
+ static void config_spi_master(void __iomem *base, struct spi_master *master)
+ {
+ 	u64 v;
+@@ -131,6 +138,7 @@ static void config_spi_master(void __iomem *base, struct spi_master *master)
+ static int dfl_spi_altera_probe(struct dfl_device *dfl_dev)
+ {
+ 	struct device *dev = &dfl_dev->dev;
++	struct spi_board_info *spi_info;
+ 	struct spi_master *master;
+ 	struct altera_spi *hw;
+ 	void __iomem *base;
+@@ -172,10 +180,14 @@ static int dfl_spi_altera_probe(struct dfl_device *dfl_dev)
+ 		goto exit;
+ 	}
+ 
+-	if (!spi_new_device(master,  &m10_bmc_info)) {
++	if (dfl_feature_revision(base) == FME_FEATURE_REV_MAX10_SPI_N5010)
++		spi_info = &m10_n5010_bmc_info;
++	else
++		spi_info = &m10_bmc_info;
++
++	if (!spi_new_device(master,  spi_info))
+ 		dev_err(dev, "%s failed to create SPI device: %s\n",
+-			__func__, m10_bmc_info.modalias);
+-	}
++			__func__, spi_info->modalias);
+ 
+ 	return 0;
+ exit:
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0145-configs-Change-FPGA_DFL_SPI_ALTERA-to-SPI_ALTERA_DFL.patch new/debian/patches/fpga-ofs/0145-configs-Change-FPGA_DFL_SPI_ALTERA-to-SPI_ALTERA_DFL.patch
--- org/debian/patches/fpga-ofs/0145-configs-Change-FPGA_DFL_SPI_ALTERA-to-SPI_ALTERA_DFL.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0145-configs-Change-FPGA_DFL_SPI_ALTERA-to-SPI_ALTERA_DFL.patch	2021-07-20 06:17:11.532844504 +0200
@@ -0,0 +1,31 @@
+From 9fce05bd0f750d2b3ef75106af20aa8827ba302d Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Wed, 19 May 2021 10:42:06 -0700
+Subject: [PATCH 145/149] configs: Change FPGA_DFL_SPI_ALTERA to SPI_ALTERA_DFL
+
+During upstreamed, the changes to the dfl-spi-altera driver implementation
+led to a change in the corresponding config option:
+
+CONFIG_FPGA_DFL_SPI_ALTERA -> CONFIG_SPI_ALTERA_DFL
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ configs/dfl-config | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/configs/dfl-config b/configs/dfl-config
+index d339cc3ee3d5..16bb530efdfa 100644
+--- a/configs/dfl-config
++++ b/configs/dfl-config
+@@ -15,7 +15,7 @@ CONFIG_FPGA_DFL_FME_BRIDGE=m
+ CONFIG_FPGA_DFL_FME_REGION=m
+ 
+ CONFIG_SPI_ALTERA=m
+-CONFIG_FPGA_DFL_SPI_ALTERA=m
++CONFIG_SPI_ALTERA_DFL=m
+ 
+ CONFIG_FPGA_SEC_MGR=m
+ CONFIG_IFPGA_M10_BMC_SECURE=m
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0146-fpga-fpga-mgr-Add-devm_fpga_mgr_register-API.patch new/debian/patches/fpga-ofs/0146-fpga-fpga-mgr-Add-devm_fpga_mgr_register-API.patch
--- org/debian/patches/fpga-ofs/0146-fpga-fpga-mgr-Add-devm_fpga_mgr_register-API.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0146-fpga-fpga-mgr-Add-devm_fpga_mgr_register-API.patch	2021-07-20 06:17:11.532844504 +0200
@@ -0,0 +1,156 @@
+From 02c47c9b3e70274cc097b2908071d85f4ab5ea88 Mon Sep 17 00:00:00 2001
+From: Moritz Fischer <mdf@kernel.org>
+Date: Sun, 15 Nov 2020 11:51:18 -0800
+Subject: [PATCH 146/149] fpga: fpga-mgr: Add devm_fpga_mgr_register() API
+
+Add a devm_fpga_mgr_register() API that can be used to register a FPGA
+Manager that was created using devm_fpga_mgr_create().
+
+Introduce a struct fpga_mgr_devres that makes the devres
+allocation a little bit more readable and gets reused for
+devm_fpga_mgr_create() devm_fpga_mgr_register().
+
+Reviewed-by: Tom Rix <trix@redhat.com>
+Signed-off-by: Moritz Fischer <mdf@kernel.org>
+Link: https://lore.kernel.org/r/20201115195127.284487-2-mdf@kernel.org
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/fpga/fpga-mgr.c       | 81 +++++++++++++++++++++++++++++------
+ include/linux/fpga/fpga-mgr.h |  2 +
+ 2 files changed, 71 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/fpga/fpga-mgr.c b/drivers/fpga/fpga-mgr.c
+index f38bab01432e..b85bc47c91a9 100644
+--- a/drivers/fpga/fpga-mgr.c
++++ b/drivers/fpga/fpga-mgr.c
+@@ -21,6 +21,10 @@
+ static DEFINE_IDA(fpga_mgr_ida);
+ static struct class *fpga_mgr_class;
+ 
++struct fpga_mgr_devres {
++	struct fpga_manager *mgr;
++};
++
+ /**
+  * fpga_image_info_alloc - Allocate a FPGA image info struct
+  * @dev: owning device
+@@ -625,9 +629,9 @@ EXPORT_SYMBOL_GPL(fpga_mgr_free);
+ 
+ static void devm_fpga_mgr_release(struct device *dev, void *res)
+ {
+-	struct fpga_manager *mgr = *(struct fpga_manager **)res;
++	struct fpga_mgr_devres *dr = res;
+ 
+-	fpga_mgr_free(mgr);
++	fpga_mgr_free(dr->mgr);
+ }
+ 
+ /**
+@@ -651,21 +655,21 @@ struct fpga_manager *devm_fpga_mgr_create(struct device *dev, const char *name,
+ 					  const struct fpga_manager_ops *mops,
+ 					  void *priv)
+ {
+-	struct fpga_manager **ptr, *mgr;
++	struct fpga_mgr_devres *dr;
+ 
+-	ptr = devres_alloc(devm_fpga_mgr_release, sizeof(*ptr), GFP_KERNEL);
+-	if (!ptr)
++	dr = devres_alloc(devm_fpga_mgr_release, sizeof(*dr), GFP_KERNEL);
++	if (!dr)
+ 		return NULL;
+ 
+-	mgr = fpga_mgr_create(dev, name, mops, priv);
+-	if (!mgr) {
+-		devres_free(ptr);
+-	} else {
+-		*ptr = mgr;
+-		devres_add(dev, ptr);
++	dr->mgr = fpga_mgr_create(dev, name, mops, priv);
++	if (!dr->mgr) {
++		devres_free(dr);
++		return NULL;
+ 	}
+ 
+-	return mgr;
++	devres_add(dev, dr);
++
++	return dr->mgr;
+ }
+ EXPORT_SYMBOL_GPL(devm_fpga_mgr_create);
+ 
+@@ -722,6 +726,59 @@ void fpga_mgr_unregister(struct fpga_manager *mgr)
+ }
+ EXPORT_SYMBOL_GPL(fpga_mgr_unregister);
+ 
++static int fpga_mgr_devres_match(struct device *dev, void *res,
++				 void *match_data)
++{
++	struct fpga_mgr_devres *dr = res;
++
++	return match_data == dr->mgr;
++}
++
++static void devm_fpga_mgr_unregister(struct device *dev, void *res)
++{
++	struct fpga_mgr_devres *dr = res;
++
++	fpga_mgr_unregister(dr->mgr);
++}
++
++/**
++ * devm_fpga_mgr_register - resource managed variant of fpga_mgr_register()
++ * @dev: managing device for this FPGA manager
++ * @mgr: fpga manager struct
++ *
++ * This is the devres variant of fpga_mgr_register() for which the unregister
++ * function will be called automatically when the managing device is detached.
++ */
++int devm_fpga_mgr_register(struct device *dev, struct fpga_manager *mgr)
++{
++	struct fpga_mgr_devres *dr;
++	int ret;
++
++	/*
++	 * Make sure that the struct fpga_manager * that is passed in is
++	 * managed itself.
++	 */
++	if (WARN_ON(!devres_find(dev, devm_fpga_mgr_release,
++				 fpga_mgr_devres_match, mgr)))
++		return -EINVAL;
++
++	dr = devres_alloc(devm_fpga_mgr_unregister, sizeof(*dr), GFP_KERNEL);
++	if (!dr)
++		return -ENOMEM;
++
++	ret = fpga_mgr_register(mgr);
++	if (ret) {
++		devres_free(dr);
++		return ret;
++	}
++
++	dr->mgr = mgr;
++	devres_add(dev, dr);
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(devm_fpga_mgr_register);
++
+ static void fpga_mgr_dev_release(struct device *dev)
+ {
+ }
+diff --git a/include/linux/fpga/fpga-mgr.h b/include/linux/fpga/fpga-mgr.h
+index e8ca62b2cb5b..2bc3030a69e5 100644
+--- a/include/linux/fpga/fpga-mgr.h
++++ b/include/linux/fpga/fpga-mgr.h
+@@ -198,6 +198,8 @@ void fpga_mgr_free(struct fpga_manager *mgr);
+ int fpga_mgr_register(struct fpga_manager *mgr);
+ void fpga_mgr_unregister(struct fpga_manager *mgr);
+ 
++int devm_fpga_mgr_register(struct device *dev, struct fpga_manager *mgr);
++
+ struct fpga_manager *devm_fpga_mgr_create(struct device *dev, const char *name,
+ 					  const struct fpga_manager_ops *mops,
+ 					  void *priv);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0147-fpga-fpga-mgr-dfl-fme-mgr-Simplify-registration.patch new/debian/patches/fpga-ofs/0147-fpga-fpga-mgr-dfl-fme-mgr-Simplify-registration.patch
--- org/debian/patches/fpga-ofs/0147-fpga-fpga-mgr-dfl-fme-mgr-Simplify-registration.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0147-fpga-fpga-mgr-dfl-fme-mgr-Simplify-registration.patch	2021-07-20 06:17:11.532844504 +0200
@@ -0,0 +1,50 @@
+From dba777d0c5004434114db24b881cb8f9b133f9d5 Mon Sep 17 00:00:00 2001
+From: Moritz Fischer <mdf@kernel.org>
+Date: Sun, 15 Nov 2020 11:51:20 -0800
+Subject: [PATCH 147/149] fpga: fpga-mgr: dfl-fme-mgr: Simplify registration
+
+Simplify registration using new devm_fpga_mgr_register() API.
+
+Reviewed-by: Tom Rix <trix@redhat.com>
+Signed-off-by: Moritz Fischer <mdf@kernel.org>
+Link: https://lore.kernel.org/r/20201115195127.284487-4-mdf@kernel.org
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+---
+ drivers/fpga/dfl-fme-mgr.c | 13 +------------
+ 1 file changed, 1 insertion(+), 12 deletions(-)
+
+diff --git a/drivers/fpga/dfl-fme-mgr.c b/drivers/fpga/dfl-fme-mgr.c
+index b3f7eee3c93f..d5861d13b306 100644
+--- a/drivers/fpga/dfl-fme-mgr.c
++++ b/drivers/fpga/dfl-fme-mgr.c
+@@ -314,18 +314,8 @@ static int fme_mgr_probe(struct platform_device *pdev)
+ 		return -ENOMEM;
+ 
+ 	mgr->compat_id = compat_id;
+-	platform_set_drvdata(pdev, mgr);
+ 
+-	return fpga_mgr_register(mgr);
+-}
+-
+-static int fme_mgr_remove(struct platform_device *pdev)
+-{
+-	struct fpga_manager *mgr = platform_get_drvdata(pdev);
+-
+-	fpga_mgr_unregister(mgr);
+-
+-	return 0;
++	return devm_fpga_mgr_register(dev, mgr);
+ }
+ 
+ static struct platform_driver fme_mgr_driver = {
+@@ -333,7 +323,6 @@ static struct platform_driver fme_mgr_driver = {
+ 		.name    = DFL_FPGA_FME_MGR,
+ 	},
+ 	.probe   = fme_mgr_probe,
+-	.remove  = fme_mgr_remove,
+ };
+ 
+ module_platform_driver(fme_mgr_driver);
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0148-memory-dfl-emif-fix-capability-check-for-v0.patch new/debian/patches/fpga-ofs/0148-memory-dfl-emif-fix-capability-check-for-v0.patch
--- org/debian/patches/fpga-ofs/0148-memory-dfl-emif-fix-capability-check-for-v0.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0148-memory-dfl-emif-fix-capability-check-for-v0.patch	2021-07-20 06:17:11.532844504 +0200
@@ -0,0 +1,49 @@
+From 91e09e02dbd41f1d8573251c269aec33ceaaf8a1 Mon Sep 17 00:00:00 2001
+From: Russ Weight <russell.h.weight@intel.com>
+Date: Fri, 4 Jun 2021 16:52:46 -0700
+Subject: [PATCH 148/149] memory: dfl-emif: fix capability check for v0
+
+The EMIF capability field is tested to determine how many DDR channels
+are present.  For revision 0 of the EMIF feature, this field is 4 bits
+wide. For later revisions, it is 8 bits wide. This change uses the
+appropriate mask to limit the capability check based on the feature
+revision.
+
+Signed-off-by: Russ Weight <russell.h.weight@intel.com>
+---
+ drivers/memory/dfl-emif.c | 12 +++++++++---
+ 1 file changed, 9 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/memory/dfl-emif.c b/drivers/memory/dfl-emif.c
+index dfcc2b6da47d..67c94b155f23 100644
+--- a/drivers/memory/dfl-emif.c
++++ b/drivers/memory/dfl-emif.c
+@@ -38,8 +38,9 @@
+  * of a memory channel, and the Control Register definitions are used for
+  * managing the memory-clear functionality in revision 0.
+  */
+-#define EMIF_CAPABILITY_BASE            0x10
+-#define EMIF_CAPABILITY_CHN_MSK         GENMASK_ULL(7, 0)
++#define EMIF_CAPABILITY_BASE		0x10
++#define EMIF_CAPABILITY_CHN_MSK_V0	GENMASK_ULL(3, 0)
++#define EMIF_CAPABILITY_CHN_MSK		GENMASK_ULL(7, 0)
+ 
+ struct dfl_emif {
+ 	struct device *dev;
+@@ -196,7 +197,12 @@ static umode_t dfl_emif_visible(struct kobject *kobj,
+ 	if (dfl_feature_revision(de->base) > 0 && strstr(attr->name, "_clear"))
+ 		return 0;
+ 
+-	val = FIELD_GET(EMIF_CAPABILITY_CHN_MSK, readq(de->base + EMIF_CAPABILITY_BASE));
++	if (dfl_feature_revision(de->base) == 0)
++		val = FIELD_GET(EMIF_CAPABILITY_CHN_MSK_V0,
++				readq(de->base + EMIF_CAPABILITY_BASE));
++	else
++		val = FIELD_GET(EMIF_CAPABILITY_CHN_MSK,
++				readq(de->base + EMIF_CAPABILITY_BASE));
+ 
+ 	return (val & BIT_ULL(eattr->index)) ? attr->mode : 0;
+ }
+-- 
+2.30.2
+
diff -Nur org/debian/patches/fpga-ofs/0149-uio-dfl-add-HSSI-feature-id.patch new/debian/patches/fpga-ofs/0149-uio-dfl-add-HSSI-feature-id.patch
--- org/debian/patches/fpga-ofs/0149-uio-dfl-add-HSSI-feature-id.patch	1970-01-01 01:00:00.000000000 +0100
+++ new/debian/patches/fpga-ofs/0149-uio-dfl-add-HSSI-feature-id.patch	2021-07-20 06:17:11.532844504 +0200
@@ -0,0 +1,32 @@
+From 279e0f91b8780b688153e16e4d53dfec8f8da525 Mon Sep 17 00:00:00 2001
+From: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+Date: Tue, 23 Mar 2021 09:15:17 -0700
+Subject: [PATCH 149/149] uio: dfl: add HSSI feature id
+
+Add the feature id of the OFS High Speed Serial Interface
+subsystem to table of ids supported by the uio_dfl driver.
+
+Signed-off-by: Matthew Gerlach <matthew.gerlach@linux.intel.com>
+---
+ drivers/uio/uio_dfl.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drivers/uio/uio_dfl.c b/drivers/uio/uio_dfl.c
+index e0fab0c597e6..f578bcb2cde7 100644
+--- a/drivers/uio/uio_dfl.c
++++ b/drivers/uio/uio_dfl.c
+@@ -132,9 +132,11 @@ static int uio_dfl_probe(struct dfl_device *ddev)
+ }
+ 
+ #define FME_FEATURE_ID_ETH_GROUP	0x10
++#define FME_FEATURE_ID_OFS_HSSI		0x15
+ 
+ static const struct dfl_device_id uio_dfl_ids[] = {
+ 	{ FME_ID, FME_FEATURE_ID_ETH_GROUP },
++	{ FME_ID, FME_FEATURE_ID_OFS_HSSI },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(dfl, uio_dfl_ids);
+-- 
+2.30.2
+
