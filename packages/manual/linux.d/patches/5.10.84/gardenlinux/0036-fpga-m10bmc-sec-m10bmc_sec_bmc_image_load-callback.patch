From cc8d07ff89c653a60405a7efb828128006197a4b Mon Sep 17 00:00:00 2001
From: Russ Weight <russell.h.weight@intel.com>
Date: Wed, 28 Oct 2020 15:50:54 -0700
Subject: [PATCH 36/39] fpga: m10bmc-sec: m10bmc_sec_bmc_image_load callback

Create m10bmc_sec_bmc_image_load() callback function to
trigger a load of a new BMC image.

Signed-off-by: Russ Weight <russell.h.weight@intel.com>
Signed-off-by: Xu Yilun <yilun.xu@intel.com>
---
 drivers/fpga/intel-m10-bmc-secure.c | 104 ++++++++++++++++++++++------
 1 file changed, 84 insertions(+), 20 deletions(-)

diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
index 3a5d9f2c2878..48bc462c10ca 100644
--- org/drivers/fpga/intel-m10-bmc-secure.c
+++ new/drivers/fpga/intel-m10-bmc-secure.c
@@ -548,29 +548,89 @@ static u64 m10bmc_sec_hw_errinfo(struct fpga_sec_mgr *smgr)
 	}
 }
 
-static const struct fpga_sec_mgr_ops m10bmc_sops = {
-	.user_flash_count = m10bmc_user_flash_count,
-	.bmc_root_entry_hash = m10bmc_bmc_reh,
-	.sr_root_entry_hash = m10bmc_sr_reh,
-	.pr_root_entry_hash = m10bmc_pr_reh,
-	.bmc_canceled_csks = m10bmc_bmc_canceled_csks,
-	.sr_canceled_csks = m10bmc_sr_canceled_csks,
-	.pr_canceled_csks = m10bmc_pr_canceled_csks,
-	.bmc_reh_size = m10bmc_bmc_reh_size,
-	.sr_reh_size = m10bmc_sr_reh_size,
-	.pr_reh_size = m10bmc_pr_reh_size,
-	.bmc_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
-	.sr_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
-	.pr_canceled_csk_nbits = m10bmc_csk_cancel_nbits,
-	.prepare = m10bmc_sec_prepare,
-	.write_blk = m10bmc_sec_write_blk,
-	.poll_complete = m10bmc_sec_poll_complete,
-	.cancel = m10bmc_sec_cancel,
-	.get_hw_errinfo = m10bmc_sec_hw_errinfo,
+static int m10bmc_sec_bmc_image_load(struct fpga_sec_mgr *smgr,
+				     unsigned int val)
+{
+	struct m10bmc_sec *sec = smgr->priv;
+	u32 doorbell;
+	int ret;
+
+	if (val > 1) {
+		dev_err(sec->dev, "%s invalid reload val = %d\n",
+			__func__, val);
+		return -EINVAL;
+	}
+
+	ret = m10bmc_sys_read(sec->m10bmc, M10BMC_DOORBELL, &doorbell);
+	if (ret)
+		return ret;
+
+	if (doorbell & DRBL_REBOOT_DISABLED)
+		return -EBUSY;
+
+	return m10bmc_sys_update_bits(sec->m10bmc, M10BMC_DOORBELL,
+				     DRBL_CONFIG_SEL | DRBL_REBOOT_REQ,
+				     FIELD_PREP(DRBL_CONFIG_SEL, val) |
+				     DRBL_REBOOT_REQ);
+}
+
+static int m10bmc_sec_bmc_image_load_0(struct fpga_sec_mgr *smgr)
+{
+	return m10bmc_sec_bmc_image_load(smgr, 0);
+}
+
+static int m10bmc_sec_bmc_image_load_1(struct fpga_sec_mgr *smgr)
+{
+	return m10bmc_sec_bmc_image_load(smgr, 1);
+}
+
+static struct image_load n3000_image_load_hndlrs[] = {
+	{
+		.name = "bmc_user",
+		.load_image = m10bmc_sec_bmc_image_load_0,
+	},
+	{
+		.name = "bmc_factory",
+		.load_image = m10bmc_sec_bmc_image_load_1,
+	},
+	{}
 };
 
+static struct fpga_sec_mgr_ops *
+m10bmc_sops_create(struct device *dev)
+{
+	struct fpga_sec_mgr_ops *sops;
+
+	sops = devm_kzalloc(dev, sizeof(*sops), GFP_KERNEL);
+	if (!sops)
+		return NULL;
+
+	sops->user_flash_count = m10bmc_user_flash_count;
+	sops->bmc_root_entry_hash = m10bmc_bmc_reh;
+	sops->sr_root_entry_hash = m10bmc_sr_reh;
+	sops->pr_root_entry_hash = m10bmc_pr_reh;
+	sops->bmc_canceled_csks = m10bmc_bmc_canceled_csks;
+	sops->sr_canceled_csks = m10bmc_sr_canceled_csks;
+	sops->pr_canceled_csks = m10bmc_pr_canceled_csks;
+	sops->bmc_reh_size = m10bmc_bmc_reh_size;
+	sops->sr_reh_size = m10bmc_sr_reh_size;
+	sops->pr_reh_size = m10bmc_pr_reh_size;
+	sops->bmc_canceled_csk_nbits = m10bmc_csk_cancel_nbits;
+	sops->sr_canceled_csk_nbits = m10bmc_csk_cancel_nbits;
+	sops->pr_canceled_csk_nbits = m10bmc_csk_cancel_nbits;
+	sops->prepare = m10bmc_sec_prepare;
+	sops->write_blk = m10bmc_sec_write_blk;
+	sops->poll_complete = m10bmc_sec_poll_complete;
+	sops->cancel = m10bmc_sec_cancel;
+	sops->get_hw_errinfo = m10bmc_sec_hw_errinfo;
+	sops->image_load = n3000_image_load_hndlrs;
+
+	return sops;
+}
+
 static int m10bmc_secure_probe(struct platform_device *pdev)
 {
+	struct fpga_sec_mgr_ops *sops;
 	struct fpga_sec_mgr *smgr;
 	struct m10bmc_sec *sec;
 	int ret;
@@ -579,12 +639,16 @@ static int m10bmc_secure_probe(struct platform_device *pdev)
 	if (!sec)
 		return -ENOMEM;
 
+	sops = m10bmc_sops_create(&pdev->dev);
+	if (!sops)
+		return -ENOMEM;
+
 	sec->dev = &pdev->dev;
 	sec->m10bmc = dev_get_drvdata(pdev->dev.parent);
 	dev_set_drvdata(&pdev->dev, sec);
 
 	smgr = devm_fpga_sec_mgr_create(sec->dev, "Max10 BMC Secure Update",
-					&m10bmc_sops, sec);
+					sops, sec);
 	if (!smgr) {
 		dev_err(sec->dev,
 			"Security manager failed to start: %d\n", ret);
-- 
2.34.1

