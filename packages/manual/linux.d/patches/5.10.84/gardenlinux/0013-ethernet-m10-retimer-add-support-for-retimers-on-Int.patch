From 3a42989c5287f8e860758f77ea1a1ee827a639f9 Mon Sep 17 00:00:00 2001
From: Xu Yilun <yilun.xu@intel.com>
Date: Mon, 23 Mar 2020 15:15:35 +0800
Subject: [PATCH 13/39] ethernet: m10-retimer: add support for retimers on
 Intel MAX 10 BMC

This driver supports the ethernet retimers (Parkvale) for the Intel PAC
(Programmable Acceleration Card) N3000, which is a FPGA based Smart NIC.

Parkvale is an Intel(R) Ethernet serdes transceiver chip that supports up
to 100G transfer. On Intel PAC N3000 there are 2 Parkvale chips managed
by the Intel MAX 10 BMC firmware. They are configured in 4 ports 10G/25G
retimer mode. Host could query their link status via retimer interfaces
(Shared registers) on Intel MAX 10 BMC.

The driver adds the phy device for each port of the 2 retimer chips.
Since the phys are not accessed by the real MDIO bus, it creates a virtual
mdio bus for each NIC device instance, and a dedicated phy driver which
only provides the supported features and link state.

A DFL Ether Group driver will create net devices and connect to these
phys.

Signed-off-by: Xu Yilun <yilun.xu@intel.com>
----
v2: pass struct device * to create_altr_spi_controller() instead of
    struct dfl_device *
    Add THIS_MODULE param for phy_driver_register()
v3: fix bug that static struct m10_n3000_pdata will cause problem on
    multiphy device instances.
v4: detach the net device when the phy is to be removed.
     It is possible the phy device is removed before the attached net
     device. If the phy device is removed silently, kernel bug happens
     when the net device still tries to operate on the phy.
v5: replace all the 'pkvl' -> 'retimer'
---
 drivers/fpga/dfl-n3000-nios.c                 |  11 +-
 drivers/mfd/intel-m10-bmc.c                   |  18 ++
 drivers/net/ethernet/intel/Kconfig            |  12 +
 drivers/net/ethernet/intel/Makefile           |   2 +
 .../ethernet/intel/intel-m10-bmc-retimer.c    | 229 ++++++++++++++++++
 include/linux/mfd/intel-m10-bmc.h             |  16 ++
 6 files changed, 286 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/ethernet/intel/intel-m10-bmc-retimer.c

diff --git a/drivers/fpga/dfl-n3000-nios.c b/drivers/fpga/dfl-n3000-nios.c
index 7c0af52d87e4..dc0392c00bd4 100644
--- org/drivers/fpga/dfl-n3000-nios.c
+++ new/drivers/fpga/dfl-n3000-nios.c
@@ -16,6 +16,7 @@
 #include <linux/io-64-nonatomic-lo-hi.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/mfd/intel-m10-bmc.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
 #include <linux/stddef.h>
@@ -163,6 +164,8 @@ struct n3000_nios {
 	struct regmap *regmap;
 	struct device *dev;
 	struct platform_device *altera_spi;
+	struct intel_m10bmc_platdata m10bmc_pdata;
+	struct intel_m10bmc_retimer_pdata m10bmc_retimer_pdata;
 };
 
 static ssize_t nios_fw_version_show(struct device *dev,
@@ -420,7 +423,8 @@ static struct spi_board_info m10_n3000_info = {
 	.chip_select = 0,
 };
 
-static int create_altera_spi_controller(struct n3000_nios *nn)
+static int create_altera_spi_controller(struct n3000_nios *nn,
+					struct device *retimer_master)
 {
 	struct altera_spi_platform_data pdata = { 0 };
 	struct platform_device_info pdevinfo = { 0 };
@@ -439,6 +443,9 @@ static int create_altera_spi_controller(struct n3000_nios *nn)
 	pdata.bits_per_word_mask =
 		SPI_BPW_RANGE_MASK(1, FIELD_GET(N3000_NS_PARAM_DATA_WIDTH, v));
 
+	nn->m10bmc_retimer_pdata.retimer_master = retimer_master;
+	nn->m10bmc_pdata.retimer = &nn->m10bmc_retimer_pdata;
+	m10_n3000_info.platform_data = &nn->m10bmc_pdata;
 	pdata.num_devices = 1;
 	pdata.devices = &m10_n3000_info;
 
@@ -557,7 +564,7 @@ static int n3000_nios_probe(struct dfl_device *ddev)
 	if (ret)
 		return ret;
 
-	ret = create_altera_spi_controller(nn);
+	ret = create_altera_spi_controller(nn, dfl_dev_get_base_dev(ddev));
 	if (ret)
 		dev_err(dev, "altera spi controller create failed: %d\n", ret);
 
diff --git a/drivers/mfd/intel-m10-bmc.c b/drivers/mfd/intel-m10-bmc.c
index b84579b7b4f0..adbfb17713b1 100644
--- org/drivers/mfd/intel-m10-bmc.c
+++ new/drivers/mfd/intel-m10-bmc.c
@@ -23,6 +23,21 @@ static struct mfd_cell m10bmc_pacn3000_subdevs[] = {
 	{ .name = "n3000bmc-secure" },
 };
 
+static void
+m10bmc_init_cells_platdata(struct intel_m10bmc_platdata *pdata,
+			   struct mfd_cell *cells, int n_cell)
+{
+	int i;
+
+	for (i = 0; i < n_cell; i++) {
+		if (!strcmp(cells[i].name, "n3000bmc-retimer")) {
+			cells[i].platform_data = pdata->retimer;
+			cells[i].pdata_size =
+				pdata->retimer ? sizeof(*pdata->retimer) : 0;
+		}
+	}
+}
+
 static struct regmap_config intel_m10bmc_regmap_config = {
 	.reg_bits = 32,
 	.val_bits = 32,
@@ -97,6 +112,7 @@ static int check_m10bmc_version(struct intel_m10bmc *ddata)
 
 static int intel_m10_bmc_spi_probe(struct spi_device *spi)
 {
+	struct intel_m10bmc_platdata *pdata = dev_get_platdata(&spi->dev);
 	const struct spi_device_id *id = spi_get_device_id(spi);
 	struct device *dev = &spi->dev;
 	struct mfd_cell *cells;
@@ -134,6 +150,8 @@ static int intel_m10_bmc_spi_probe(struct spi_device *spi)
 		return -ENODEV;
 	}
 
+	m10bmc_init_cells_platdata(pdata, cells, n_cell);
+
 	ret = devm_mfd_add_devices(dev, PLATFORM_DEVID_AUTO, cells, n_cell,
 				   NULL, 0, NULL);
 	if (ret)
diff --git a/drivers/net/ethernet/intel/Kconfig b/drivers/net/ethernet/intel/Kconfig
index 5aa86318ed3e..81c43d4a0cc5 100644
--- org/drivers/net/ethernet/intel/Kconfig
+++ new/drivers/net/ethernet/intel/Kconfig
@@ -343,4 +343,16 @@ config IGC
 	  To compile this driver as a module, choose M here. The module
 	  will be called igc.
 
+config INTEL_M10_BMC_RETIMER
+	tristate "Intel(R) MAX 10 BMC ethernet retimer support"
+	depends on MFD_INTEL_M10_BMC
+	select PHYLIB
+        help
+          This driver supports the ethernet retimer (Parkvale) on
+	  Intel(R) MAX 10 BMC, which is used by Intel PAC N3000 FPGA based
+	  Smart NIC.
+
+	  To compile this driver as a module, choose M here. The module
+	  will be called intel-m10-bmc-retimer.
+
 endif # NET_VENDOR_INTEL
diff --git a/drivers/net/ethernet/intel/Makefile b/drivers/net/ethernet/intel/Makefile
index 3075290063f6..596544703803 100644
--- org/drivers/net/ethernet/intel/Makefile
+++ new/drivers/net/ethernet/intel/Makefile
@@ -16,3 +16,5 @@ obj-$(CONFIG_IXGB) += ixgb/
 obj-$(CONFIG_IAVF) += iavf/
 obj-$(CONFIG_FM10K) += fm10k/
 obj-$(CONFIG_ICE) += ice/
+
+obj-$(CONFIG_INTEL_M10_BMC_RETIMER) += intel-m10-bmc-retimer.o
diff --git a/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c b/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
new file mode 100644
index 000000000000..c7b05581e546
--- /dev/null
+++ new/drivers/net/ethernet/intel/intel-m10-bmc-retimer.c
@@ -0,0 +1,229 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Intel Max10 BMC Retimer Interface Driver
+ *
+ * Copyright (C) 2018-2020 Intel Corporation. All rights reserved.
+ *
+ */
+#include <linux/device.h>
+#include <linux/mfd/intel-m10-bmc.h>
+#include <linux/module.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+
+#define NUM_CHIP	2
+#define MAX_LINK	4
+
+#define BITS_MASK(nbits)	((1 << (nbits)) - 1)
+
+#define N3000BMC_RETIMER_DEV_NAME "n3000bmc-retimer"
+#define M10BMC_RETIMER_MII_NAME "m10bmc retimer mii"
+
+struct m10bmc_retimer {
+	struct device *dev;
+	struct intel_m10bmc *m10bmc;
+	int num_devs;
+	struct device *base_dev;
+	struct mii_bus *retimer_mii_bus;
+};
+
+#define RETIMER_LINK_STAT_BIT(retimer_id, link_id) \
+	BIT(((retimer_id) << 2) + (link_id))
+
+static u32 retimer_get_link(struct m10bmc_retimer *retimer, int index)
+{
+	unsigned int val;
+
+	if (m10bmc_sys_read(retimer->m10bmc, PKVL_LINK_STATUS, &val)) {
+		dev_err(retimer->dev, "fail to read PKVL_LINK_STATUS\n");
+		return 0;
+	}
+
+	if (val & BIT(index))
+		return 1;
+
+	return 0;
+}
+
+static int m10bmc_retimer_phy_match(struct phy_device *phydev)
+{
+	if (phydev->mdio.bus->name &&
+	    !strcmp(phydev->mdio.bus->name, M10BMC_RETIMER_MII_NAME)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+static int m10bmc_retimer_phy_probe(struct phy_device *phydev)
+{
+	struct m10bmc_retimer *retimer = phydev->mdio.bus->priv;
+
+	phydev->priv = retimer;
+
+	return 0;
+}
+
+static void m10bmc_retimer_phy_remove(struct phy_device *phydev)
+{
+	if (phydev->attached_dev)
+		phy_disconnect(phydev);
+}
+
+static int m10bmc_retimer_read_status(struct phy_device *phydev)
+{
+	struct m10bmc_retimer *retimer = phydev->priv;
+
+	phydev->link = retimer_get_link(retimer, phydev->mdio.addr);
+
+	phydev->duplex = DUPLEX_FULL;
+
+	return 0;
+}
+
+static int m10bmc_retimer_get_features(struct phy_device *phydev)
+{
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseSR_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_10000baseLR_Full_BIT,
+			 phydev->supported);
+
+	linkmode_set_bit(ETHTOOL_LINK_MODE_25000baseCR_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_25000baseSR_Full_BIT,
+			 phydev->supported);
+
+	linkmode_set_bit(ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT,
+			 phydev->supported);
+	linkmode_set_bit(ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT,
+			 phydev->supported);
+
+	linkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->supported);
+
+	return 0;
+}
+
+static struct phy_driver m10bmc_retimer_phy_driver = {
+	.phy_id			= 0xffffffff,
+	.phy_id_mask		= 0xffffffff,
+	.name			= "m10bmc retimer PHY",
+	.match_phy_device	= m10bmc_retimer_phy_match,
+	.probe			= m10bmc_retimer_phy_probe,
+	.remove			= m10bmc_retimer_phy_remove,
+	.read_status		= m10bmc_retimer_read_status,
+	.get_features		= m10bmc_retimer_get_features,
+	.read_mmd		= genphy_read_mmd_unsupported,
+	.write_mmd		= genphy_write_mmd_unsupported,
+};
+
+static int m10bmc_retimer_read(struct mii_bus *bus, int addr, int regnum)
+{
+	struct m10bmc_retimer *retimer = bus->priv;
+
+	if (addr < retimer->num_devs &&
+	    (regnum == MII_PHYSID1 || regnum == MII_PHYSID2))
+		return 0;
+
+	return 0xffff;
+}
+
+static int m10bmc_retimer_write(struct mii_bus *bus, int addr, int regnum, u16 val)
+{
+	return 0;
+}
+
+static int m10bmc_retimer_mii_bus_init(struct m10bmc_retimer *retimer)
+{
+	struct mii_bus *bus;
+	int ret;
+
+	bus = devm_mdiobus_alloc(retimer->dev);
+	if (!bus)
+		return -ENOMEM;
+
+	bus->priv = (void *)retimer;
+	bus->name = M10BMC_RETIMER_MII_NAME;
+	bus->read = m10bmc_retimer_read;
+	bus->write = m10bmc_retimer_write;
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-mii",
+		 dev_name(retimer->base_dev));
+	bus->parent = retimer->dev;
+	bus->phy_mask = ~(BITS_MASK(retimer->num_devs));
+
+	ret = mdiobus_register(bus);
+	if (ret)
+		return ret;
+
+	retimer->retimer_mii_bus = bus;
+
+	return 0;
+}
+
+static void m10bmc_retimer_mii_bus_uinit(struct m10bmc_retimer *retimer)
+{
+	mdiobus_unregister(retimer->retimer_mii_bus);
+}
+
+static int intel_m10bmc_retimer_probe(struct platform_device *pdev)
+{
+	struct intel_m10bmc_retimer_pdata *pdata = dev_get_platdata(&pdev->dev);
+	struct intel_m10bmc *m10bmc = dev_get_drvdata(pdev->dev.parent);
+	struct m10bmc_retimer *retimer;
+
+	retimer = devm_kzalloc(&pdev->dev, sizeof(*retimer), GFP_KERNEL);
+	if (!retimer)
+		return -ENOMEM;
+
+	dev_set_drvdata(&pdev->dev, retimer);
+
+	retimer->dev = &pdev->dev;
+	retimer->m10bmc = m10bmc;
+	retimer->base_dev = pdata->retimer_master;
+	retimer->num_devs = NUM_CHIP * MAX_LINK;
+
+	return m10bmc_retimer_mii_bus_init(retimer);
+}
+
+static int intel_m10bmc_retimer_remove(struct platform_device *pdev)
+{
+	struct m10bmc_retimer *retimer = dev_get_drvdata(&pdev->dev);
+
+	m10bmc_retimer_mii_bus_uinit(retimer);
+
+	return 0;
+}
+
+static struct platform_driver intel_m10bmc_retimer_driver = {
+	.probe = intel_m10bmc_retimer_probe,
+	.remove = intel_m10bmc_retimer_remove,
+	.driver = {
+		.name = N3000BMC_RETIMER_DEV_NAME,
+	},
+};
+
+static int __init intel_m10bmc_retimer_init(void)
+{
+	int ret;
+
+	ret = phy_driver_register(&m10bmc_retimer_phy_driver, THIS_MODULE);
+	if (ret)
+		return ret;
+
+	return platform_driver_register(&intel_m10bmc_retimer_driver);
+}
+module_init(intel_m10bmc_retimer_init);
+
+static void __exit intel_m10bmc_retimer_exit(void)
+{
+	platform_driver_unregister(&intel_m10bmc_retimer_driver);
+	phy_driver_unregister(&m10bmc_retimer_phy_driver);
+}
+module_exit(intel_m10bmc_retimer_exit);
+
+MODULE_ALIAS("platform:" N3000BMC_RETIMER_DEV_NAME);
+MODULE_AUTHOR("Intel Corporation");
+MODULE_DESCRIPTION("Intel MAX 10 BMC retimer driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/mfd/intel-m10-bmc.h b/include/linux/mfd/intel-m10-bmc.h
index c8ef2f1654a4..3d9d22c94ae2 100644
--- org/include/linux/mfd/intel-m10-bmc.h
+++ new/include/linux/mfd/intel-m10-bmc.h
@@ -21,6 +21,22 @@
 #define M10BMC_VER_PCB_INFO_MSK		GENMASK(31, 24)
 #define M10BMC_VER_LEGACY_INVALID	0xffffffff
 
+/* PKVL related registers, in system register region */
+#define PKVL_LINK_STATUS		0x164
+
+/**
+ * struct intel_m10bmc_retimer_pdata - subdev retimer platform data
+ *
+ * @retimer_master: the NIC device which connects to the retimers on m10bmc
+ */
+struct intel_m10bmc_retimer_pdata {
+	struct device *retimer_master;
+};
+
+struct intel_m10bmc_platdata {
+	struct intel_m10bmc_retimer_pdata *retimer;
+};
+
 /**
  * struct intel_m10bmc - Intel MAX 10 BMC parent driver data structure
  * @dev: this device
-- 
2.34.1

