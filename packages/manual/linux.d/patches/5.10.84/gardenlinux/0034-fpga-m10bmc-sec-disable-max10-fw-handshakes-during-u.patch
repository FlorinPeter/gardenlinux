From 983ee466ae13de95a54fa286447525a7e952568b Mon Sep 17 00:00:00 2001
From: Russ Weight <russell.h.weight@intel.com>
Date: Wed, 28 Oct 2020 15:50:52 -0700
Subject: [PATCH 34/39] fpga: m10bmc-sec: disable max10 fw handshakes during
 update

Disable accesses to NIOS FW handshake registers during a secure
update. During updates, the NIOS soft processor is fully occupied
and is unable to respond to handshakes.

Signed-off-by: Russ Weight <russell.h.weight@intel.com>
---
 drivers/fpga/intel-m10-bmc-secure.c | 63 +++++++++++++++++------------
 1 file changed, 38 insertions(+), 25 deletions(-)

diff --git a/drivers/fpga/intel-m10-bmc-secure.c b/drivers/fpga/intel-m10-bmc-secure.c
index df88a3346b45..3a5d9f2c2878 100644
--- org/drivers/fpga/intel-m10-bmc-secure.c
+++ new/drivers/fpga/intel-m10-bmc-secure.c
@@ -264,12 +264,11 @@ static enum fpga_sec_err rsu_update_init(struct m10bmc_sec *sec)
 	u32 doorbell, status;
 	int ret;
 
-	ret = regmap_update_bits(sec->m10bmc->regmap,
-				 M10BMC_SYS_BASE + M10BMC_DOORBELL,
-				 DRBL_RSU_REQUEST | DRBL_HOST_STATUS,
-				 DRBL_RSU_REQUEST |
-				 FIELD_PREP(DRBL_HOST_STATUS,
-					    HOST_STATUS_IDLE));
+	ret = m10bmc_sys_update_bits(sec->m10bmc, M10BMC_DOORBELL,
+				     DRBL_RSU_REQUEST | DRBL_HOST_STATUS,
+				     DRBL_RSU_REQUEST |
+				     FIELD_PREP(DRBL_HOST_STATUS,
+						HOST_STATUS_IDLE));
 	if (ret)
 		return FPGA_SEC_ERR_RW_ERROR;
 
@@ -337,11 +336,10 @@ static enum fpga_sec_err rsu_send_data(struct m10bmc_sec *sec)
 	u32 doorbell;
 	int ret;
 
-	ret = regmap_update_bits(sec->m10bmc->regmap,
-				 M10BMC_SYS_BASE + M10BMC_DOORBELL,
-				 DRBL_HOST_STATUS,
-				 FIELD_PREP(DRBL_HOST_STATUS,
-					    HOST_STATUS_WRITE_DONE));
+	ret = m10bmc_sys_update_bits(sec->m10bmc, M10BMC_DOORBELL,
+				     DRBL_HOST_STATUS,
+				     FIELD_PREP(DRBL_HOST_STATUS,
+						HOST_STATUS_WRITE_DONE));
 	if (ret)
 		return FPGA_SEC_ERR_RW_ERROR;
 
@@ -415,11 +413,19 @@ static enum fpga_sec_err m10bmc_sec_prepare(struct fpga_sec_mgr *smgr)
 	if (ret != FPGA_SEC_ERR_NONE)
 		return ret;
 
+	ret = m10bmc_fw_state_enter(sec->m10bmc, M10BMC_FW_STATE_SEC_UPDATE);
+	if (ret)
+		return FPGA_SEC_ERR_BUSY;
+
 	ret = rsu_update_init(sec);
 	if (ret != FPGA_SEC_ERR_NONE)
-		return ret;
+		goto fw_state_exit;
 
-	return rsu_prog_ready(sec);
+	ret = rsu_prog_ready(sec);
+
+fw_state_exit:
+	m10bmc_fw_state_exit(sec->m10bmc);
+	return ret;
 }
 
 static enum fpga_sec_err
@@ -462,9 +468,13 @@ static enum fpga_sec_err m10bmc_sec_poll_complete(struct fpga_sec_mgr *smgr)
 	u32 doorbell;
 	int ret;
 
+	ret = m10bmc_fw_state_enter(sec->m10bmc, M10BMC_FW_STATE_SEC_UPDATE);
+	if (ret)
+		return FPGA_SEC_ERR_BUSY;
+
 	result = rsu_send_data(sec);
 	if (result != FPGA_SEC_ERR_NONE)
-		return result;
+		goto fw_state_exit;
 
 	ret = rsu_check_complete(sec, &doorbell);
 	poll_timeout = jiffies + msecs_to_jiffies(RSU_COMPLETE_TIMEOUT_MS);
@@ -472,21 +482,25 @@ static enum fpga_sec_err m10bmc_sec_poll_complete(struct fpga_sec_mgr *smgr)
 	while (ret == -EAGAIN && !time_after(jiffies, poll_timeout)) {
 		msleep(RSU_COMPLETE_INTERVAL_MS);
 		ret = rsu_check_complete(sec, &doorbell);
-		if (smgr->driver_unload)
-			return FPGA_SEC_ERR_CANCELED;
+		if (smgr->driver_unload) {
+			result = FPGA_SEC_ERR_CANCELED;
+			goto fw_state_exit;
+		}
 	}
 
 	if (ret == -EAGAIN) {
 		log_error_regs(sec, doorbell);
-		return FPGA_SEC_ERR_TIMEOUT;
+		result = FPGA_SEC_ERR_TIMEOUT;
 	} else if (ret == -EIO) {
-		return FPGA_SEC_ERR_RW_ERROR;
+		result = FPGA_SEC_ERR_RW_ERROR;
 	} else if (ret) {
 		log_error_regs(sec, doorbell);
-		return FPGA_SEC_ERR_HW_ERROR;
+		result = FPGA_SEC_ERR_HW_ERROR;
 	}
 
-	return FPGA_SEC_ERR_NONE;
+fw_state_exit:
+	m10bmc_fw_state_exit(sec->m10bmc);
+	return result;
 }
 
 static enum fpga_sec_err m10bmc_sec_cancel(struct fpga_sec_mgr *smgr)
@@ -502,11 +516,10 @@ static enum fpga_sec_err m10bmc_sec_cancel(struct fpga_sec_mgr *smgr)
 	if (rsu_prog(doorbell) != RSU_PROG_READY)
 		return FPGA_SEC_ERR_BUSY;
 
-	ret = regmap_update_bits(sec->m10bmc->regmap,
-				 M10BMC_SYS_BASE + M10BMC_DOORBELL,
-				 DRBL_HOST_STATUS,
-				 FIELD_PREP(DRBL_HOST_STATUS,
-					    HOST_STATUS_ABORT_RSU));
+	ret = m10bmc_sys_update_bits(sec->m10bmc, M10BMC_DOORBELL,
+				     DRBL_HOST_STATUS,
+				     FIELD_PREP(DRBL_HOST_STATUS,
+						HOST_STATUS_ABORT_RSU));
 
 	return ret ? FPGA_SEC_ERR_RW_ERROR : FPGA_SEC_ERR_NONE;
 }
-- 
2.34.1

